import {
  $addNodeStyle,
  $cloneWithProperties,
  $moveCharacter,
  $shouldOverrideDefaultCharacterSelection,
  $sliceSelectedTextNodeContent,
  isHTMLElement,
  mergeRegister,
  objectKlassEquals
} from "./chunk-HN4TTGCX.js";
import {
  require_react_dom
} from "./chunk-CAK4BOIH.js";
import {
  $createTabNode,
  $createTextNode,
  $getRoot,
  $getSelection,
  $isDecoratorNode,
  $isElementNode,
  $isParagraphNode,
  $isRangeSelection,
  $isTextNode,
  $parseSerializedNode,
  $selectAll,
  COMMAND_PRIORITY_CRITICAL,
  COMMAND_PRIORITY_EDITOR,
  CONTROLLED_TEXT_INSERTION_COMMAND,
  COPY_COMMAND,
  CUT_COMMAND,
  DELETE_CHARACTER_COMMAND,
  DELETE_LINE_COMMAND,
  DELETE_WORD_COMMAND,
  DRAGSTART_COMMAND,
  DROP_COMMAND,
  INSERT_LINE_BREAK_COMMAND,
  INSERT_PARAGRAPH_COMMAND,
  KEY_ARROW_LEFT_COMMAND,
  KEY_ARROW_RIGHT_COMMAND,
  KEY_BACKSPACE_COMMAND,
  KEY_DELETE_COMMAND,
  KEY_ENTER_COMMAND,
  PASTE_COMMAND,
  REMOVE_TEXT_COMMAND,
  SELECTION_INSERT_CLIPBOARD_NODES_COMMAND,
  SELECT_ALL_COMMAND,
  TextNode,
  isSelectionWithinEditor
} from "./chunk-BYXBVZT6.js";
import {
  useLexicalComposerContext
} from "./chunk-TSURQBAX.js";
import {
  require_react
} from "./chunk-2VROJHEF.js";
import {
  __export,
  __toESM
} from "./chunk-HL2QZUHZ.js";

// node_modules/.pnpm/@lexical+react@0.14.2_lexical@0.14.2_react-dom@18.2.0_react@18.2.0_yjs@13.6.14/node_modules/@lexical/react/LexicalPlainTextPlugin.dev.esm.js
var LexicalPlainTextPlugin_dev_esm_exports = {};
__export(LexicalPlainTextPlugin_dev_esm_exports, {
  PlainTextPlugin: () => PlainTextPlugin
});

// node_modules/.pnpm/@lexical+react@0.14.2_lexical@0.14.2_react-dom@18.2.0_react@18.2.0_yjs@13.6.14/node_modules/@lexical/react/useLexicalEditable.dev.esm.js
var useLexicalEditable_dev_esm_exports = {};
__export(useLexicalEditable_dev_esm_exports, {
  default: () => useLexicalEditable
});
var import_react = __toESM(require_react());
var CAN_USE_DOM = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
var useLayoutEffectImpl = CAN_USE_DOM ? import_react.useLayoutEffect : import_react.useEffect;
var useLayoutEffect = useLayoutEffectImpl;
function useLexicalSubscription(subscription2) {
  const [editor] = useLexicalComposerContext();
  const initializedSubscription = (0, import_react.useMemo)(() => subscription2(editor), [editor, subscription2]);
  const valueRef = (0, import_react.useRef)(initializedSubscription.initialValueFn());
  const [value, setValue] = (0, import_react.useState)(valueRef.current);
  useLayoutEffect(() => {
    const {
      initialValueFn,
      subscribe
    } = initializedSubscription;
    const currentValue = initialValueFn();
    if (valueRef.current !== currentValue) {
      valueRef.current = currentValue;
      setValue(currentValue);
    }
    return subscribe((newValue) => {
      valueRef.current = newValue;
      setValue(newValue);
    });
  }, [initializedSubscription, subscription2]);
  return value;
}
function subscription(editor) {
  return {
    initialValueFn: () => editor.isEditable(),
    subscribe: (callback) => {
      return editor.registerEditableListener(callback);
    }
  };
}
function useLexicalEditable() {
  return useLexicalSubscription(subscription);
}

// node_modules/.pnpm/@lexical+react@0.14.2_lexical@0.14.2_react-dom@18.2.0_react@18.2.0_yjs@13.6.14/node_modules/@lexical/react/useLexicalEditable.prod.esm.js
var import_react2 = __toESM(require_react());
var u = "undefined" != typeof window && void 0 !== window.document && void 0 !== window.document.createElement ? import_react2.useLayoutEffect : import_react2.useEffect;

// node_modules/.pnpm/@lexical+react@0.14.2_lexical@0.14.2_react-dom@18.2.0_react@18.2.0_yjs@13.6.14/node_modules/@lexical/react/useLexicalEditable.esm.js
var mod = true ? useLexicalEditable_dev_esm_exports : useLexicalEditable_prod_esm_exports;
var useLexicalEditable_esm_default = mod.default;

// node_modules/.pnpm/@lexical+react@0.14.2_lexical@0.14.2_react-dom@18.2.0_react@18.2.0_yjs@13.6.14/node_modules/@lexical/react/LexicalPlainTextPlugin.dev.esm.js
var React = __toESM(require_react());
var import_react3 = __toESM(require_react());

// node_modules/.pnpm/@lexical+text@0.14.2_lexical@0.14.2/node_modules/@lexical/text/LexicalText.dev.esm.js
var LexicalText_dev_esm_exports = {};
__export(LexicalText_dev_esm_exports, {
  $canShowPlaceholder: () => $canShowPlaceholder,
  $canShowPlaceholderCurry: () => $canShowPlaceholderCurry,
  $findTextIntersectionFromCharacters: () => $findTextIntersectionFromCharacters,
  $isRootTextContentEmpty: () => $isRootTextContentEmpty,
  $isRootTextContentEmptyCurry: () => $isRootTextContentEmptyCurry,
  $rootTextContent: () => $rootTextContent,
  registerLexicalTextEntity: () => registerLexicalTextEntity
});
function $findTextIntersectionFromCharacters(root, targetCharacters) {
  let node = root.getFirstChild();
  let currentCharacters = 0;
  mainLoop:
    while (node !== null) {
      if ($isElementNode(node)) {
        const child = node.getFirstChild();
        if (child !== null) {
          node = child;
          continue;
        }
      } else if ($isTextNode(node)) {
        const characters = node.getTextContentSize();
        if (currentCharacters + characters > targetCharacters) {
          return {
            node,
            offset: targetCharacters - currentCharacters
          };
        }
        currentCharacters += characters;
      }
      const sibling = node.getNextSibling();
      if (sibling !== null) {
        node = sibling;
        continue;
      }
      let parent = node.getParent();
      while (parent !== null) {
        const parentSibling = parent.getNextSibling();
        if (parentSibling !== null) {
          node = parentSibling;
          continue mainLoop;
        }
        parent = parent.getParent();
      }
      break;
    }
  return null;
}
function $isRootTextContentEmpty(isEditorComposing, trim = true) {
  if (isEditorComposing) {
    return false;
  }
  let text = $rootTextContent();
  if (trim) {
    text = text.trim();
  }
  return text === "";
}
function $isRootTextContentEmptyCurry(isEditorComposing, trim) {
  return () => $isRootTextContentEmpty(isEditorComposing, trim);
}
function $rootTextContent() {
  const root = $getRoot();
  return root.getTextContent();
}
function $canShowPlaceholder(isComposing) {
  if (!$isRootTextContentEmpty(isComposing, false)) {
    return false;
  }
  const root = $getRoot();
  const children = root.getChildren();
  const childrenLength = children.length;
  if (childrenLength > 1) {
    return false;
  }
  for (let i3 = 0; i3 < childrenLength; i3++) {
    const topBlock = children[i3];
    if ($isDecoratorNode(topBlock)) {
      return false;
    }
    if ($isElementNode(topBlock)) {
      if (!$isParagraphNode(topBlock)) {
        return false;
      }
      if (topBlock.__indent !== 0) {
        return false;
      }
      const topBlockChildren = topBlock.getChildren();
      const topBlockChildrenLength = topBlockChildren.length;
      for (let s2 = 0; s2 < topBlockChildrenLength; s2++) {
        const child = topBlockChildren[i3];
        if (!$isTextNode(child)) {
          return false;
        }
      }
    }
  }
  return true;
}
function $canShowPlaceholderCurry(isEditorComposing) {
  return () => $canShowPlaceholder(isEditorComposing);
}
function registerLexicalTextEntity(editor, getMatch, targetNode, createNode) {
  const isTargetNode = (node) => {
    return node instanceof targetNode;
  };
  const replaceWithSimpleText = (node) => {
    const textNode = $createTextNode(node.getTextContent());
    textNode.setFormat(node.getFormat());
    node.replace(textNode);
  };
  const getMode = (node) => {
    return node.getLatest().__mode;
  };
  const textNodeTransform = (node) => {
    if (!node.isSimpleText()) {
      return;
    }
    const prevSibling = node.getPreviousSibling();
    let text = node.getTextContent();
    let currentNode = node;
    let match;
    if ($isTextNode(prevSibling)) {
      const previousText = prevSibling.getTextContent();
      const combinedText = previousText + text;
      const prevMatch = getMatch(combinedText);
      if (isTargetNode(prevSibling)) {
        if (prevMatch === null || getMode(prevSibling) !== 0) {
          replaceWithSimpleText(prevSibling);
          return;
        } else {
          const diff = prevMatch.end - previousText.length;
          if (diff > 0) {
            const concatText = text.slice(0, diff);
            const newTextContent = previousText + concatText;
            prevSibling.select();
            prevSibling.setTextContent(newTextContent);
            if (diff === text.length) {
              node.remove();
            } else {
              const remainingText = text.slice(diff);
              node.setTextContent(remainingText);
            }
            return;
          }
        }
      } else if (prevMatch === null || prevMatch.start < previousText.length) {
        return;
      }
    }
    while (true) {
      match = getMatch(text);
      let nextText = match === null ? "" : text.slice(match.end);
      text = nextText;
      if (nextText === "") {
        const nextSibling = currentNode.getNextSibling();
        if ($isTextNode(nextSibling)) {
          nextText = currentNode.getTextContent() + nextSibling.getTextContent();
          const nextMatch = getMatch(nextText);
          if (nextMatch === null) {
            if (isTargetNode(nextSibling)) {
              replaceWithSimpleText(nextSibling);
            } else {
              nextSibling.markDirty();
            }
            return;
          } else if (nextMatch.start !== 0) {
            return;
          }
        }
      } else {
        const nextMatch = getMatch(nextText);
        if (nextMatch !== null && nextMatch.start === 0) {
          return;
        }
      }
      if (match === null) {
        return;
      }
      if (match.start === 0 && $isTextNode(prevSibling) && prevSibling.isTextEntity()) {
        continue;
      }
      let nodeToReplace;
      if (match.start === 0) {
        [nodeToReplace, currentNode] = currentNode.splitText(match.end);
      } else {
        [, nodeToReplace, currentNode] = currentNode.splitText(match.start, match.end);
      }
      const replacementNode = createNode(nodeToReplace);
      replacementNode.setFormat(nodeToReplace.getFormat());
      nodeToReplace.replace(replacementNode);
      if (currentNode == null) {
        return;
      }
    }
  };
  const reverseNodeTransform = (node) => {
    const text = node.getTextContent();
    const match = getMatch(text);
    if (match === null || match.start !== 0) {
      replaceWithSimpleText(node);
      return;
    }
    if (text.length > match.end) {
      node.splitText(match.end);
      return;
    }
    const prevSibling = node.getPreviousSibling();
    if ($isTextNode(prevSibling) && prevSibling.isTextEntity()) {
      replaceWithSimpleText(prevSibling);
      replaceWithSimpleText(node);
    }
    const nextSibling = node.getNextSibling();
    if ($isTextNode(nextSibling) && nextSibling.isTextEntity()) {
      replaceWithSimpleText(nextSibling);
      if (isTargetNode(node)) {
        replaceWithSimpleText(node);
      }
    }
  };
  const removePlainTextTransform = editor.registerNodeTransform(TextNode, textNodeTransform);
  const removeReverseNodeTransform = editor.registerNodeTransform(targetNode, reverseNodeTransform);
  return [removePlainTextTransform, removeReverseNodeTransform];
}

// node_modules/.pnpm/@lexical+text@0.14.2_lexical@0.14.2/node_modules/@lexical/text/LexicalText.esm.js
var mod2 = true ? LexicalText_dev_esm_exports : LexicalText_prod_esm_exports;
var $canShowPlaceholder2 = mod2.$canShowPlaceholder;
var $canShowPlaceholderCurry2 = mod2.$canShowPlaceholderCurry;
var $findTextIntersectionFromCharacters2 = mod2.$findTextIntersectionFromCharacters;
var $isRootTextContentEmpty2 = mod2.$isRootTextContentEmpty;
var $isRootTextContentEmptyCurry2 = mod2.$isRootTextContentEmptyCurry;
var $rootTextContent2 = mod2.$rootTextContent;
var registerLexicalTextEntity2 = mod2.registerLexicalTextEntity;

// node_modules/.pnpm/@lexical+react@0.14.2_lexical@0.14.2_react-dom@18.2.0_react@18.2.0_yjs@13.6.14/node_modules/@lexical/react/LexicalPlainTextPlugin.dev.esm.js
var import_react_dom = __toESM(require_react_dom());

// node_modules/.pnpm/@lexical+dragon@0.14.2_lexical@0.14.2/node_modules/@lexical/dragon/LexicalDragon.dev.esm.js
var LexicalDragon_dev_esm_exports = {};
__export(LexicalDragon_dev_esm_exports, {
  registerDragonSupport: () => registerDragonSupport
});
function registerDragonSupport(editor) {
  const origin = window.location.origin;
  const handler = (event) => {
    if (event.origin !== origin) {
      return;
    }
    const rootElement = editor.getRootElement();
    if (document.activeElement !== rootElement) {
      return;
    }
    const data = event.data;
    if (typeof data === "string") {
      let parsedData;
      try {
        parsedData = JSON.parse(data);
      } catch (e) {
        return;
      }
      if (parsedData && parsedData.protocol === "nuanria_messaging" && parsedData.type === "request") {
        const payload = parsedData.payload;
        if (payload && payload.functionId === "makeChanges") {
          const args = payload.args;
          if (args) {
            const [elementStart, elementLength, text, selStart, selLength, formatCommand] = args;
            editor.update(() => {
              const selection = $getSelection();
              if ($isRangeSelection(selection)) {
                const anchor = selection.anchor;
                let anchorNode = anchor.getNode();
                let setSelStart = 0;
                let setSelEnd = 0;
                if ($isTextNode(anchorNode)) {
                  if (elementStart >= 0 && elementLength >= 0) {
                    setSelStart = elementStart;
                    setSelEnd = elementStart + elementLength;
                    selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);
                  }
                }
                if (setSelStart !== setSelEnd || text !== "") {
                  selection.insertRawText(text);
                  anchorNode = anchor.getNode();
                }
                if ($isTextNode(anchorNode)) {
                  setSelStart = selStart;
                  setSelEnd = selStart + selLength;
                  const anchorNodeTextLength = anchorNode.getTextContentSize();
                  setSelStart = setSelStart > anchorNodeTextLength ? anchorNodeTextLength : setSelStart;
                  setSelEnd = setSelEnd > anchorNodeTextLength ? anchorNodeTextLength : setSelEnd;
                  selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);
                }
                event.stopImmediatePropagation();
              }
            });
          }
        }
      }
    }
  };
  window.addEventListener("message", handler, true);
  return () => {
    window.removeEventListener("message", handler, true);
  };
}

// node_modules/.pnpm/@lexical+dragon@0.14.2_lexical@0.14.2/node_modules/@lexical/dragon/LexicalDragon.esm.js
var mod3 = true ? LexicalDragon_dev_esm_exports : LexicalDragon_prod_esm_exports;
var registerDragonSupport2 = mod3.registerDragonSupport;

// node_modules/.pnpm/@lexical+plain-text@0.14.2_@lexical+clipboard@0.14.2_@lexical+selection@0.14.2_@lexical+utils@0.14.2_lexical@0.14.2/node_modules/@lexical/plain-text/LexicalPlainText.dev.esm.js
var LexicalPlainText_dev_esm_exports = {};
__export(LexicalPlainText_dev_esm_exports, {
  registerPlainText: () => registerPlainText
});

// node_modules/.pnpm/@lexical+clipboard@0.14.2_lexical@0.14.2/node_modules/@lexical/clipboard/LexicalClipboard.dev.esm.js
var LexicalClipboard_dev_esm_exports = {};
__export(LexicalClipboard_dev_esm_exports, {
  $generateJSONFromSelectedNodes: () => $generateJSONFromSelectedNodes,
  $generateNodesFromSerializedNodes: () => $generateNodesFromSerializedNodes,
  $getHtmlContent: () => $getHtmlContent,
  $getLexicalContent: () => $getLexicalContent,
  $insertDataTransferForPlainText: () => $insertDataTransferForPlainText,
  $insertDataTransferForRichText: () => $insertDataTransferForRichText,
  $insertGeneratedNodes: () => $insertGeneratedNodes,
  copyToClipboard: () => copyToClipboard
});

// node_modules/.pnpm/@lexical+html@0.14.2_lexical@0.14.2/node_modules/@lexical/html/LexicalHtml.dev.esm.js
var LexicalHtml_dev_esm_exports = {};
__export(LexicalHtml_dev_esm_exports, {
  $generateHtmlFromNodes: () => $generateHtmlFromNodes,
  $generateNodesFromDOM: () => $generateNodesFromDOM
});
function $generateNodesFromDOM(editor, dom) {
  const elements = dom.body ? dom.body.childNodes : [];
  let lexicalNodes = [];
  for (let i3 = 0; i3 < elements.length; i3++) {
    const element = elements[i3];
    if (!IGNORE_TAGS.has(element.nodeName)) {
      const lexicalNode = $createNodesFromDOM(element, editor);
      if (lexicalNode !== null) {
        lexicalNodes = lexicalNodes.concat(lexicalNode);
      }
    }
  }
  return lexicalNodes;
}
function $generateHtmlFromNodes(editor, selection) {
  if (typeof document === "undefined" || typeof window === "undefined" && typeof global.window === "undefined") {
    throw new Error("To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.");
  }
  const container = document.createElement("div");
  const root = $getRoot();
  const topLevelChildren = root.getChildren();
  for (let i3 = 0; i3 < topLevelChildren.length; i3++) {
    const topLevelNode = topLevelChildren[i3];
    $appendNodesToHTML(editor, topLevelNode, container, selection);
  }
  return container.innerHTML;
}
function $appendNodesToHTML(editor, currentNode, parentElement, selection = null) {
  let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;
  const shouldExclude = $isElementNode(currentNode) && currentNode.excludeFromCopy("html");
  let target = currentNode;
  if (selection !== null) {
    let clone = $cloneWithProperties(currentNode);
    clone = $isTextNode(clone) && selection !== null ? $sliceSelectedTextNodeContent(selection, clone) : clone;
    target = clone;
  }
  const children = $isElementNode(target) ? target.getChildren() : [];
  const registeredNode = editor._nodes.get(target.getType());
  let exportOutput;
  if (registeredNode && registeredNode.exportDOM !== void 0) {
    exportOutput = registeredNode.exportDOM(editor, target);
  } else {
    exportOutput = target.exportDOM(editor);
  }
  const {
    element,
    after
  } = exportOutput;
  if (!element) {
    return false;
  }
  const fragment = document.createDocumentFragment();
  for (let i3 = 0; i3 < children.length; i3++) {
    const childNode = children[i3];
    const shouldIncludeChild = $appendNodesToHTML(editor, childNode, fragment, selection);
    if (!shouldInclude && $isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, "html")) {
      shouldInclude = true;
    }
  }
  if (shouldInclude && !shouldExclude) {
    if (isHTMLElement(element)) {
      element.append(fragment);
    }
    parentElement.append(element);
    if (after) {
      const newElement = after.call(target, element);
      if (newElement) {
        element.replaceWith(newElement);
      }
    }
  } else {
    parentElement.append(fragment);
  }
  return shouldInclude;
}
function getConversionFunction(domNode, editor) {
  const {
    nodeName
  } = domNode;
  const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());
  let currentConversion = null;
  if (cachedConversions !== void 0) {
    for (const cachedConversion of cachedConversions) {
      const domConversion = cachedConversion(domNode);
      if (domConversion !== null && (currentConversion === null || (currentConversion.priority || 0) < (domConversion.priority || 0))) {
        currentConversion = domConversion;
      }
    }
  }
  return currentConversion !== null ? currentConversion.conversion : null;
}
var IGNORE_TAGS = /* @__PURE__ */ new Set(["STYLE", "SCRIPT"]);
function $createNodesFromDOM(node, editor, forChildMap = /* @__PURE__ */ new Map(), parentLexicalNode) {
  let lexicalNodes = [];
  if (IGNORE_TAGS.has(node.nodeName)) {
    return lexicalNodes;
  }
  let currentLexicalNode = null;
  const transformFunction = getConversionFunction(node, editor);
  const transformOutput = transformFunction ? transformFunction(node) : null;
  let postTransform = null;
  if (transformOutput !== null) {
    postTransform = transformOutput.after;
    const transformNodes = transformOutput.node;
    currentLexicalNode = Array.isArray(transformNodes) ? transformNodes[transformNodes.length - 1] : transformNodes;
    if (currentLexicalNode !== null) {
      for (const [, forChildFunction] of forChildMap) {
        currentLexicalNode = forChildFunction(currentLexicalNode, parentLexicalNode);
        if (!currentLexicalNode) {
          break;
        }
      }
      if (currentLexicalNode) {
        lexicalNodes.push(...Array.isArray(transformNodes) ? transformNodes : [currentLexicalNode]);
      }
    }
    if (transformOutput.forChild != null) {
      forChildMap.set(node.nodeName, transformOutput.forChild);
    }
  }
  const children = node.childNodes;
  let childLexicalNodes = [];
  for (let i3 = 0; i3 < children.length; i3++) {
    childLexicalNodes.push(...$createNodesFromDOM(children[i3], editor, new Map(forChildMap), currentLexicalNode));
  }
  if (postTransform != null) {
    childLexicalNodes = postTransform(childLexicalNodes);
  }
  if (currentLexicalNode == null) {
    lexicalNodes = lexicalNodes.concat(childLexicalNodes);
  } else {
    if ($isElementNode(currentLexicalNode)) {
      currentLexicalNode.append(...childLexicalNodes);
    }
  }
  return lexicalNodes;
}

// node_modules/.pnpm/@lexical+html@0.14.2_lexical@0.14.2/node_modules/@lexical/html/LexicalHtml.esm.js
var mod4 = true ? LexicalHtml_dev_esm_exports : LexicalHtml_prod_esm_exports;
var $generateHtmlFromNodes2 = mod4.$generateHtmlFromNodes;
var $generateNodesFromDOM2 = mod4.$generateNodesFromDOM;

// node_modules/.pnpm/@lexical+clipboard@0.14.2_lexical@0.14.2/node_modules/@lexical/clipboard/LexicalClipboard.dev.esm.js
var CAN_USE_DOM2 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
var getDOMSelection = (targetWindow) => CAN_USE_DOM2 ? (targetWindow || window).getSelection() : null;
function $getHtmlContent(editor) {
  const selection = $getSelection();
  if (selection == null) {
    {
      throw Error(`Expected valid LexicalSelection`);
    }
  }
  if ($isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {
    return "";
  }
  return $generateHtmlFromNodes2(editor, selection);
}
function $getLexicalContent(editor) {
  const selection = $getSelection();
  if (selection == null) {
    {
      throw Error(`Expected valid LexicalSelection`);
    }
  }
  if ($isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {
    return null;
  }
  return JSON.stringify($generateJSONFromSelectedNodes(editor, selection));
}
function $insertDataTransferForPlainText(dataTransfer, selection) {
  const text = dataTransfer.getData("text/plain") || dataTransfer.getData("text/uri-list");
  if (text != null) {
    selection.insertRawText(text);
  }
}
function $insertDataTransferForRichText(dataTransfer, selection, editor) {
  const lexicalString = dataTransfer.getData("application/x-lexical-editor");
  if (lexicalString) {
    try {
      const payload = JSON.parse(lexicalString);
      if (payload.namespace === editor._config.namespace && Array.isArray(payload.nodes)) {
        const nodes = $generateNodesFromSerializedNodes(payload.nodes);
        return $insertGeneratedNodes(editor, nodes, selection);
      }
    } catch (_unused) {
    }
  }
  const htmlString = dataTransfer.getData("text/html");
  if (htmlString) {
    try {
      const parser = new DOMParser();
      const dom = parser.parseFromString(htmlString, "text/html");
      const nodes = $generateNodesFromDOM2(editor, dom);
      return $insertGeneratedNodes(editor, nodes, selection);
    } catch (_unused2) {
    }
  }
  const text = dataTransfer.getData("text/plain") || dataTransfer.getData("text/uri-list");
  if (text != null) {
    if ($isRangeSelection(selection)) {
      const parts = text.split(/(\r?\n|\t)/);
      if (parts[parts.length - 1] === "") {
        parts.pop();
      }
      for (let i3 = 0; i3 < parts.length; i3++) {
        const part = parts[i3];
        if (part === "\n" || part === "\r\n") {
          selection.insertParagraph();
        } else if (part === "	") {
          selection.insertNodes([$createTabNode()]);
        } else {
          selection.insertText(part);
        }
      }
    } else {
      selection.insertRawText(text);
    }
  }
}
function $insertGeneratedNodes(editor, nodes, selection) {
  if (!editor.dispatchCommand(SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, {
    nodes,
    selection
  })) {
    selection.insertNodes(nodes);
  }
  return;
}
function exportNodeToJSON(node) {
  const serializedNode = node.exportJSON();
  const nodeClass = node.constructor;
  if (serializedNode.type !== nodeClass.getType()) {
    {
      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);
    }
  }
  if ($isElementNode(node)) {
    const serializedChildren = serializedNode.children;
    if (!Array.isArray(serializedChildren)) {
      {
        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);
      }
    }
  }
  return serializedNode;
}
function $appendNodesToJSON(editor, selection, currentNode, targetArray = []) {
  let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;
  const shouldExclude = $isElementNode(currentNode) && currentNode.excludeFromCopy("html");
  let target = currentNode;
  if (selection !== null) {
    let clone = $cloneWithProperties(currentNode);
    clone = $isTextNode(clone) && selection !== null ? $sliceSelectedTextNodeContent(selection, clone) : clone;
    target = clone;
  }
  const children = $isElementNode(target) ? target.getChildren() : [];
  const serializedNode = exportNodeToJSON(target);
  if ($isTextNode(target)) {
    const text = target.__text;
    if (text.length > 0) {
      serializedNode.text = text;
    } else {
      shouldInclude = false;
    }
  }
  for (let i3 = 0; i3 < children.length; i3++) {
    const childNode = children[i3];
    const shouldIncludeChild = $appendNodesToJSON(editor, selection, childNode, serializedNode.children);
    if (!shouldInclude && $isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, "clone")) {
      shouldInclude = true;
    }
  }
  if (shouldInclude && !shouldExclude) {
    targetArray.push(serializedNode);
  } else if (Array.isArray(serializedNode.children)) {
    for (let i3 = 0; i3 < serializedNode.children.length; i3++) {
      const serializedChildNode = serializedNode.children[i3];
      targetArray.push(serializedChildNode);
    }
  }
  return shouldInclude;
}
function $generateJSONFromSelectedNodes(editor, selection) {
  const nodes = [];
  const root = $getRoot();
  const topLevelChildren = root.getChildren();
  for (let i3 = 0; i3 < topLevelChildren.length; i3++) {
    const topLevelNode = topLevelChildren[i3];
    $appendNodesToJSON(editor, selection, topLevelNode, nodes);
  }
  return {
    namespace: editor._config.namespace,
    nodes
  };
}
function $generateNodesFromSerializedNodes(serializedNodes) {
  const nodes = [];
  for (let i3 = 0; i3 < serializedNodes.length; i3++) {
    const serializedNode = serializedNodes[i3];
    const node = $parseSerializedNode(serializedNode);
    if ($isTextNode(node)) {
      $addNodeStyle(node);
    }
    nodes.push(node);
  }
  return nodes;
}
var EVENT_LATENCY = 50;
var clipboardEventTimeout = null;
async function copyToClipboard(editor, event) {
  if (clipboardEventTimeout !== null) {
    return false;
  }
  if (event !== null) {
    return new Promise((resolve, reject) => {
      editor.update(() => {
        resolve($copyToClipboardEvent(editor, event));
      });
    });
  }
  const rootElement = editor.getRootElement();
  const windowDocument = editor._window == null ? window.document : editor._window.document;
  const domSelection = getDOMSelection(editor._window);
  if (rootElement === null || domSelection === null) {
    return false;
  }
  const element = windowDocument.createElement("span");
  element.style.cssText = "position: fixed; top: -1000px;";
  element.append(windowDocument.createTextNode("#"));
  rootElement.append(element);
  const range = new Range();
  range.setStart(element, 0);
  range.setEnd(element, 1);
  domSelection.removeAllRanges();
  domSelection.addRange(range);
  return new Promise((resolve, reject) => {
    const removeListener = editor.registerCommand(COPY_COMMAND, (secondEvent) => {
      if (objectKlassEquals(secondEvent, ClipboardEvent)) {
        removeListener();
        if (clipboardEventTimeout !== null) {
          window.clearTimeout(clipboardEventTimeout);
          clipboardEventTimeout = null;
        }
        resolve($copyToClipboardEvent(editor, secondEvent));
      }
      return true;
    }, COMMAND_PRIORITY_CRITICAL);
    clipboardEventTimeout = window.setTimeout(() => {
      removeListener();
      clipboardEventTimeout = null;
      resolve(false);
    }, EVENT_LATENCY);
    windowDocument.execCommand("copy");
    element.remove();
  });
}
function $copyToClipboardEvent(editor, event) {
  const domSelection = getDOMSelection(editor._window);
  if (!domSelection) {
    return false;
  }
  const anchorDOM = domSelection.anchorNode;
  const focusDOM = domSelection.focusNode;
  if (anchorDOM !== null && focusDOM !== null && !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {
    return false;
  }
  event.preventDefault();
  const clipboardData = event.clipboardData;
  const selection = $getSelection();
  if (clipboardData === null || selection === null) {
    return false;
  }
  const htmlString = $getHtmlContent(editor);
  const lexicalString = $getLexicalContent(editor);
  let plainString = "";
  if (selection !== null) {
    plainString = selection.getTextContent();
  }
  if (htmlString !== null) {
    clipboardData.setData("text/html", htmlString);
  }
  if (lexicalString !== null) {
    clipboardData.setData("application/x-lexical-editor", lexicalString);
  }
  clipboardData.setData("text/plain", plainString);
  return true;
}

// node_modules/.pnpm/@lexical+clipboard@0.14.2_lexical@0.14.2/node_modules/@lexical/clipboard/LexicalClipboard.prod.esm.js
var w = "undefined" != typeof window && void 0 !== window.document && void 0 !== window.document.createElement;

// node_modules/.pnpm/@lexical+clipboard@0.14.2_lexical@0.14.2/node_modules/@lexical/clipboard/LexicalClipboard.esm.js
var mod5 = true ? LexicalClipboard_dev_esm_exports : LexicalClipboard_prod_esm_exports;
var $generateJSONFromSelectedNodes2 = mod5.$generateJSONFromSelectedNodes;
var $generateNodesFromSerializedNodes2 = mod5.$generateNodesFromSerializedNodes;
var $getHtmlContent2 = mod5.$getHtmlContent;
var $getLexicalContent2 = mod5.$getLexicalContent;
var $insertDataTransferForPlainText2 = mod5.$insertDataTransferForPlainText;
var $insertDataTransferForRichText2 = mod5.$insertDataTransferForRichText;
var $insertGeneratedNodes2 = mod5.$insertGeneratedNodes;
var copyToClipboard2 = mod5.copyToClipboard;

// node_modules/.pnpm/@lexical+plain-text@0.14.2_@lexical+clipboard@0.14.2_@lexical+selection@0.14.2_@lexical+utils@0.14.2_lexical@0.14.2/node_modules/@lexical/plain-text/LexicalPlainText.dev.esm.js
var CAN_USE_DOM3 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
var documentMode = CAN_USE_DOM3 && "documentMode" in document ? document.documentMode : null;
CAN_USE_DOM3 && /Mac|iPod|iPhone|iPad/.test(navigator.platform);
CAN_USE_DOM3 && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
var CAN_USE_BEFORE_INPUT = CAN_USE_DOM3 && "InputEvent" in window && !documentMode ? "getTargetRanges" in new window.InputEvent("input") : false;
var IS_SAFARI = CAN_USE_DOM3 && /Version\/[\d.]+.*Safari/.test(navigator.userAgent);
var IS_IOS = CAN_USE_DOM3 && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
var IS_ANDROID = CAN_USE_DOM3 && /Android/.test(navigator.userAgent);
var IS_CHROME = CAN_USE_DOM3 && /^(?=.*Chrome).*/i.test(navigator.userAgent);
var IS_APPLE_WEBKIT = CAN_USE_DOM3 && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !IS_CHROME;
function onCopyForPlainText(event, editor) {
  editor.update(() => {
    if (event !== null) {
      const clipboardData = objectKlassEquals(event, KeyboardEvent) ? null : event.clipboardData;
      const selection = $getSelection();
      if (selection !== null && clipboardData != null) {
        event.preventDefault();
        const htmlString = $getHtmlContent2(editor);
        if (htmlString !== null) {
          clipboardData.setData("text/html", htmlString);
        }
        clipboardData.setData("text/plain", selection.getTextContent());
      }
    }
  });
}
function onPasteForPlainText(event, editor) {
  event.preventDefault();
  editor.update(() => {
    const selection = $getSelection();
    const {
      clipboardData
    } = event;
    if (clipboardData != null && $isRangeSelection(selection)) {
      $insertDataTransferForPlainText2(clipboardData, selection);
    }
  }, {
    tag: "paste"
  });
}
function onCutForPlainText(event, editor) {
  onCopyForPlainText(event, editor);
  editor.update(() => {
    const selection = $getSelection();
    if ($isRangeSelection(selection)) {
      selection.removeText();
    }
  });
}
function registerPlainText(editor) {
  const removeListener = mergeRegister(editor.registerCommand(DELETE_CHARACTER_COMMAND, (isBackward) => {
    const selection = $getSelection();
    if (!$isRangeSelection(selection)) {
      return false;
    }
    selection.deleteCharacter(isBackward);
    return true;
  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DELETE_WORD_COMMAND, (isBackward) => {
    const selection = $getSelection();
    if (!$isRangeSelection(selection)) {
      return false;
    }
    selection.deleteWord(isBackward);
    return true;
  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DELETE_LINE_COMMAND, (isBackward) => {
    const selection = $getSelection();
    if (!$isRangeSelection(selection)) {
      return false;
    }
    selection.deleteLine(isBackward);
    return true;
  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(CONTROLLED_TEXT_INSERTION_COMMAND, (eventOrText) => {
    const selection = $getSelection();
    if (!$isRangeSelection(selection)) {
      return false;
    }
    if (typeof eventOrText === "string") {
      selection.insertText(eventOrText);
    } else {
      const dataTransfer = eventOrText.dataTransfer;
      if (dataTransfer != null) {
        $insertDataTransferForPlainText2(dataTransfer, selection);
      } else {
        const data = eventOrText.data;
        if (data) {
          selection.insertText(data);
        }
      }
    }
    return true;
  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(REMOVE_TEXT_COMMAND, () => {
    const selection = $getSelection();
    if (!$isRangeSelection(selection)) {
      return false;
    }
    selection.removeText();
    return true;
  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(INSERT_LINE_BREAK_COMMAND, (selectStart) => {
    const selection = $getSelection();
    if (!$isRangeSelection(selection)) {
      return false;
    }
    selection.insertLineBreak(selectStart);
    return true;
  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(INSERT_PARAGRAPH_COMMAND, () => {
    const selection = $getSelection();
    if (!$isRangeSelection(selection)) {
      return false;
    }
    selection.insertLineBreak();
    return true;
  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ARROW_LEFT_COMMAND, (payload) => {
    const selection = $getSelection();
    if (!$isRangeSelection(selection)) {
      return false;
    }
    const event = payload;
    const isHoldingShift = event.shiftKey;
    if ($shouldOverrideDefaultCharacterSelection(selection, true)) {
      event.preventDefault();
      $moveCharacter(selection, isHoldingShift, true);
      return true;
    }
    return false;
  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ARROW_RIGHT_COMMAND, (payload) => {
    const selection = $getSelection();
    if (!$isRangeSelection(selection)) {
      return false;
    }
    const event = payload;
    const isHoldingShift = event.shiftKey;
    if ($shouldOverrideDefaultCharacterSelection(selection, false)) {
      event.preventDefault();
      $moveCharacter(selection, isHoldingShift, false);
      return true;
    }
    return false;
  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_BACKSPACE_COMMAND, (event) => {
    const selection = $getSelection();
    if (!$isRangeSelection(selection)) {
      return false;
    }
    event.preventDefault();
    return editor.dispatchCommand(DELETE_CHARACTER_COMMAND, true);
  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_DELETE_COMMAND, (event) => {
    const selection = $getSelection();
    if (!$isRangeSelection(selection)) {
      return false;
    }
    event.preventDefault();
    return editor.dispatchCommand(DELETE_CHARACTER_COMMAND, false);
  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ENTER_COMMAND, (event) => {
    const selection = $getSelection();
    if (!$isRangeSelection(selection)) {
      return false;
    }
    if (event !== null) {
      if ((IS_IOS || IS_SAFARI || IS_APPLE_WEBKIT) && CAN_USE_BEFORE_INPUT) {
        return false;
      }
      event.preventDefault();
    }
    return editor.dispatchCommand(INSERT_LINE_BREAK_COMMAND, false);
  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(SELECT_ALL_COMMAND, () => {
    $selectAll();
    return true;
  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(COPY_COMMAND, (event) => {
    const selection = $getSelection();
    if (!$isRangeSelection(selection)) {
      return false;
    }
    onCopyForPlainText(event, editor);
    return true;
  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(CUT_COMMAND, (event) => {
    const selection = $getSelection();
    if (!$isRangeSelection(selection)) {
      return false;
    }
    onCutForPlainText(event, editor);
    return true;
  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(PASTE_COMMAND, (event) => {
    const selection = $getSelection();
    if (!$isRangeSelection(selection)) {
      return false;
    }
    onPasteForPlainText(event, editor);
    return true;
  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DROP_COMMAND, (event) => {
    const selection = $getSelection();
    if (!$isRangeSelection(selection)) {
      return false;
    }
    event.preventDefault();
    return true;
  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DRAGSTART_COMMAND, (event) => {
    const selection = $getSelection();
    if (!$isRangeSelection(selection)) {
      return false;
    }
    event.preventDefault();
    return true;
  }, COMMAND_PRIORITY_EDITOR));
  return removeListener;
}

// node_modules/.pnpm/@lexical+plain-text@0.14.2_@lexical+clipboard@0.14.2_@lexical+selection@0.14.2_@lexical+utils@0.14.2_lexical@0.14.2/node_modules/@lexical/plain-text/LexicalPlainText.prod.esm.js
var K = "undefined" != typeof window && void 0 !== window.document && void 0 !== window.document.createElement;
var M = K && "documentMode" in document ? document.documentMode : null;
K && /Mac|iPod|iPhone|iPad/.test(navigator.platform), K && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
var S = !(!K || !("InputEvent" in window) || M) && "getTargetRanges" in new window.InputEvent("input");
var k = K && /Version\/[\d.]+.*Safari/.test(navigator.userAgent);
var L = K && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
var B = (K && /Android/.test(navigator.userAgent), K && /^(?=.*Chrome).*/i.test(navigator.userAgent));
var I = K && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !B;

// node_modules/.pnpm/@lexical+plain-text@0.14.2_@lexical+clipboard@0.14.2_@lexical+selection@0.14.2_@lexical+utils@0.14.2_lexical@0.14.2/node_modules/@lexical/plain-text/LexicalPlainText.esm.js
var mod6 = true ? LexicalPlainText_dev_esm_exports : LexicalPlainText_prod_esm_exports;
var registerPlainText2 = mod6.registerPlainText;

// node_modules/.pnpm/@lexical+react@0.14.2_lexical@0.14.2_react-dom@18.2.0_react@18.2.0_yjs@13.6.14/node_modules/@lexical/react/LexicalPlainTextPlugin.dev.esm.js
var CAN_USE_DOM4 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
var useLayoutEffectImpl2 = CAN_USE_DOM4 ? import_react3.useLayoutEffect : import_react3.useEffect;
var useLayoutEffect2 = useLayoutEffectImpl2;
function canShowPlaceholderFromCurrentEditorState(editor) {
  const currentCanShowPlaceholder = editor.getEditorState().read($canShowPlaceholderCurry2(editor.isComposing()));
  return currentCanShowPlaceholder;
}
function useCanShowPlaceholder(editor) {
  const [canShowPlaceholder, setCanShowPlaceholder] = (0, import_react3.useState)(() => canShowPlaceholderFromCurrentEditorState(editor));
  useLayoutEffect2(() => {
    function resetCanShowPlaceholder() {
      const currentCanShowPlaceholder = canShowPlaceholderFromCurrentEditorState(editor);
      setCanShowPlaceholder(currentCanShowPlaceholder);
    }
    resetCanShowPlaceholder();
    return mergeRegister(editor.registerUpdateListener(() => {
      resetCanShowPlaceholder();
    }), editor.registerEditableListener(() => {
      resetCanShowPlaceholder();
    }));
  }, [editor]);
  return canShowPlaceholder;
}
function useDecorators(editor, ErrorBoundary) {
  const [decorators, setDecorators] = (0, import_react3.useState)(() => editor.getDecorators());
  useLayoutEffect2(() => {
    return editor.registerDecoratorListener((nextDecorators) => {
      (0, import_react_dom.flushSync)(() => {
        setDecorators(nextDecorators);
      });
    });
  }, [editor]);
  (0, import_react3.useEffect)(() => {
    setDecorators(editor.getDecorators());
  }, [editor]);
  return (0, import_react3.useMemo)(() => {
    const decoratedPortals = [];
    const decoratorKeys = Object.keys(decorators);
    for (let i3 = 0; i3 < decoratorKeys.length; i3++) {
      const nodeKey = decoratorKeys[i3];
      const reactDecorator = React.createElement(ErrorBoundary, {
        onError: (e) => editor._onError(e)
      }, React.createElement(import_react3.Suspense, {
        fallback: null
      }, decorators[nodeKey]));
      const element = editor.getElementByKey(nodeKey);
      if (element !== null) {
        decoratedPortals.push((0, import_react_dom.createPortal)(reactDecorator, element, nodeKey));
      }
    }
    return decoratedPortals;
  }, [ErrorBoundary, decorators, editor]);
}
function usePlainTextSetup(editor) {
  useLayoutEffect2(() => {
    return mergeRegister(registerPlainText2(editor), registerDragonSupport2(editor));
  }, [editor]);
}
function PlainTextPlugin({
  contentEditable,
  placeholder,
  ErrorBoundary
}) {
  const [editor] = useLexicalComposerContext();
  const decorators = useDecorators(editor, ErrorBoundary);
  usePlainTextSetup(editor);
  return React.createElement(React.Fragment, null, contentEditable, React.createElement(Placeholder, {
    content: placeholder
  }), decorators);
}
function Placeholder({
  content
}) {
  const [editor] = useLexicalComposerContext();
  const showPlaceholder = useCanShowPlaceholder(editor);
  const editable = useLexicalEditable_esm_default();
  if (!showPlaceholder) {
    return null;
  }
  if (typeof content === "function") {
    return content(editable);
  } else {
    return content;
  }
}

// node_modules/.pnpm/@lexical+react@0.14.2_lexical@0.14.2_react-dom@18.2.0_react@18.2.0_yjs@13.6.14/node_modules/@lexical/react/LexicalPlainTextPlugin.prod.esm.js
var r2 = __toESM(require_react());
var import_react4 = __toESM(require_react());
var import_react_dom2 = __toESM(require_react_dom());
var p = "undefined" != typeof window && void 0 !== window.document && void 0 !== window.document.createElement ? import_react4.useLayoutEffect : import_react4.useEffect;

// node_modules/.pnpm/@lexical+react@0.14.2_lexical@0.14.2_react-dom@18.2.0_react@18.2.0_yjs@13.6.14/node_modules/@lexical/react/LexicalPlainTextPlugin.esm.js
var mod7 = true ? LexicalPlainTextPlugin_dev_esm_exports : LexicalPlainTextPlugin_prod_esm_exports;
var PlainTextPlugin2 = mod7.PlainTextPlugin;
export {
  PlainTextPlugin2 as PlainTextPlugin
};
//# sourceMappingURL=@lexical_react_LexicalPlainTextPlugin.js.map
