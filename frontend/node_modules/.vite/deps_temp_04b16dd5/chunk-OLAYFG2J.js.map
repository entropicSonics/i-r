{
  "version": 3,
  "sources": ["../../../../node_modules/lexical/Lexical.dev.esm.js", "../../../../node_modules/lexical/Lexical.prod.esm.js", "../../../../node_modules/lexical/Lexical.esm.js"],
  "sourcesContent": ["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction createCommand(type) {\n  return {\n    type\n  } ;\n}\nconst SELECTION_CHANGE_COMMAND = createCommand('SELECTION_CHANGE_COMMAND');\nconst SELECTION_INSERT_CLIPBOARD_NODES_COMMAND = createCommand('SELECTION_INSERT_CLIPBOARD_NODES_COMMAND');\nconst CLICK_COMMAND = createCommand('CLICK_COMMAND');\nconst DELETE_CHARACTER_COMMAND = createCommand('DELETE_CHARACTER_COMMAND');\nconst INSERT_LINE_BREAK_COMMAND = createCommand('INSERT_LINE_BREAK_COMMAND');\nconst INSERT_PARAGRAPH_COMMAND = createCommand('INSERT_PARAGRAPH_COMMAND');\nconst CONTROLLED_TEXT_INSERTION_COMMAND = createCommand('CONTROLLED_TEXT_INSERTION_COMMAND');\nconst PASTE_COMMAND = createCommand('PASTE_COMMAND');\nconst REMOVE_TEXT_COMMAND = createCommand('REMOVE_TEXT_COMMAND');\nconst DELETE_WORD_COMMAND = createCommand('DELETE_WORD_COMMAND');\nconst DELETE_LINE_COMMAND = createCommand('DELETE_LINE_COMMAND');\nconst FORMAT_TEXT_COMMAND = createCommand('FORMAT_TEXT_COMMAND');\nconst UNDO_COMMAND = createCommand('UNDO_COMMAND');\nconst REDO_COMMAND = createCommand('REDO_COMMAND');\nconst KEY_DOWN_COMMAND = createCommand('KEYDOWN_COMMAND');\nconst KEY_ARROW_RIGHT_COMMAND = createCommand('KEY_ARROW_RIGHT_COMMAND');\nconst MOVE_TO_END = createCommand('MOVE_TO_END');\nconst KEY_ARROW_LEFT_COMMAND = createCommand('KEY_ARROW_LEFT_COMMAND');\nconst MOVE_TO_START = createCommand('MOVE_TO_START');\nconst KEY_ARROW_UP_COMMAND = createCommand('KEY_ARROW_UP_COMMAND');\nconst KEY_ARROW_DOWN_COMMAND = createCommand('KEY_ARROW_DOWN_COMMAND');\nconst KEY_ENTER_COMMAND = createCommand('KEY_ENTER_COMMAND');\nconst KEY_SPACE_COMMAND = createCommand('KEY_SPACE_COMMAND');\nconst KEY_BACKSPACE_COMMAND = createCommand('KEY_BACKSPACE_COMMAND');\nconst KEY_ESCAPE_COMMAND = createCommand('KEY_ESCAPE_COMMAND');\nconst KEY_DELETE_COMMAND = createCommand('KEY_DELETE_COMMAND');\nconst KEY_TAB_COMMAND = createCommand('KEY_TAB_COMMAND');\nconst INSERT_TAB_COMMAND = createCommand('INSERT_TAB_COMMAND');\nconst INDENT_CONTENT_COMMAND = createCommand('INDENT_CONTENT_COMMAND');\nconst OUTDENT_CONTENT_COMMAND = createCommand('OUTDENT_CONTENT_COMMAND');\nconst DROP_COMMAND = createCommand('DROP_COMMAND');\nconst FORMAT_ELEMENT_COMMAND = createCommand('FORMAT_ELEMENT_COMMAND');\nconst DRAGSTART_COMMAND = createCommand('DRAGSTART_COMMAND');\nconst DRAGOVER_COMMAND = createCommand('DRAGOVER_COMMAND');\nconst DRAGEND_COMMAND = createCommand('DRAGEND_COMMAND');\nconst COPY_COMMAND = createCommand('COPY_COMMAND');\nconst CUT_COMMAND = createCommand('CUT_COMMAND');\nconst SELECT_ALL_COMMAND = createCommand('SELECT_ALL_COMMAND');\nconst CLEAR_EDITOR_COMMAND = createCommand('CLEAR_EDITOR_COMMAND');\nconst CLEAR_HISTORY_COMMAND = createCommand('CLEAR_HISTORY_COMMAND');\nconst CAN_REDO_COMMAND = createCommand('CAN_REDO_COMMAND');\nconst CAN_UNDO_COMMAND = createCommand('CAN_UNDO_COMMAND');\nconst FOCUS_COMMAND = createCommand('FOCUS_COMMAND');\nconst BLUR_COMMAND = createCommand('BLUR_COMMAND');\nconst KEY_MODIFIER_COMMAND = createCommand('KEY_MODIFIER_COMMAND');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nconst IS_APPLE = CAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nconst IS_FIREFOX = CAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT = CAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nconst IS_ANDROID = CAN_USE_DOM && /Android/.test(navigator.userAgent);\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);\n// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_ANDROID_CHROME = CAN_USE_DOM && IS_ANDROID && IS_CHROME;\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// DOM\nconst DOM_ELEMENT_TYPE = 1;\nconst DOM_TEXT_TYPE = 3;\n\n// Reconciling\nconst NO_DIRTY_NODES = 0;\nconst HAS_DIRTY_NODES = 1;\nconst FULL_RECONCILE = 2;\n\n// Text node modes\nconst IS_NORMAL = 0;\nconst IS_TOKEN = 1;\nconst IS_SEGMENTED = 2;\n// IS_INERT = 3\n\n// Text node formatting\nconst IS_BOLD = 1;\nconst IS_ITALIC = 1 << 1;\nconst IS_STRIKETHROUGH = 1 << 2;\nconst IS_UNDERLINE = 1 << 3;\nconst IS_CODE = 1 << 4;\nconst IS_SUBSCRIPT = 1 << 5;\nconst IS_SUPERSCRIPT = 1 << 6;\nconst IS_HIGHLIGHT = 1 << 7;\nconst IS_ALL_FORMATTING = IS_BOLD | IS_ITALIC | IS_STRIKETHROUGH | IS_UNDERLINE | IS_CODE | IS_SUBSCRIPT | IS_SUPERSCRIPT | IS_HIGHLIGHT;\n\n// Text node details\nconst IS_DIRECTIONLESS = 1;\nconst IS_UNMERGEABLE = 1 << 1;\n\n// Element node formatting\nconst IS_ALIGN_LEFT = 1;\nconst IS_ALIGN_CENTER = 2;\nconst IS_ALIGN_RIGHT = 3;\nconst IS_ALIGN_JUSTIFY = 4;\nconst IS_ALIGN_START = 5;\nconst IS_ALIGN_END = 6;\n\n// Reconciliation\nconst NON_BREAKING_SPACE = '\\u00A0';\nconst ZERO_WIDTH_SPACE = '\\u200b';\n\n// For iOS/Safari we use a non breaking space, otherwise the cursor appears\n// overlapping the composed text.\nconst COMPOSITION_SUFFIX = IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT ? NON_BREAKING_SPACE : ZERO_WIDTH_SPACE;\nconst DOUBLE_LINE_BREAK = '\\n\\n';\n\n// For FF, we need to use a non-breaking space, or it gets composition\n// in a stuck state.\nconst COMPOSITION_START_CHAR = IS_FIREFOX ? NON_BREAKING_SPACE : COMPOSITION_SUFFIX;\nconst RTL = '\\u0591-\\u07FF\\uFB1D-\\uFDFD\\uFE70-\\uFEFC';\nconst LTR = 'A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6' + '\\u00F8-\\u02B8\\u0300-\\u0590\\u0800-\\u1FFF\\u200E\\u2C00-\\uFB1C' + '\\uFE00-\\uFE6F\\uFEFD-\\uFFFF';\n\n// eslint-disable-next-line no-misleading-character-class\nconst RTL_REGEX = new RegExp('^[^' + LTR + ']*[' + RTL + ']');\n// eslint-disable-next-line no-misleading-character-class\nconst LTR_REGEX = new RegExp('^[^' + RTL + ']*[' + LTR + ']');\nconst TEXT_TYPE_TO_FORMAT = {\n  bold: IS_BOLD,\n  code: IS_CODE,\n  highlight: IS_HIGHLIGHT,\n  italic: IS_ITALIC,\n  strikethrough: IS_STRIKETHROUGH,\n  subscript: IS_SUBSCRIPT,\n  superscript: IS_SUPERSCRIPT,\n  underline: IS_UNDERLINE\n};\nconst DETAIL_TYPE_TO_DETAIL = {\n  directionless: IS_DIRECTIONLESS,\n  unmergeable: IS_UNMERGEABLE\n};\nconst ELEMENT_TYPE_TO_FORMAT = {\n  center: IS_ALIGN_CENTER,\n  end: IS_ALIGN_END,\n  justify: IS_ALIGN_JUSTIFY,\n  left: IS_ALIGN_LEFT,\n  right: IS_ALIGN_RIGHT,\n  start: IS_ALIGN_START\n};\nconst ELEMENT_FORMAT_TO_TYPE = {\n  [IS_ALIGN_CENTER]: 'center',\n  [IS_ALIGN_END]: 'end',\n  [IS_ALIGN_JUSTIFY]: 'justify',\n  [IS_ALIGN_LEFT]: 'left',\n  [IS_ALIGN_RIGHT]: 'right',\n  [IS_ALIGN_START]: 'start'\n};\nconst TEXT_MODE_TO_TYPE = {\n  normal: IS_NORMAL,\n  segmented: IS_SEGMENTED,\n  token: IS_TOKEN\n};\nconst TEXT_TYPE_TO_MODE = {\n  [IS_NORMAL]: 'normal',\n  [IS_SEGMENTED]: 'segmented',\n  [IS_TOKEN]: 'token'\n};\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n// The time between a text entry event and the mutation observer firing.\nconst TEXT_MUTATION_VARIANCE = 100;\nlet isProcessingMutations = false;\nlet lastTextEntryTimeStamp = 0;\nfunction getIsProcessingMutations() {\n  return isProcessingMutations;\n}\nfunction updateTimeStamp(event) {\n  lastTextEntryTimeStamp = event.timeStamp;\n}\nfunction initTextEntryListener(editor) {\n  if (lastTextEntryTimeStamp === 0) {\n    getWindow(editor).addEventListener('textInput', updateTimeStamp, true);\n  }\n}\nfunction isManagedLineBreak(dom, target, editor) {\n  return (\n    // @ts-expect-error: internal field\n    target.__lexicalLineBreak === dom ||\n    // @ts-ignore We intentionally add this to the Node.\n    dom[`__lexicalKey_${editor._key}`] !== undefined\n  );\n}\nfunction getLastSelection(editor) {\n  return editor.getEditorState().read(() => {\n    const selection = $getSelection();\n    return selection !== null ? selection.clone() : null;\n  });\n}\nfunction handleTextMutation(target, node, editor) {\n  const domSelection = getDOMSelection(editor._window);\n  let anchorOffset = null;\n  let focusOffset = null;\n  if (domSelection !== null && domSelection.anchorNode === target) {\n    anchorOffset = domSelection.anchorOffset;\n    focusOffset = domSelection.focusOffset;\n  }\n  const text = target.nodeValue;\n  if (text !== null) {\n    $updateTextNodeFromDOMContent(node, text, anchorOffset, focusOffset, false);\n  }\n}\nfunction shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode) {\n  if ($isRangeSelection(selection)) {\n    const anchorNode = selection.anchor.getNode();\n    if (anchorNode.is(targetNode) && selection.format !== anchorNode.getFormat()) {\n      return false;\n    }\n  }\n  return targetDOM.nodeType === DOM_TEXT_TYPE && targetNode.isAttached();\n}\nfunction $flushMutations$1(editor, mutations, observer) {\n  isProcessingMutations = true;\n  const shouldFlushTextMutations = performance.now() - lastTextEntryTimeStamp > TEXT_MUTATION_VARIANCE;\n  try {\n    updateEditor(editor, () => {\n      const selection = $getSelection() || getLastSelection(editor);\n      const badDOMTargets = new Map();\n      const rootElement = editor.getRootElement();\n      // We use the current editor state, as that reflects what is\n      // actually \"on screen\".\n      const currentEditorState = editor._editorState;\n      const blockCursorElement = editor._blockCursorElement;\n      let shouldRevertSelection = false;\n      let possibleTextForFirefoxPaste = '';\n      for (let i = 0; i < mutations.length; i++) {\n        const mutation = mutations[i];\n        const type = mutation.type;\n        const targetDOM = mutation.target;\n        let targetNode = $getNearestNodeFromDOMNode(targetDOM, currentEditorState);\n        if (targetNode === null && targetDOM !== rootElement || $isDecoratorNode(targetNode)) {\n          continue;\n        }\n        if (type === 'characterData') {\n          // Text mutations are deferred and passed to mutation listeners to be\n          // processed outside of the Lexical engine.\n          if (shouldFlushTextMutations && $isTextNode(targetNode) && shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode)) {\n            handleTextMutation(\n            // nodeType === DOM_TEXT_TYPE is a Text DOM node\n            targetDOM, targetNode, editor);\n          }\n        } else if (type === 'childList') {\n          shouldRevertSelection = true;\n          // We attempt to \"undo\" any changes that have occurred outside\n          // of Lexical. We want Lexical's editor state to be source of truth.\n          // To the user, these will look like no-ops.\n          const addedDOMs = mutation.addedNodes;\n          for (let s = 0; s < addedDOMs.length; s++) {\n            const addedDOM = addedDOMs[s];\n            const node = getNodeFromDOMNode(addedDOM);\n            const parentDOM = addedDOM.parentNode;\n            if (parentDOM != null && addedDOM !== blockCursorElement && node === null && (addedDOM.nodeName !== 'BR' || !isManagedLineBreak(addedDOM, parentDOM, editor))) {\n              if (IS_FIREFOX) {\n                const possibleText = addedDOM.innerText || addedDOM.nodeValue;\n                if (possibleText) {\n                  possibleTextForFirefoxPaste += possibleText;\n                }\n              }\n              parentDOM.removeChild(addedDOM);\n            }\n          }\n          const removedDOMs = mutation.removedNodes;\n          const removedDOMsLength = removedDOMs.length;\n          if (removedDOMsLength > 0) {\n            let unremovedBRs = 0;\n            for (let s = 0; s < removedDOMsLength; s++) {\n              const removedDOM = removedDOMs[s];\n              if (removedDOM.nodeName === 'BR' && isManagedLineBreak(removedDOM, targetDOM, editor) || blockCursorElement === removedDOM) {\n                targetDOM.appendChild(removedDOM);\n                unremovedBRs++;\n              }\n            }\n            if (removedDOMsLength !== unremovedBRs) {\n              if (targetDOM === rootElement) {\n                targetNode = internalGetRoot(currentEditorState);\n              }\n              badDOMTargets.set(targetDOM, targetNode);\n            }\n          }\n        }\n      }\n\n      // Now we process each of the unique target nodes, attempting\n      // to restore their contents back to the source of truth, which\n      // is Lexical's \"current\" editor state. This is basically like\n      // an internal revert on the DOM.\n      if (badDOMTargets.size > 0) {\n        for (const [targetDOM, targetNode] of badDOMTargets) {\n          if ($isElementNode(targetNode)) {\n            const childKeys = targetNode.getChildrenKeys();\n            let currentDOM = targetDOM.firstChild;\n            for (let s = 0; s < childKeys.length; s++) {\n              const key = childKeys[s];\n              const correctDOM = editor.getElementByKey(key);\n              if (correctDOM === null) {\n                continue;\n              }\n              if (currentDOM == null) {\n                targetDOM.appendChild(correctDOM);\n                currentDOM = correctDOM;\n              } else if (currentDOM !== correctDOM) {\n                targetDOM.replaceChild(correctDOM, currentDOM);\n              }\n              currentDOM = currentDOM.nextSibling;\n            }\n          } else if ($isTextNode(targetNode)) {\n            targetNode.markDirty();\n          }\n        }\n      }\n\n      // Capture all the mutations made during this function. This\n      // also prevents us having to process them on the next cycle\n      // of onMutation, as these mutations were made by us.\n      const records = observer.takeRecords();\n\n      // Check for any random auto-added <br> elements, and remove them.\n      // These get added by the browser when we undo the above mutations\n      // and this can lead to a broken UI.\n      if (records.length > 0) {\n        for (let i = 0; i < records.length; i++) {\n          const record = records[i];\n          const addedNodes = record.addedNodes;\n          const target = record.target;\n          for (let s = 0; s < addedNodes.length; s++) {\n            const addedDOM = addedNodes[s];\n            const parentDOM = addedDOM.parentNode;\n            if (parentDOM != null && addedDOM.nodeName === 'BR' && !isManagedLineBreak(addedDOM, target, editor)) {\n              parentDOM.removeChild(addedDOM);\n            }\n          }\n        }\n\n        // Clear any of those removal mutations\n        observer.takeRecords();\n      }\n      if (selection !== null) {\n        if (shouldRevertSelection) {\n          selection.dirty = true;\n          $setSelection(selection);\n        }\n        if (IS_FIREFOX && isFirefoxClipboardEvents(editor)) {\n          selection.insertRawText(possibleTextForFirefoxPaste);\n        }\n      }\n    });\n  } finally {\n    isProcessingMutations = false;\n  }\n}\nfunction flushRootMutations(editor) {\n  const observer = editor._observer;\n  if (observer !== null) {\n    const mutations = observer.takeRecords();\n    $flushMutations$1(editor, mutations, observer);\n  }\n}\nfunction initMutationObserver(editor) {\n  initTextEntryListener(editor);\n  editor._observer = new MutationObserver((mutations, observer) => {\n    $flushMutations$1(editor, mutations, observer);\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction $canSimpleTextNodesBeMerged(node1, node2) {\n  const node1Mode = node1.__mode;\n  const node1Format = node1.__format;\n  const node1Style = node1.__style;\n  const node2Mode = node2.__mode;\n  const node2Format = node2.__format;\n  const node2Style = node2.__style;\n  return (node1Mode === null || node1Mode === node2Mode) && (node1Format === null || node1Format === node2Format) && (node1Style === null || node1Style === node2Style);\n}\nfunction $mergeTextNodes(node1, node2) {\n  const writableNode1 = node1.mergeWithSibling(node2);\n  const normalizedNodes = getActiveEditor()._normalizedNodes;\n  normalizedNodes.add(node1.__key);\n  normalizedNodes.add(node2.__key);\n  return writableNode1;\n}\nfunction $normalizeTextNode(textNode) {\n  let node = textNode;\n  if (node.__text === '' && node.isSimpleText() && !node.isUnmergeable()) {\n    node.remove();\n    return;\n  }\n\n  // Backward\n  let previousNode;\n  while ((previousNode = node.getPreviousSibling()) !== null && $isTextNode(previousNode) && previousNode.isSimpleText() && !previousNode.isUnmergeable()) {\n    if (previousNode.__text === '') {\n      previousNode.remove();\n    } else if ($canSimpleTextNodesBeMerged(previousNode, node)) {\n      node = $mergeTextNodes(previousNode, node);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Forward\n  let nextNode;\n  while ((nextNode = node.getNextSibling()) !== null && $isTextNode(nextNode) && nextNode.isSimpleText() && !nextNode.isUnmergeable()) {\n    if (nextNode.__text === '') {\n      nextNode.remove();\n    } else if ($canSimpleTextNodesBeMerged(node, nextNode)) {\n      node = $mergeTextNodes(node, nextNode);\n      break;\n    } else {\n      break;\n    }\n  }\n}\nfunction $normalizeSelection(selection) {\n  $normalizePoint(selection.anchor);\n  $normalizePoint(selection.focus);\n  return selection;\n}\nfunction $normalizePoint(point) {\n  while (point.type === 'element') {\n    const node = point.getNode();\n    const offset = point.offset;\n    let nextNode;\n    let nextOffsetAtEnd;\n    if (offset === node.getChildrenSize()) {\n      nextNode = node.getChildAtIndex(offset - 1);\n      nextOffsetAtEnd = true;\n    } else {\n      nextNode = node.getChildAtIndex(offset);\n      nextOffsetAtEnd = false;\n    }\n    if ($isTextNode(nextNode)) {\n      point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getTextContentSize() : 0, 'text');\n      break;\n    } else if (!$isElementNode(nextNode)) {\n      break;\n    }\n    point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getChildrenSize() : 0, 'element');\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nlet keyCounter = 1;\nfunction generateRandomKey() {\n  return '' + keyCounter++;\n}\nfunction getRegisteredNodeOrThrow(editor, nodeType) {\n  const registeredNode = editor._nodes.get(nodeType);\n  if (registeredNode === undefined) {\n    {\n      throw Error(`registeredNode: Type ${nodeType} not found`);\n    }\n  }\n  return registeredNode;\n}\nconst scheduleMicroTask = typeof queueMicrotask === 'function' ? queueMicrotask : fn => {\n  // No window prefix intended (#1400)\n  Promise.resolve().then(fn);\n};\nfunction $isSelectionCapturedInDecorator(node) {\n  return $isDecoratorNode($getNearestNodeFromDOMNode(node));\n}\nfunction isSelectionCapturedInDecoratorInput(anchorDOM) {\n  const activeElement = document.activeElement;\n  if (activeElement === null) {\n    return false;\n  }\n  const nodeName = activeElement.nodeName;\n  return $isDecoratorNode($getNearestNodeFromDOMNode(anchorDOM)) && (nodeName === 'INPUT' || nodeName === 'TEXTAREA' || activeElement.contentEditable === 'true' &&\n  // @ts-ignore iternal field\n  activeElement.__lexicalEditor == null);\n}\nfunction isSelectionWithinEditor(editor, anchorDOM, focusDOM) {\n  const rootElement = editor.getRootElement();\n  try {\n    return rootElement !== null && rootElement.contains(anchorDOM) && rootElement.contains(focusDOM) &&\n    // Ignore if selection is within nested editor\n    anchorDOM !== null && !isSelectionCapturedInDecoratorInput(anchorDOM) && getNearestEditorFromDOMNode(anchorDOM) === editor;\n  } catch (error) {\n    return false;\n  }\n}\nfunction getNearestEditorFromDOMNode(node) {\n  let currentNode = node;\n  while (currentNode != null) {\n    // @ts-expect-error: internal field\n    const editor = currentNode.__lexicalEditor;\n    if (editor != null) {\n      return editor;\n    }\n    currentNode = getParentElement(currentNode);\n  }\n  return null;\n}\nfunction getTextDirection(text) {\n  if (RTL_REGEX.test(text)) {\n    return 'rtl';\n  }\n  if (LTR_REGEX.test(text)) {\n    return 'ltr';\n  }\n  return null;\n}\nfunction $isTokenOrSegmented(node) {\n  return node.isToken() || node.isSegmented();\n}\nfunction isDOMNodeLexicalTextNode(node) {\n  return node.nodeType === DOM_TEXT_TYPE;\n}\nfunction getDOMTextNode(element) {\n  let node = element;\n  while (node != null) {\n    if (isDOMNodeLexicalTextNode(node)) {\n      return node;\n    }\n    node = node.firstChild;\n  }\n  return null;\n}\nfunction toggleTextFormatType(format, type, alignWithFormat) {\n  const activeFormat = TEXT_TYPE_TO_FORMAT[type];\n  if (alignWithFormat !== null && (format & activeFormat) === (alignWithFormat & activeFormat)) {\n    return format;\n  }\n  let newFormat = format ^ activeFormat;\n  if (type === 'subscript') {\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.superscript;\n  } else if (type === 'superscript') {\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.subscript;\n  }\n  return newFormat;\n}\nfunction $isLeafNode(node) {\n  return $isTextNode(node) || $isLineBreakNode(node) || $isDecoratorNode(node);\n}\nfunction $setNodeKey(node, existingKey) {\n  if (existingKey != null) {\n    node.__key = existingKey;\n    return;\n  }\n  errorOnReadOnly();\n  errorOnInfiniteTransforms();\n  const editor = getActiveEditor();\n  const editorState = getActiveEditorState();\n  const key = generateRandomKey();\n  editorState._nodeMap.set(key, node);\n  // TODO Split this function into leaf/element\n  if ($isElementNode(node)) {\n    editor._dirtyElements.set(key, true);\n  } else {\n    editor._dirtyLeaves.add(key);\n  }\n  editor._cloneNotNeeded.add(key);\n  editor._dirtyType = HAS_DIRTY_NODES;\n  node.__key = key;\n}\nfunction internalMarkParentElementsAsDirty(parentKey, nodeMap, dirtyElements) {\n  let nextParentKey = parentKey;\n  while (nextParentKey !== null) {\n    if (dirtyElements.has(nextParentKey)) {\n      return;\n    }\n    const node = nodeMap.get(nextParentKey);\n    if (node === undefined) {\n      break;\n    }\n    dirtyElements.set(nextParentKey, false);\n    nextParentKey = node.__parent;\n  }\n}\nfunction removeFromParent(node) {\n  const oldParent = node.getParent();\n  if (oldParent !== null) {\n    const writableNode = node.getWritable();\n    const writableParent = oldParent.getWritable();\n    const prevSibling = node.getPreviousSibling();\n    const nextSibling = node.getNextSibling();\n    // TODO: this function duplicates a bunch of operations, can be simplified.\n    if (prevSibling === null) {\n      if (nextSibling !== null) {\n        const writableNextSibling = nextSibling.getWritable();\n        writableParent.__first = nextSibling.__key;\n        writableNextSibling.__prev = null;\n      } else {\n        writableParent.__first = null;\n      }\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      if (nextSibling !== null) {\n        const writableNextSibling = nextSibling.getWritable();\n        writableNextSibling.__prev = writablePrevSibling.__key;\n        writablePrevSibling.__next = writableNextSibling.__key;\n      } else {\n        writablePrevSibling.__next = null;\n      }\n      writableNode.__prev = null;\n    }\n    if (nextSibling === null) {\n      if (prevSibling !== null) {\n        const writablePrevSibling = prevSibling.getWritable();\n        writableParent.__last = prevSibling.__key;\n        writablePrevSibling.__next = null;\n      } else {\n        writableParent.__last = null;\n      }\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      if (prevSibling !== null) {\n        const writablePrevSibling = prevSibling.getWritable();\n        writablePrevSibling.__next = writableNextSibling.__key;\n        writableNextSibling.__prev = writablePrevSibling.__key;\n      } else {\n        writableNextSibling.__prev = null;\n      }\n      writableNode.__next = null;\n    }\n    writableParent.__size--;\n    writableNode.__parent = null;\n  }\n}\n\n// Never use this function directly! It will break\n// the cloning heuristic. Instead use node.getWritable().\nfunction internalMarkNodeAsDirty(node) {\n  errorOnInfiniteTransforms();\n  const latest = node.getLatest();\n  const parent = latest.__parent;\n  const editorState = getActiveEditorState();\n  const editor = getActiveEditor();\n  const nodeMap = editorState._nodeMap;\n  const dirtyElements = editor._dirtyElements;\n  if (parent !== null) {\n    internalMarkParentElementsAsDirty(parent, nodeMap, dirtyElements);\n  }\n  const key = latest.__key;\n  editor._dirtyType = HAS_DIRTY_NODES;\n  if ($isElementNode(node)) {\n    dirtyElements.set(key, true);\n  } else {\n    // TODO split internally MarkNodeAsDirty into two dedicated Element/leave functions\n    editor._dirtyLeaves.add(key);\n  }\n}\nfunction internalMarkSiblingsAsDirty(node) {\n  const previousNode = node.getPreviousSibling();\n  const nextNode = node.getNextSibling();\n  if (previousNode !== null) {\n    internalMarkNodeAsDirty(previousNode);\n  }\n  if (nextNode !== null) {\n    internalMarkNodeAsDirty(nextNode);\n  }\n}\nfunction $setCompositionKey(compositionKey) {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  const previousCompositionKey = editor._compositionKey;\n  if (compositionKey !== previousCompositionKey) {\n    editor._compositionKey = compositionKey;\n    if (previousCompositionKey !== null) {\n      const node = $getNodeByKey(previousCompositionKey);\n      if (node !== null) {\n        node.getWritable();\n      }\n    }\n    if (compositionKey !== null) {\n      const node = $getNodeByKey(compositionKey);\n      if (node !== null) {\n        node.getWritable();\n      }\n    }\n  }\n}\nfunction $getCompositionKey() {\n  if (isCurrentlyReadOnlyMode()) {\n    return null;\n  }\n  const editor = getActiveEditor();\n  return editor._compositionKey;\n}\nfunction $getNodeByKey(key, _editorState) {\n  const editorState = _editorState || getActiveEditorState();\n  const node = editorState._nodeMap.get(key);\n  if (node === undefined) {\n    return null;\n  }\n  return node;\n}\nfunction getNodeFromDOMNode(dom, editorState) {\n  const editor = getActiveEditor();\n  // @ts-ignore We intentionally add this to the Node.\n  const key = dom[`__lexicalKey_${editor._key}`];\n  if (key !== undefined) {\n    return $getNodeByKey(key, editorState);\n  }\n  return null;\n}\nfunction $getNearestNodeFromDOMNode(startingDOM, editorState) {\n  let dom = startingDOM;\n  while (dom != null) {\n    const node = getNodeFromDOMNode(dom, editorState);\n    if (node !== null) {\n      return node;\n    }\n    dom = getParentElement(dom);\n  }\n  return null;\n}\nfunction cloneDecorators(editor) {\n  const currentDecorators = editor._decorators;\n  const pendingDecorators = Object.assign({}, currentDecorators);\n  editor._pendingDecorators = pendingDecorators;\n  return pendingDecorators;\n}\nfunction getEditorStateTextContent(editorState) {\n  return editorState.read(() => $getRoot().getTextContent());\n}\nfunction markAllNodesAsDirty(editor, type) {\n  // Mark all existing text nodes as dirty\n  updateEditor(editor, () => {\n    const editorState = getActiveEditorState();\n    if (editorState.isEmpty()) {\n      return;\n    }\n    if (type === 'root') {\n      $getRoot().markDirty();\n      return;\n    }\n    const nodeMap = editorState._nodeMap;\n    for (const [, node] of nodeMap) {\n      node.markDirty();\n    }\n  }, editor._pendingEditorState === null ? {\n    tag: 'history-merge'\n  } : undefined);\n}\nfunction $getRoot() {\n  return internalGetRoot(getActiveEditorState());\n}\nfunction internalGetRoot(editorState) {\n  return editorState._nodeMap.get('root');\n}\nfunction $setSelection(selection) {\n  errorOnReadOnly();\n  const editorState = getActiveEditorState();\n  if (selection !== null) {\n    {\n      if (Object.isFrozen(selection)) {\n        {\n          throw Error(`$setSelection called on frozen selection object. Ensure selection is cloned before passing in.`);\n        }\n      }\n    }\n    selection.dirty = true;\n    selection.setCachedNodes(null);\n  }\n  editorState._selection = selection;\n}\nfunction $flushMutations() {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  flushRootMutations(editor);\n}\nfunction getNodeFromDOM(dom) {\n  const editor = getActiveEditor();\n  const nodeKey = getNodeKeyFromDOM(dom, editor);\n  if (nodeKey === null) {\n    const rootElement = editor.getRootElement();\n    if (dom === rootElement) {\n      return $getNodeByKey('root');\n    }\n    return null;\n  }\n  return $getNodeByKey(nodeKey);\n}\nfunction getTextNodeOffset(node, moveSelectionToEnd) {\n  return moveSelectionToEnd ? node.getTextContentSize() : 0;\n}\nfunction getNodeKeyFromDOM(\n// Note that node here refers to a DOM Node, not an Lexical Node\ndom, editor) {\n  let node = dom;\n  while (node != null) {\n    // @ts-ignore We intentionally add this to the Node.\n    const key = node[`__lexicalKey_${editor._key}`];\n    if (key !== undefined) {\n      return key;\n    }\n    node = getParentElement(node);\n  }\n  return null;\n}\nfunction doesContainGrapheme(str) {\n  return /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g.test(str);\n}\nfunction getEditorsToPropagate(editor) {\n  const editorsToPropagate = [];\n  let currentEditor = editor;\n  while (currentEditor !== null) {\n    editorsToPropagate.push(currentEditor);\n    currentEditor = currentEditor._parentEditor;\n  }\n  return editorsToPropagate;\n}\nfunction createUID() {\n  return Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 5);\n}\nfunction getAnchorTextFromDOM(anchorNode) {\n  if (anchorNode.nodeType === DOM_TEXT_TYPE) {\n    return anchorNode.nodeValue;\n  }\n  return null;\n}\nfunction $updateSelectedTextFromDOM(isCompositionEnd, editor, data) {\n  // Update the text content with the latest composition text\n  const domSelection = getDOMSelection(editor._window);\n  if (domSelection === null) {\n    return;\n  }\n  const anchorNode = domSelection.anchorNode;\n  let {\n    anchorOffset,\n    focusOffset\n  } = domSelection;\n  if (anchorNode !== null) {\n    let textContent = getAnchorTextFromDOM(anchorNode);\n    const node = $getNearestNodeFromDOMNode(anchorNode);\n    if (textContent !== null && $isTextNode(node)) {\n      // Data is intentionally truthy, as we check for boolean, null and empty string.\n      if (textContent === COMPOSITION_SUFFIX && data) {\n        const offset = data.length;\n        textContent = data;\n        anchorOffset = offset;\n        focusOffset = offset;\n      }\n      if (textContent !== null) {\n        $updateTextNodeFromDOMContent(node, textContent, anchorOffset, focusOffset, isCompositionEnd);\n      }\n    }\n  }\n}\nfunction $updateTextNodeFromDOMContent(textNode, textContent, anchorOffset, focusOffset, compositionEnd) {\n  let node = textNode;\n  if (node.isAttached() && (compositionEnd || !node.isDirty())) {\n    const isComposing = node.isComposing();\n    let normalizedTextContent = textContent;\n    if ((isComposing || compositionEnd) && textContent[textContent.length - 1] === COMPOSITION_SUFFIX) {\n      normalizedTextContent = textContent.slice(0, -1);\n    }\n    const prevTextContent = node.getTextContent();\n    if (compositionEnd || normalizedTextContent !== prevTextContent) {\n      if (normalizedTextContent === '') {\n        $setCompositionKey(null);\n        if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT) {\n          // For composition (mainly Android), we have to remove the node on a later update\n          const editor = getActiveEditor();\n          setTimeout(() => {\n            editor.update(() => {\n              if (node.isAttached()) {\n                node.remove();\n              }\n            });\n          }, 20);\n        } else {\n          node.remove();\n        }\n        return;\n      }\n      const parent = node.getParent();\n      const prevSelection = $getPreviousSelection();\n      const prevTextContentSize = node.getTextContentSize();\n      const compositionKey = $getCompositionKey();\n      const nodeKey = node.getKey();\n      if (node.isToken() || compositionKey !== null && nodeKey === compositionKey && !isComposing ||\n      // Check if character was added at the start or boundaries when not insertable, and we need\n      // to clear this input from occurring as that action wasn't permitted.\n      $isRangeSelection(prevSelection) && (parent !== null && !parent.canInsertTextBefore() && prevSelection.anchor.offset === 0 || prevSelection.anchor.key === textNode.__key && prevSelection.anchor.offset === 0 && !node.canInsertTextBefore() && !isComposing || prevSelection.focus.key === textNode.__key && prevSelection.focus.offset === prevTextContentSize && !node.canInsertTextAfter() && !isComposing)) {\n        node.markDirty();\n        return;\n      }\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection) || anchorOffset === null || focusOffset === null) {\n        node.setTextContent(normalizedTextContent);\n        return;\n      }\n      selection.setTextNodeRange(node, anchorOffset, node, focusOffset);\n      if (node.isSegmented()) {\n        const originalTextContent = node.getTextContent();\n        const replacement = $createTextNode(originalTextContent);\n        node.replace(replacement);\n        node = replacement;\n      }\n      node.setTextContent(normalizedTextContent);\n    }\n  }\n}\nfunction $previousSiblingDoesNotAcceptText(node) {\n  const previousSibling = node.getPreviousSibling();\n  return ($isTextNode(previousSibling) || $isElementNode(previousSibling) && previousSibling.isInline()) && !previousSibling.canInsertTextAfter();\n}\n\n// This function is connected to $shouldPreventDefaultAndInsertText and determines whether the\n// TextNode boundaries are writable or we should use the previous/next sibling instead. For example,\n// in the case of a LinkNode, boundaries are not writable.\nfunction $shouldInsertTextAfterOrBeforeTextNode(selection, node) {\n  if (node.isSegmented()) {\n    return true;\n  }\n  if (!selection.isCollapsed()) {\n    return false;\n  }\n  const offset = selection.anchor.offset;\n  const parent = node.getParentOrThrow();\n  const isToken = node.isToken();\n  if (offset === 0) {\n    return !node.canInsertTextBefore() || !parent.canInsertTextBefore() || isToken || $previousSiblingDoesNotAcceptText(node);\n  } else if (offset === node.getTextContentSize()) {\n    return !node.canInsertTextAfter() || !parent.canInsertTextAfter() || isToken;\n  } else {\n    return false;\n  }\n}\nfunction isTab(keyCode, altKey, ctrlKey, metaKey) {\n  return keyCode === 9 && !altKey && !ctrlKey && !metaKey;\n}\nfunction isBold(keyCode, altKey, metaKey, ctrlKey) {\n  return keyCode === 66 && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isItalic(keyCode, altKey, metaKey, ctrlKey) {\n  return keyCode === 73 && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isUnderline(keyCode, altKey, metaKey, ctrlKey) {\n  return keyCode === 85 && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isParagraph(keyCode, shiftKey) {\n  return isReturn(keyCode) && !shiftKey;\n}\nfunction isLineBreak(keyCode, shiftKey) {\n  return isReturn(keyCode) && shiftKey;\n}\n\n// Inserts a new line after the selection\n\nfunction isOpenLineBreak(keyCode, ctrlKey) {\n  // 79 = KeyO\n  return IS_APPLE && ctrlKey && keyCode === 79;\n}\nfunction isDeleteWordBackward(keyCode, altKey, ctrlKey) {\n  return isBackspace(keyCode) && (IS_APPLE ? altKey : ctrlKey);\n}\nfunction isDeleteWordForward(keyCode, altKey, ctrlKey) {\n  return isDelete(keyCode) && (IS_APPLE ? altKey : ctrlKey);\n}\nfunction isDeleteLineBackward(keyCode, metaKey) {\n  return IS_APPLE && metaKey && isBackspace(keyCode);\n}\nfunction isDeleteLineForward(keyCode, metaKey) {\n  return IS_APPLE && metaKey && isDelete(keyCode);\n}\nfunction isDeleteBackward(keyCode, altKey, metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    if (altKey || metaKey) {\n      return false;\n    }\n    return isBackspace(keyCode) || keyCode === 72 && ctrlKey;\n  }\n  if (ctrlKey || altKey || metaKey) {\n    return false;\n  }\n  return isBackspace(keyCode);\n}\nfunction isDeleteForward(keyCode, ctrlKey, shiftKey, altKey, metaKey) {\n  if (IS_APPLE) {\n    if (shiftKey || altKey || metaKey) {\n      return false;\n    }\n    return isDelete(keyCode) || keyCode === 68 && ctrlKey;\n  }\n  if (ctrlKey || altKey || metaKey) {\n    return false;\n  }\n  return isDelete(keyCode);\n}\nfunction isUndo(keyCode, shiftKey, metaKey, ctrlKey) {\n  return keyCode === 90 && !shiftKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isRedo(keyCode, shiftKey, metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    return keyCode === 90 && metaKey && shiftKey;\n  }\n  return keyCode === 89 && ctrlKey || keyCode === 90 && ctrlKey && shiftKey;\n}\nfunction isCopy(keyCode, shiftKey, metaKey, ctrlKey) {\n  if (shiftKey) {\n    return false;\n  }\n  if (keyCode === 67) {\n    return IS_APPLE ? metaKey : ctrlKey;\n  }\n  return false;\n}\nfunction isCut(keyCode, shiftKey, metaKey, ctrlKey) {\n  if (shiftKey) {\n    return false;\n  }\n  if (keyCode === 88) {\n    return IS_APPLE ? metaKey : ctrlKey;\n  }\n  return false;\n}\nfunction isArrowLeft(keyCode) {\n  return keyCode === 37;\n}\nfunction isArrowRight(keyCode) {\n  return keyCode === 39;\n}\nfunction isArrowUp(keyCode) {\n  return keyCode === 38;\n}\nfunction isArrowDown(keyCode) {\n  return keyCode === 40;\n}\nfunction isMoveBackward(keyCode, ctrlKey, altKey, metaKey) {\n  return isArrowLeft(keyCode) && !ctrlKey && !metaKey && !altKey;\n}\nfunction isMoveToStart(keyCode, ctrlKey, shiftKey, altKey, metaKey) {\n  return isArrowLeft(keyCode) && !altKey && !shiftKey && (ctrlKey || metaKey);\n}\nfunction isMoveForward(keyCode, ctrlKey, altKey, metaKey) {\n  return isArrowRight(keyCode) && !ctrlKey && !metaKey && !altKey;\n}\nfunction isMoveToEnd(keyCode, ctrlKey, shiftKey, altKey, metaKey) {\n  return isArrowRight(keyCode) && !altKey && !shiftKey && (ctrlKey || metaKey);\n}\nfunction isMoveUp(keyCode, ctrlKey, metaKey) {\n  return isArrowUp(keyCode) && !ctrlKey && !metaKey;\n}\nfunction isMoveDown(keyCode, ctrlKey, metaKey) {\n  return isArrowDown(keyCode) && !ctrlKey && !metaKey;\n}\nfunction isModifier(ctrlKey, shiftKey, altKey, metaKey) {\n  return ctrlKey || shiftKey || altKey || metaKey;\n}\nfunction isSpace(keyCode) {\n  return keyCode === 32;\n}\nfunction controlOrMeta(metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    return metaKey;\n  }\n  return ctrlKey;\n}\nfunction isReturn(keyCode) {\n  return keyCode === 13;\n}\nfunction isBackspace(keyCode) {\n  return keyCode === 8;\n}\nfunction isEscape(keyCode) {\n  return keyCode === 27;\n}\nfunction isDelete(keyCode) {\n  return keyCode === 46;\n}\nfunction isSelectAll(keyCode, metaKey, ctrlKey) {\n  return keyCode === 65 && controlOrMeta(metaKey, ctrlKey);\n}\nfunction $selectAll() {\n  const root = $getRoot();\n  const selection = root.select(0, root.getChildrenSize());\n  $setSelection($normalizeSelection(selection));\n}\nfunction getCachedClassNameArray(classNamesTheme, classNameThemeType) {\n  if (classNamesTheme.__lexicalClassNameCache === undefined) {\n    classNamesTheme.__lexicalClassNameCache = {};\n  }\n  const classNamesCache = classNamesTheme.__lexicalClassNameCache;\n  const cachedClassNames = classNamesCache[classNameThemeType];\n  if (cachedClassNames !== undefined) {\n    return cachedClassNames;\n  }\n  const classNames = classNamesTheme[classNameThemeType];\n  // As we're using classList, we need\n  // to handle className tokens that have spaces.\n  // The easiest way to do this to convert the\n  // className tokens to an array that can be\n  // applied to classList.add()/remove().\n  if (typeof classNames === 'string') {\n    const classNamesArr = normalizeClassNames(classNames);\n    classNamesCache[classNameThemeType] = classNamesArr;\n    return classNamesArr;\n  }\n  return classNames;\n}\nfunction setMutatedNode(mutatedNodes, registeredNodes, mutationListeners, node, mutation) {\n  if (mutationListeners.size === 0) {\n    return;\n  }\n  const nodeType = node.__type;\n  const nodeKey = node.__key;\n  const registeredNode = registeredNodes.get(nodeType);\n  if (registeredNode === undefined) {\n    {\n      throw Error(`Type ${nodeType} not in registeredNodes`);\n    }\n  }\n  const klass = registeredNode.klass;\n  let mutatedNodesByType = mutatedNodes.get(klass);\n  if (mutatedNodesByType === undefined) {\n    mutatedNodesByType = new Map();\n    mutatedNodes.set(klass, mutatedNodesByType);\n  }\n  const prevMutation = mutatedNodesByType.get(nodeKey);\n  // If the node has already been \"destroyed\", yet we are\n  // re-making it, then this means a move likely happened.\n  // We should change the mutation to be that of \"updated\"\n  // instead.\n  const isMove = prevMutation === 'destroyed' && mutation === 'created';\n  if (prevMutation === undefined || isMove) {\n    mutatedNodesByType.set(nodeKey, isMove ? 'updated' : mutation);\n  }\n}\nfunction $nodesOfType(klass) {\n  const editorState = getActiveEditorState();\n  const readOnly = editorState._readOnly;\n  const klassType = klass.getType();\n  const nodes = editorState._nodeMap;\n  const nodesOfType = [];\n  for (const [, node] of nodes) {\n    if (node instanceof klass && node.__type === klassType && (readOnly || node.isAttached())) {\n      nodesOfType.push(node);\n    }\n  }\n  return nodesOfType;\n}\nfunction resolveElement(element, isBackward, focusOffset) {\n  const parent = element.getParent();\n  let offset = focusOffset;\n  let block = element;\n  if (parent !== null) {\n    if (isBackward && focusOffset === 0) {\n      offset = block.getIndexWithinParent();\n      block = parent;\n    } else if (!isBackward && focusOffset === block.getChildrenSize()) {\n      offset = block.getIndexWithinParent() + 1;\n      block = parent;\n    }\n  }\n  return block.getChildAtIndex(isBackward ? offset - 1 : offset);\n}\nfunction $getAdjacentNode(focus, isBackward) {\n  const focusOffset = focus.offset;\n  if (focus.type === 'element') {\n    const block = focus.getNode();\n    return resolveElement(block, isBackward, focusOffset);\n  } else {\n    const focusNode = focus.getNode();\n    if (isBackward && focusOffset === 0 || !isBackward && focusOffset === focusNode.getTextContentSize()) {\n      const possibleNode = isBackward ? focusNode.getPreviousSibling() : focusNode.getNextSibling();\n      if (possibleNode === null) {\n        return resolveElement(focusNode.getParentOrThrow(), isBackward, focusNode.getIndexWithinParent() + (isBackward ? 0 : 1));\n      }\n      return possibleNode;\n    }\n  }\n  return null;\n}\nfunction isFirefoxClipboardEvents(editor) {\n  const event = getWindow(editor).event;\n  const inputType = event && event.inputType;\n  return inputType === 'insertFromPaste' || inputType === 'insertFromPasteAsQuotation';\n}\nfunction dispatchCommand(editor, command, payload) {\n  return triggerCommandListeners(editor, command, payload);\n}\nfunction $textContentRequiresDoubleLinebreakAtEnd(node) {\n  return !$isRootNode(node) && !node.isLastChild() && !node.isInline();\n}\nfunction getElementByKeyOrThrow(editor, key) {\n  const element = editor._keyToDOMMap.get(key);\n  if (element === undefined) {\n    {\n      throw Error(`Reconciliation: could not find DOM element for node key ${key}`);\n    }\n  }\n  return element;\n}\nfunction getParentElement(node) {\n  const parentElement = node.assignedSlot || node.parentElement;\n  return parentElement !== null && parentElement.nodeType === 11 ? parentElement.host : parentElement;\n}\nfunction scrollIntoViewIfNeeded(editor, selectionRect, rootElement) {\n  const doc = rootElement.ownerDocument;\n  const defaultView = doc.defaultView;\n  if (defaultView === null) {\n    return;\n  }\n  let {\n    top: currentTop,\n    bottom: currentBottom\n  } = selectionRect;\n  let targetTop = 0;\n  let targetBottom = 0;\n  let element = rootElement;\n  while (element !== null) {\n    const isBodyElement = element === doc.body;\n    if (isBodyElement) {\n      targetTop = 0;\n      targetBottom = getWindow(editor).innerHeight;\n    } else {\n      const targetRect = element.getBoundingClientRect();\n      targetTop = targetRect.top;\n      targetBottom = targetRect.bottom;\n    }\n    let diff = 0;\n    if (currentTop < targetTop) {\n      diff = -(targetTop - currentTop);\n    } else if (currentBottom > targetBottom) {\n      diff = currentBottom - targetBottom;\n    }\n    if (diff !== 0) {\n      if (isBodyElement) {\n        // Only handles scrolling of Y axis\n        defaultView.scrollBy(0, diff);\n      } else {\n        const scrollTop = element.scrollTop;\n        element.scrollTop += diff;\n        const yOffset = element.scrollTop - scrollTop;\n        currentTop -= yOffset;\n        currentBottom -= yOffset;\n      }\n    }\n    if (isBodyElement) {\n      break;\n    }\n    element = getParentElement(element);\n  }\n}\nfunction $hasUpdateTag(tag) {\n  const editor = getActiveEditor();\n  return editor._updateTags.has(tag);\n}\nfunction $addUpdateTag(tag) {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  editor._updateTags.add(tag);\n}\nfunction $maybeMoveChildrenSelectionToParent(parentNode) {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection) || !$isElementNode(parentNode)) {\n    return selection;\n  }\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if ($hasAncestor(anchorNode, parentNode)) {\n    anchor.set(parentNode.__key, 0, 'element');\n  }\n  if ($hasAncestor(focusNode, parentNode)) {\n    focus.set(parentNode.__key, 0, 'element');\n  }\n  return selection;\n}\nfunction $hasAncestor(child, targetNode) {\n  let parent = child.getParent();\n  while (parent !== null) {\n    if (parent.is(targetNode)) {\n      return true;\n    }\n    parent = parent.getParent();\n  }\n  return false;\n}\nfunction getDefaultView(domElem) {\n  const ownerDoc = domElem.ownerDocument;\n  return ownerDoc && ownerDoc.defaultView || null;\n}\nfunction getWindow(editor) {\n  const windowObj = editor._window;\n  if (windowObj === null) {\n    {\n      throw Error(`window object not found`);\n    }\n  }\n  return windowObj;\n}\nfunction $isInlineElementOrDecoratorNode(node) {\n  return $isElementNode(node) && node.isInline() || $isDecoratorNode(node) && node.isInline();\n}\nfunction $getNearestRootOrShadowRoot(node) {\n  let parent = node.getParentOrThrow();\n  while (parent !== null) {\n    if ($isRootOrShadowRoot(parent)) {\n      return parent;\n    }\n    parent = parent.getParentOrThrow();\n  }\n  return parent;\n}\nfunction $isRootOrShadowRoot(node) {\n  return $isRootNode(node) || $isElementNode(node) && node.isShadowRoot();\n}\nfunction $copyNode(node) {\n  const copy = node.constructor.clone(node);\n  $setNodeKey(copy, null);\n  // @ts-expect-error\n  return copy;\n}\nfunction $applyNodeReplacement(node) {\n  const editor = getActiveEditor();\n  const nodeType = node.constructor.getType();\n  const registeredNode = editor._nodes.get(nodeType);\n  if (registeredNode === undefined) {\n    {\n      throw Error(`$initializeNode failed. Ensure node has been registered to the editor. You can do this by passing the node class via the \"nodes\" array in the editor config.`);\n    }\n  }\n  const replaceFunc = registeredNode.replace;\n  if (replaceFunc !== null) {\n    const replacementNode = replaceFunc(node);\n    if (!(replacementNode instanceof node.constructor)) {\n      {\n        throw Error(`$initializeNode failed. Ensure replacement node is a subclass of the original node.`);\n      }\n    }\n    return replacementNode;\n  }\n  return node;\n}\nfunction errorOnInsertTextNodeOnRoot(node, insertNode) {\n  const parentNode = node.getParent();\n  if ($isRootNode(parentNode) && !$isElementNode(insertNode) && !$isDecoratorNode(insertNode)) {\n    {\n      throw Error(`Only element or decorator nodes can be inserted in to the root node`);\n    }\n  }\n}\nfunction createBlockCursorElement(editorConfig) {\n  const theme = editorConfig.theme;\n  const element = document.createElement('div');\n  element.contentEditable = 'false';\n  element.setAttribute('data-lexical-cursor', 'true');\n  let blockCursorTheme = theme.blockCursor;\n  if (blockCursorTheme !== undefined) {\n    if (typeof blockCursorTheme === 'string') {\n      const classNamesArr = normalizeClassNames(blockCursorTheme);\n      // @ts-expect-error: intentional\n      blockCursorTheme = theme.blockCursor = classNamesArr;\n    }\n    if (blockCursorTheme !== undefined) {\n      element.classList.add(...blockCursorTheme);\n    }\n  }\n  return element;\n}\nfunction needsBlockCursor(node) {\n  return ($isDecoratorNode(node) || $isElementNode(node) && !node.canBeEmpty()) && !node.isInline();\n}\nfunction removeDOMBlockCursorElement(blockCursorElement, editor, rootElement) {\n  rootElement.style.removeProperty('caret-color');\n  editor._blockCursorElement = null;\n  const parentElement = blockCursorElement.parentElement;\n  if (parentElement !== null) {\n    parentElement.removeChild(blockCursorElement);\n  }\n}\nfunction updateDOMBlockCursorElement(editor, rootElement, nextSelection) {\n  let blockCursorElement = editor._blockCursorElement;\n  if ($isRangeSelection(nextSelection) && nextSelection.isCollapsed() && nextSelection.anchor.type === 'element' && rootElement.contains(document.activeElement)) {\n    const anchor = nextSelection.anchor;\n    const elementNode = anchor.getNode();\n    const offset = anchor.offset;\n    const elementNodeSize = elementNode.getChildrenSize();\n    let isBlockCursor = false;\n    let insertBeforeElement = null;\n    if (offset === elementNodeSize) {\n      const child = elementNode.getChildAtIndex(offset - 1);\n      if (needsBlockCursor(child)) {\n        isBlockCursor = true;\n      }\n    } else {\n      const child = elementNode.getChildAtIndex(offset);\n      if (needsBlockCursor(child)) {\n        const sibling = child.getPreviousSibling();\n        if (sibling === null || needsBlockCursor(sibling)) {\n          isBlockCursor = true;\n          insertBeforeElement = editor.getElementByKey(child.__key);\n        }\n      }\n    }\n    if (isBlockCursor) {\n      const elementDOM = editor.getElementByKey(elementNode.__key);\n      if (blockCursorElement === null) {\n        editor._blockCursorElement = blockCursorElement = createBlockCursorElement(editor._config);\n      }\n      rootElement.style.caretColor = 'transparent';\n      if (insertBeforeElement === null) {\n        elementDOM.appendChild(blockCursorElement);\n      } else {\n        elementDOM.insertBefore(blockCursorElement, insertBeforeElement);\n      }\n      return;\n    }\n  }\n  // Remove cursor\n  if (blockCursorElement !== null) {\n    removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n  }\n}\nfunction getDOMSelection(targetWindow) {\n  return !CAN_USE_DOM ? null : (targetWindow || window).getSelection();\n}\nfunction $splitNode(node, offset) {\n  let startNode = node.getChildAtIndex(offset);\n  if (startNode == null) {\n    startNode = node;\n  }\n  if (!!$isRootOrShadowRoot(node)) {\n    throw Error(`Can not call $splitNode() on root element`);\n  }\n  const recurse = currentNode => {\n    const parent = currentNode.getParentOrThrow();\n    const isParentRoot = $isRootOrShadowRoot(parent);\n    // The node we start split from (leaf) is moved, but its recursive\n    // parents are copied to create separate tree\n    const nodeToMove = currentNode === startNode && !isParentRoot ? currentNode : $copyNode(currentNode);\n    if (isParentRoot) {\n      if (!($isElementNode(currentNode) && $isElementNode(nodeToMove))) {\n        throw Error(`Children of a root must be ElementNode`);\n      }\n      currentNode.insertAfter(nodeToMove);\n      return [currentNode, nodeToMove, nodeToMove];\n    } else {\n      const [leftTree, rightTree, newParent] = recurse(parent);\n      const nextSiblings = currentNode.getNextSiblings();\n      newParent.append(nodeToMove, ...nextSiblings);\n      return [leftTree, rightTree, nodeToMove];\n    }\n  };\n  const [leftTree, rightTree] = recurse(startNode);\n  return [leftTree, rightTree];\n}\n\n/**\n * @param x - The element being tested\n * @returns Returns true if x is an HTML anchor tag, false otherwise\n */\nfunction isHTMLAnchorElement(x) {\n  return isHTMLElement(x) && x.tagName === 'A';\n}\n\n/**\n * @param x - The element being testing\n * @returns Returns true if x is an HTML element, false otherwise.\n */\nfunction isHTMLElement(x) {\n  // @ts-ignore-next-line - strict check on nodeType here should filter out non-Element EventTarget implementors\n  return x.nodeType === 1;\n}\n\n/**\n * This function is for internal use of the library.\n * Please do not use it as it may change in the future.\n */\nfunction INTERNAL_$isBlock(node) {\n  if ($isDecoratorNode(node) && !node.isInline()) {\n    return true;\n  }\n  if (!$isElementNode(node) || $isRootOrShadowRoot(node)) {\n    return false;\n  }\n  const firstChild = node.getFirstChild();\n  const isLeafElement = firstChild === null || $isLineBreakNode(firstChild) || $isTextNode(firstChild) || firstChild.isInline();\n  return !node.isInline() && node.canBeEmpty() !== false && isLeafElement;\n}\nfunction $getAncestor(node, predicate) {\n  let parent = node;\n  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {\n    parent = parent.getParentOrThrow();\n  }\n  return predicate(parent) ? parent : null;\n}\n\n/**\n * Utility function for accessing current active editor instance.\n * @returns Current active editor\n */\nfunction $getEditor() {\n  return getActiveEditor();\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction $garbageCollectDetachedDecorators(editor, pendingEditorState) {\n  const currentDecorators = editor._decorators;\n  const pendingDecorators = editor._pendingDecorators;\n  let decorators = pendingDecorators || currentDecorators;\n  const nodeMap = pendingEditorState._nodeMap;\n  let key;\n  for (key in decorators) {\n    if (!nodeMap.has(key)) {\n      if (decorators === currentDecorators) {\n        decorators = cloneDecorators(editor);\n      }\n      delete decorators[key];\n    }\n  }\n}\nfunction $garbageCollectDetachedDeepChildNodes(node, parentKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyNodes) {\n  let child = node.getFirstChild();\n  while (child !== null) {\n    const childKey = child.__key;\n    // TODO Revise condition below, redundant? LexicalNode already cleans up children when moving Nodes\n    if (child.__parent === parentKey) {\n      if ($isElementNode(child)) {\n        $garbageCollectDetachedDeepChildNodes(child, childKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyNodes);\n      }\n\n      // If we have created a node and it was dereferenced, then also\n      // remove it from out dirty nodes Set.\n      if (!prevNodeMap.has(childKey)) {\n        dirtyNodes.delete(childKey);\n      }\n      nodeMapDelete.push(childKey);\n    }\n    child = child.getNextSibling();\n  }\n}\nfunction $garbageCollectDetachedNodes(prevEditorState, editorState, dirtyLeaves, dirtyElements) {\n  const prevNodeMap = prevEditorState._nodeMap;\n  const nodeMap = editorState._nodeMap;\n  // Store dirtyElements in a queue for later deletion; deleting dirty subtrees too early will\n  // hinder accessing .__next on child nodes\n  const nodeMapDelete = [];\n  for (const [nodeKey] of dirtyElements) {\n    const node = nodeMap.get(nodeKey);\n    if (node !== undefined) {\n      // Garbage collect node and its children if they exist\n      if (!node.isAttached()) {\n        if ($isElementNode(node)) {\n          $garbageCollectDetachedDeepChildNodes(node, nodeKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyElements);\n        }\n        // If we have created a node and it was dereferenced, then also\n        // remove it from out dirty nodes Set.\n        if (!prevNodeMap.has(nodeKey)) {\n          dirtyElements.delete(nodeKey);\n        }\n        nodeMapDelete.push(nodeKey);\n      }\n    }\n  }\n  for (const nodeKey of nodeMapDelete) {\n    nodeMap.delete(nodeKey);\n  }\n  for (const nodeKey of dirtyLeaves) {\n    const node = nodeMap.get(nodeKey);\n    if (node !== undefined && !node.isAttached()) {\n      if (!prevNodeMap.has(nodeKey)) {\n        dirtyLeaves.delete(nodeKey);\n      }\n      nodeMap.delete(nodeKey);\n    }\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nlet subTreeTextContent = '';\nlet subTreeDirectionedTextContent = '';\nlet editorTextContent = '';\nlet activeEditorConfig;\nlet activeEditor$1;\nlet activeEditorNodes;\nlet treatAllNodesAsDirty = false;\nlet activeEditorStateReadOnly = false;\nlet activeMutationListeners;\nlet activeTextDirection = null;\nlet activeDirtyElements;\nlet activeDirtyLeaves;\nlet activePrevNodeMap;\nlet activeNextNodeMap;\nlet activePrevKeyToDOMMap;\nlet mutatedNodes;\nfunction destroyNode(key, parentDOM) {\n  const node = activePrevNodeMap.get(key);\n  if (parentDOM !== null) {\n    const dom = getPrevElementByKeyOrThrow(key);\n    if (dom.parentNode === parentDOM) {\n      parentDOM.removeChild(dom);\n    }\n  }\n\n  // This logic is really important, otherwise we will leak DOM nodes\n  // when their corresponding LexicalNodes are removed from the editor state.\n  if (!activeNextNodeMap.has(key)) {\n    activeEditor$1._keyToDOMMap.delete(key);\n  }\n  if ($isElementNode(node)) {\n    const children = createChildrenArray(node, activePrevNodeMap);\n    destroyChildren(children, 0, children.length - 1, null);\n  }\n  if (node !== undefined) {\n    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, 'destroyed');\n  }\n}\nfunction destroyChildren(children, _startIndex, endIndex, dom) {\n  let startIndex = _startIndex;\n  for (; startIndex <= endIndex; ++startIndex) {\n    const child = children[startIndex];\n    if (child !== undefined) {\n      destroyNode(child, dom);\n    }\n  }\n}\nfunction setTextAlign(domStyle, value) {\n  domStyle.setProperty('text-align', value);\n}\nconst DEFAULT_INDENT_VALUE = '40px';\nfunction setElementIndent(dom, indent) {\n  const indentClassName = activeEditorConfig.theme.indent;\n  if (typeof indentClassName === 'string') {\n    const elementHasClassName = dom.classList.contains(indentClassName);\n    if (indent > 0 && !elementHasClassName) {\n      dom.classList.add(indentClassName);\n    } else if (indent < 1 && elementHasClassName) {\n      dom.classList.remove(indentClassName);\n    }\n  }\n  const indentationBaseValue = getComputedStyle(dom).getPropertyValue('--lexical-indent-base-value') || DEFAULT_INDENT_VALUE;\n  dom.style.setProperty('padding-inline-start', indent === 0 ? '' : `calc(${indent} * ${indentationBaseValue})`);\n}\nfunction setElementFormat(dom, format) {\n  const domStyle = dom.style;\n  if (format === 0) {\n    setTextAlign(domStyle, '');\n  } else if (format === IS_ALIGN_LEFT) {\n    setTextAlign(domStyle, 'left');\n  } else if (format === IS_ALIGN_CENTER) {\n    setTextAlign(domStyle, 'center');\n  } else if (format === IS_ALIGN_RIGHT) {\n    setTextAlign(domStyle, 'right');\n  } else if (format === IS_ALIGN_JUSTIFY) {\n    setTextAlign(domStyle, 'justify');\n  } else if (format === IS_ALIGN_START) {\n    setTextAlign(domStyle, 'start');\n  } else if (format === IS_ALIGN_END) {\n    setTextAlign(domStyle, 'end');\n  }\n}\nfunction createNode(key, parentDOM, insertDOM) {\n  const node = activeNextNodeMap.get(key);\n  if (node === undefined) {\n    {\n      throw Error(`createNode: node does not exist in nodeMap`);\n    }\n  }\n  const dom = node.createDOM(activeEditorConfig, activeEditor$1);\n  storeDOMWithKey(key, dom, activeEditor$1);\n\n  // This helps preserve the text, and stops spell check tools from\n  // merging or break the spans (which happens if they are missing\n  // this attribute).\n  if ($isTextNode(node)) {\n    dom.setAttribute('data-lexical-text', 'true');\n  } else if ($isDecoratorNode(node)) {\n    dom.setAttribute('data-lexical-decorator', 'true');\n  }\n  if ($isElementNode(node)) {\n    const indent = node.__indent;\n    const childrenSize = node.__size;\n    if (indent !== 0) {\n      setElementIndent(dom, indent);\n    }\n    if (childrenSize !== 0) {\n      const endIndex = childrenSize - 1;\n      const children = createChildrenArray(node, activeNextNodeMap);\n      createChildrenWithDirection(children, endIndex, node, dom);\n    }\n    const format = node.__format;\n    if (format !== 0) {\n      setElementFormat(dom, format);\n    }\n    if (!node.isInline()) {\n      reconcileElementTerminatingLineBreak(null, node, dom);\n    }\n    if ($textContentRequiresDoubleLinebreakAtEnd(node)) {\n      subTreeTextContent += DOUBLE_LINE_BREAK;\n      editorTextContent += DOUBLE_LINE_BREAK;\n    }\n  } else {\n    const text = node.getTextContent();\n    if ($isDecoratorNode(node)) {\n      const decorator = node.decorate(activeEditor$1, activeEditorConfig);\n      if (decorator !== null) {\n        reconcileDecorator(key, decorator);\n      }\n      // Decorators are always non editable\n      dom.contentEditable = 'false';\n    } else if ($isTextNode(node)) {\n      if (!node.isDirectionless()) {\n        subTreeDirectionedTextContent += text;\n      }\n    }\n    subTreeTextContent += text;\n    editorTextContent += text;\n  }\n  if (parentDOM !== null) {\n    if (insertDOM != null) {\n      parentDOM.insertBefore(dom, insertDOM);\n    } else {\n      // @ts-expect-error: internal field\n      const possibleLineBreak = parentDOM.__lexicalLineBreak;\n      if (possibleLineBreak != null) {\n        parentDOM.insertBefore(dom, possibleLineBreak);\n      } else {\n        parentDOM.appendChild(dom);\n      }\n    }\n  }\n  {\n    // Freeze the node in DEV to prevent accidental mutations\n    Object.freeze(node);\n  }\n  setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, 'created');\n  return dom;\n}\nfunction createChildrenWithDirection(children, endIndex, element, dom) {\n  const previousSubTreeDirectionedTextContent = subTreeDirectionedTextContent;\n  subTreeDirectionedTextContent = '';\n  createChildren(children, element, 0, endIndex, dom, null);\n  reconcileBlockDirection(element, dom);\n  subTreeDirectionedTextContent = previousSubTreeDirectionedTextContent;\n}\nfunction createChildren(children, element, _startIndex, endIndex, dom, insertDOM) {\n  const previousSubTreeTextContent = subTreeTextContent;\n  subTreeTextContent = '';\n  let startIndex = _startIndex;\n  for (; startIndex <= endIndex; ++startIndex) {\n    createNode(children[startIndex], dom, insertDOM);\n  }\n  if ($textContentRequiresDoubleLinebreakAtEnd(element)) {\n    subTreeTextContent += DOUBLE_LINE_BREAK;\n  }\n  // @ts-expect-error: internal field\n  dom.__lexicalTextContent = subTreeTextContent;\n  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;\n}\nfunction isLastChildLineBreakOrDecorator(childKey, nodeMap) {\n  const node = nodeMap.get(childKey);\n  return $isLineBreakNode(node) || $isDecoratorNode(node) && node.isInline();\n}\n\n// If we end an element with a LineBreakNode, then we need to add an additional <br>\nfunction reconcileElementTerminatingLineBreak(prevElement, nextElement, dom) {\n  const prevLineBreak = prevElement !== null && (prevElement.__size === 0 || isLastChildLineBreakOrDecorator(prevElement.__last, activePrevNodeMap));\n  const nextLineBreak = nextElement.__size === 0 || isLastChildLineBreakOrDecorator(nextElement.__last, activeNextNodeMap);\n  if (prevLineBreak) {\n    if (!nextLineBreak) {\n      // @ts-expect-error: internal field\n      const element = dom.__lexicalLineBreak;\n      if (element != null) {\n        dom.removeChild(element);\n      }\n\n      // @ts-expect-error: internal field\n      dom.__lexicalLineBreak = null;\n    }\n  } else if (nextLineBreak) {\n    const element = document.createElement('br');\n    // @ts-expect-error: internal field\n    dom.__lexicalLineBreak = element;\n    dom.appendChild(element);\n  }\n}\nfunction reconcileBlockDirection(element, dom) {\n  const previousSubTreeDirectionTextContent =\n  // @ts-expect-error: internal field\n  dom.__lexicalDirTextContent;\n  // @ts-expect-error: internal field\n  const previousDirection = dom.__lexicalDir;\n  if (previousSubTreeDirectionTextContent !== subTreeDirectionedTextContent || previousDirection !== activeTextDirection) {\n    const hasEmptyDirectionedTextContent = subTreeDirectionedTextContent === '';\n    const direction = hasEmptyDirectionedTextContent ? activeTextDirection : getTextDirection(subTreeDirectionedTextContent);\n    if (direction !== previousDirection) {\n      const classList = dom.classList;\n      const theme = activeEditorConfig.theme;\n      let previousDirectionTheme = previousDirection !== null ? theme[previousDirection] : undefined;\n      let nextDirectionTheme = direction !== null ? theme[direction] : undefined;\n\n      // Remove the old theme classes if they exist\n      if (previousDirectionTheme !== undefined) {\n        if (typeof previousDirectionTheme === 'string') {\n          const classNamesArr = normalizeClassNames(previousDirectionTheme);\n          previousDirectionTheme = theme[previousDirection] = classNamesArr;\n        }\n\n        // @ts-ignore: intentional\n        classList.remove(...previousDirectionTheme);\n      }\n      if (direction === null || hasEmptyDirectionedTextContent && direction === 'ltr') {\n        // Remove direction\n        dom.removeAttribute('dir');\n      } else {\n        // Apply the new theme classes if they exist\n        if (nextDirectionTheme !== undefined) {\n          if (typeof nextDirectionTheme === 'string') {\n            const classNamesArr = normalizeClassNames(nextDirectionTheme);\n            // @ts-expect-error: intentional\n            nextDirectionTheme = theme[direction] = classNamesArr;\n          }\n          if (nextDirectionTheme !== undefined) {\n            classList.add(...nextDirectionTheme);\n          }\n        }\n\n        // Update direction\n        dom.dir = direction;\n      }\n      if (!activeEditorStateReadOnly) {\n        const writableNode = element.getWritable();\n        writableNode.__dir = direction;\n      }\n    }\n    activeTextDirection = direction;\n    // @ts-expect-error: internal field\n    dom.__lexicalDirTextContent = subTreeDirectionedTextContent;\n    // @ts-expect-error: internal field\n    dom.__lexicalDir = direction;\n  }\n}\nfunction reconcileChildrenWithDirection(prevElement, nextElement, dom) {\n  const previousSubTreeDirectionTextContent = subTreeDirectionedTextContent;\n  subTreeDirectionedTextContent = '';\n  reconcileChildren(prevElement, nextElement, dom);\n  reconcileBlockDirection(nextElement, dom);\n  subTreeDirectionedTextContent = previousSubTreeDirectionTextContent;\n}\nfunction createChildrenArray(element, nodeMap) {\n  const children = [];\n  let nodeKey = element.__first;\n  while (nodeKey !== null) {\n    const node = nodeMap.get(nodeKey);\n    if (node === undefined) {\n      {\n        throw Error(`createChildrenArray: node does not exist in nodeMap`);\n      }\n    }\n    children.push(nodeKey);\n    nodeKey = node.__next;\n  }\n  return children;\n}\nfunction reconcileChildren(prevElement, nextElement, dom) {\n  const previousSubTreeTextContent = subTreeTextContent;\n  const prevChildrenSize = prevElement.__size;\n  const nextChildrenSize = nextElement.__size;\n  subTreeTextContent = '';\n  if (prevChildrenSize === 1 && nextChildrenSize === 1) {\n    const prevFirstChildKey = prevElement.__first;\n    const nextFrstChildKey = nextElement.__first;\n    if (prevFirstChildKey === nextFrstChildKey) {\n      reconcileNode(prevFirstChildKey, dom);\n    } else {\n      const lastDOM = getPrevElementByKeyOrThrow(prevFirstChildKey);\n      const replacementDOM = createNode(nextFrstChildKey, null, null);\n      dom.replaceChild(replacementDOM, lastDOM);\n      destroyNode(prevFirstChildKey, null);\n    }\n  } else {\n    const prevChildren = createChildrenArray(prevElement, activePrevNodeMap);\n    const nextChildren = createChildrenArray(nextElement, activeNextNodeMap);\n    if (prevChildrenSize === 0) {\n      if (nextChildrenSize !== 0) {\n        createChildren(nextChildren, nextElement, 0, nextChildrenSize - 1, dom, null);\n      }\n    } else if (nextChildrenSize === 0) {\n      if (prevChildrenSize !== 0) {\n        // @ts-expect-error: internal field\n        const lexicalLineBreak = dom.__lexicalLineBreak;\n        const canUseFastPath = lexicalLineBreak == null;\n        destroyChildren(prevChildren, 0, prevChildrenSize - 1, canUseFastPath ? null : dom);\n        if (canUseFastPath) {\n          // Fast path for removing DOM nodes\n          dom.textContent = '';\n        }\n      }\n    } else {\n      reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenSize, nextChildrenSize, dom);\n    }\n  }\n  if ($textContentRequiresDoubleLinebreakAtEnd(nextElement)) {\n    subTreeTextContent += DOUBLE_LINE_BREAK;\n  }\n\n  // @ts-expect-error: internal field\n  dom.__lexicalTextContent = subTreeTextContent;\n  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;\n}\nfunction reconcileNode(key, parentDOM) {\n  const prevNode = activePrevNodeMap.get(key);\n  let nextNode = activeNextNodeMap.get(key);\n  if (prevNode === undefined || nextNode === undefined) {\n    {\n      throw Error(`reconcileNode: prevNode or nextNode does not exist in nodeMap`);\n    }\n  }\n  const isDirty = treatAllNodesAsDirty || activeDirtyLeaves.has(key) || activeDirtyElements.has(key);\n  const dom = getElementByKeyOrThrow(activeEditor$1, key);\n\n  // If the node key points to the same instance in both states\n  // and isn't dirty, we just update the text content cache\n  // and return the existing DOM Node.\n  if (prevNode === nextNode && !isDirty) {\n    if ($isElementNode(prevNode)) {\n      // @ts-expect-error: internal field\n      const previousSubTreeTextContent = dom.__lexicalTextContent;\n      if (previousSubTreeTextContent !== undefined) {\n        subTreeTextContent += previousSubTreeTextContent;\n        editorTextContent += previousSubTreeTextContent;\n      }\n\n      // @ts-expect-error: internal field\n      const previousSubTreeDirectionTextContent = dom.__lexicalDirTextContent;\n      if (previousSubTreeDirectionTextContent !== undefined) {\n        subTreeDirectionedTextContent += previousSubTreeDirectionTextContent;\n      }\n    } else {\n      const text = prevNode.getTextContent();\n      if ($isTextNode(prevNode) && !prevNode.isDirectionless()) {\n        subTreeDirectionedTextContent += text;\n      }\n      editorTextContent += text;\n      subTreeTextContent += text;\n    }\n    return dom;\n  }\n  // If the node key doesn't point to the same instance in both maps,\n  // it means it were cloned. If they're also dirty, we mark them as mutated.\n  if (prevNode !== nextNode && isDirty) {\n    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, nextNode, 'updated');\n  }\n\n  // Update node. If it returns true, we need to unmount and re-create the node\n  if (nextNode.updateDOM(prevNode, dom, activeEditorConfig)) {\n    const replacementDOM = createNode(key, null, null);\n    if (parentDOM === null) {\n      {\n        throw Error(`reconcileNode: parentDOM is null`);\n      }\n    }\n    parentDOM.replaceChild(replacementDOM, dom);\n    destroyNode(key, null);\n    return replacementDOM;\n  }\n  if ($isElementNode(prevNode) && $isElementNode(nextNode)) {\n    // Reconcile element children\n    const nextIndent = nextNode.__indent;\n    if (nextIndent !== prevNode.__indent) {\n      setElementIndent(dom, nextIndent);\n    }\n    const nextFormat = nextNode.__format;\n    if (nextFormat !== prevNode.__format) {\n      setElementFormat(dom, nextFormat);\n    }\n    if (isDirty) {\n      reconcileChildrenWithDirection(prevNode, nextNode, dom);\n      if (!$isRootNode(nextNode) && !nextNode.isInline()) {\n        reconcileElementTerminatingLineBreak(prevNode, nextNode, dom);\n      }\n    }\n    if ($textContentRequiresDoubleLinebreakAtEnd(nextNode)) {\n      subTreeTextContent += DOUBLE_LINE_BREAK;\n      editorTextContent += DOUBLE_LINE_BREAK;\n    }\n  } else {\n    const text = nextNode.getTextContent();\n    if ($isDecoratorNode(nextNode)) {\n      const decorator = nextNode.decorate(activeEditor$1, activeEditorConfig);\n      if (decorator !== null) {\n        reconcileDecorator(key, decorator);\n      }\n    } else if ($isTextNode(nextNode) && !nextNode.isDirectionless()) {\n      // Handle text content, for LTR, LTR cases.\n      subTreeDirectionedTextContent += text;\n    }\n    subTreeTextContent += text;\n    editorTextContent += text;\n  }\n  if (!activeEditorStateReadOnly && $isRootNode(nextNode) && nextNode.__cachedText !== editorTextContent) {\n    // Cache the latest text content.\n    const nextRootNode = nextNode.getWritable();\n    nextRootNode.__cachedText = editorTextContent;\n    nextNode = nextRootNode;\n  }\n  {\n    // Freeze the node in DEV to prevent accidental mutations\n    Object.freeze(nextNode);\n  }\n  return dom;\n}\nfunction reconcileDecorator(key, decorator) {\n  let pendingDecorators = activeEditor$1._pendingDecorators;\n  const currentDecorators = activeEditor$1._decorators;\n  if (pendingDecorators === null) {\n    if (currentDecorators[key] === decorator) {\n      return;\n    }\n    pendingDecorators = cloneDecorators(activeEditor$1);\n  }\n  pendingDecorators[key] = decorator;\n}\nfunction getFirstChild(element) {\n  return element.firstChild;\n}\nfunction getNextSibling(element) {\n  let nextSibling = element.nextSibling;\n  if (nextSibling !== null && nextSibling === activeEditor$1._blockCursorElement) {\n    nextSibling = nextSibling.nextSibling;\n  }\n  return nextSibling;\n}\nfunction reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenLength, nextChildrenLength, dom) {\n  const prevEndIndex = prevChildrenLength - 1;\n  const nextEndIndex = nextChildrenLength - 1;\n  let prevChildrenSet;\n  let nextChildrenSet;\n  let siblingDOM = getFirstChild(dom);\n  let prevIndex = 0;\n  let nextIndex = 0;\n  while (prevIndex <= prevEndIndex && nextIndex <= nextEndIndex) {\n    const prevKey = prevChildren[prevIndex];\n    const nextKey = nextChildren[nextIndex];\n    if (prevKey === nextKey) {\n      siblingDOM = getNextSibling(reconcileNode(nextKey, dom));\n      prevIndex++;\n      nextIndex++;\n    } else {\n      if (prevChildrenSet === undefined) {\n        prevChildrenSet = new Set(prevChildren);\n      }\n      if (nextChildrenSet === undefined) {\n        nextChildrenSet = new Set(nextChildren);\n      }\n      const nextHasPrevKey = nextChildrenSet.has(prevKey);\n      const prevHasNextKey = prevChildrenSet.has(nextKey);\n      if (!nextHasPrevKey) {\n        // Remove prev\n        siblingDOM = getNextSibling(getPrevElementByKeyOrThrow(prevKey));\n        destroyNode(prevKey, dom);\n        prevIndex++;\n      } else if (!prevHasNextKey) {\n        // Create next\n        createNode(nextKey, dom, siblingDOM);\n        nextIndex++;\n      } else {\n        // Move next\n        const childDOM = getElementByKeyOrThrow(activeEditor$1, nextKey);\n        if (childDOM === siblingDOM) {\n          siblingDOM = getNextSibling(reconcileNode(nextKey, dom));\n        } else {\n          if (siblingDOM != null) {\n            dom.insertBefore(childDOM, siblingDOM);\n          } else {\n            dom.appendChild(childDOM);\n          }\n          reconcileNode(nextKey, dom);\n        }\n        prevIndex++;\n        nextIndex++;\n      }\n    }\n  }\n  const appendNewChildren = prevIndex > prevEndIndex;\n  const removeOldChildren = nextIndex > nextEndIndex;\n  if (appendNewChildren && !removeOldChildren) {\n    const previousNode = nextChildren[nextEndIndex + 1];\n    const insertDOM = previousNode === undefined ? null : activeEditor$1.getElementByKey(previousNode);\n    createChildren(nextChildren, nextElement, nextIndex, nextEndIndex, dom, insertDOM);\n  } else if (removeOldChildren && !appendNewChildren) {\n    destroyChildren(prevChildren, prevIndex, prevEndIndex, dom);\n  }\n}\nfunction reconcileRoot(prevEditorState, nextEditorState, editor, dirtyType, dirtyElements, dirtyLeaves) {\n  // We cache text content to make retrieval more efficient.\n  // The cache must be rebuilt during reconciliation to account for any changes.\n  subTreeTextContent = '';\n  editorTextContent = '';\n  subTreeDirectionedTextContent = '';\n  // Rather than pass around a load of arguments through the stack recursively\n  // we instead set them as bindings within the scope of the module.\n  treatAllNodesAsDirty = dirtyType === FULL_RECONCILE;\n  activeTextDirection = null;\n  activeEditor$1 = editor;\n  activeEditorConfig = editor._config;\n  activeEditorNodes = editor._nodes;\n  activeMutationListeners = activeEditor$1._listeners.mutation;\n  activeDirtyElements = dirtyElements;\n  activeDirtyLeaves = dirtyLeaves;\n  activePrevNodeMap = prevEditorState._nodeMap;\n  activeNextNodeMap = nextEditorState._nodeMap;\n  activeEditorStateReadOnly = nextEditorState._readOnly;\n  activePrevKeyToDOMMap = new Map(editor._keyToDOMMap);\n  // We keep track of mutated nodes so we can trigger mutation\n  // listeners later in the update cycle.\n  const currentMutatedNodes = new Map();\n  mutatedNodes = currentMutatedNodes;\n  reconcileNode('root', null);\n  // We don't want a bunch of void checks throughout the scope\n  // so instead we make it seem that these values are always set.\n  // We also want to make sure we clear them down, otherwise we\n  // can leak memory.\n  // @ts-ignore\n  activeEditor$1 = undefined;\n  // @ts-ignore\n  activeEditorNodes = undefined;\n  // @ts-ignore\n  activeDirtyElements = undefined;\n  // @ts-ignore\n  activeDirtyLeaves = undefined;\n  // @ts-ignore\n  activePrevNodeMap = undefined;\n  // @ts-ignore\n  activeNextNodeMap = undefined;\n  // @ts-ignore\n  activeEditorConfig = undefined;\n  // @ts-ignore\n  activePrevKeyToDOMMap = undefined;\n  // @ts-ignore\n  mutatedNodes = undefined;\n  return currentMutatedNodes;\n}\nfunction storeDOMWithKey(key, dom, editor) {\n  const keyToDOMMap = editor._keyToDOMMap;\n  // @ts-ignore We intentionally add this to the Node.\n  dom['__lexicalKey_' + editor._key] = key;\n  keyToDOMMap.set(key, dom);\n}\nfunction getPrevElementByKeyOrThrow(key) {\n  const element = activePrevKeyToDOMMap.get(key);\n  if (element === undefined) {\n    {\n      throw Error(`Reconciliation: could not find DOM element for node key ${key}`);\n    }\n  }\n  return element;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst PASS_THROUGH_COMMAND = Object.freeze({});\nconst ANDROID_COMPOSITION_LATENCY = 30;\nconst rootElementEvents = [['keydown', onKeyDown], ['pointerdown', onPointerDown], ['compositionstart', onCompositionStart], ['compositionend', onCompositionEnd], ['input', onInput], ['click', onClick], ['cut', PASS_THROUGH_COMMAND], ['copy', PASS_THROUGH_COMMAND], ['dragstart', PASS_THROUGH_COMMAND], ['dragover', PASS_THROUGH_COMMAND], ['dragend', PASS_THROUGH_COMMAND], ['paste', PASS_THROUGH_COMMAND], ['focus', PASS_THROUGH_COMMAND], ['blur', PASS_THROUGH_COMMAND], ['drop', PASS_THROUGH_COMMAND]];\nif (CAN_USE_BEFORE_INPUT) {\n  rootElementEvents.push(['beforeinput', (event, editor) => onBeforeInput(event, editor)]);\n}\nlet lastKeyDownTimeStamp = 0;\nlet lastKeyCode = 0;\nlet lastBeforeInputInsertTextTimeStamp = 0;\nlet unprocessedBeforeInputData = null;\nconst rootElementsRegistered = new WeakMap();\nlet isSelectionChangeFromDOMUpdate = false;\nlet isSelectionChangeFromMouseDown = false;\nlet isInsertLineBreak = false;\nlet isFirefoxEndingComposition = false;\nlet collapsedSelectionFormat = [0, '', 0, 'root', 0];\n\n// This function is used to determine if Lexical should attempt to override\n// the default browser behavior for insertion of text and use its own internal\n// heuristics. This is an extremely important function, and makes much of Lexical\n// work as intended between different browsers and across word, line and character\n// boundary/formats. It also is important for text replacement, node schemas and\n// composition mechanics.\n\nfunction $shouldPreventDefaultAndInsertText(selection, domTargetRange, text, timeStamp, isBeforeInput) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const editor = getActiveEditor();\n  const domSelection = getDOMSelection(editor._window);\n  const domAnchorNode = domSelection !== null ? domSelection.anchorNode : null;\n  const anchorKey = anchor.key;\n  const backingAnchorElement = editor.getElementByKey(anchorKey);\n  const textLength = text.length;\n  return anchorKey !== focus.key ||\n  // If we're working with a non-text node.\n  !$isTextNode(anchorNode) ||\n  // If we are replacing a range with a single character or grapheme, and not composing.\n  (!isBeforeInput && (!CAN_USE_BEFORE_INPUT ||\n  // We check to see if there has been\n  // a recent beforeinput event for \"textInput\". If there has been one in the last\n  // 50ms then we proceed as normal. However, if there is not, then this is likely\n  // a dangling `input` event caused by execCommand('insertText').\n  lastBeforeInputInsertTextTimeStamp < timeStamp + 50) || anchorNode.isDirty() && textLength < 2 || doesContainGrapheme(text)) && anchor.offset !== focus.offset && !anchorNode.isComposing() ||\n  // Any non standard text node.\n  $isTokenOrSegmented(anchorNode) ||\n  // If the text length is more than a single character and we're either\n  // dealing with this in \"beforeinput\" or where the node has already recently\n  // been changed (thus is dirty).\n  anchorNode.isDirty() && textLength > 1 ||\n  // If the DOM selection element is not the same as the backing node during beforeinput.\n  (isBeforeInput || !CAN_USE_BEFORE_INPUT) && backingAnchorElement !== null && !anchorNode.isComposing() && domAnchorNode !== getDOMTextNode(backingAnchorElement) ||\n  // If TargetRange is not the same as the DOM selection; browser trying to edit random parts\n  // of the editor.\n  domSelection !== null && domTargetRange !== null && (!domTargetRange.collapsed || domTargetRange.startContainer !== domSelection.anchorNode || domTargetRange.startOffset !== domSelection.anchorOffset) ||\n  // Check if we're changing from bold to italics, or some other format.\n  anchorNode.getFormat() !== selection.format || anchorNode.getStyle() !== selection.style ||\n  // One last set of heuristics to check against.\n  $shouldInsertTextAfterOrBeforeTextNode(selection, anchorNode);\n}\nfunction shouldSkipSelectionChange(domNode, offset) {\n  return domNode !== null && domNode.nodeValue !== null && domNode.nodeType === DOM_TEXT_TYPE && offset !== 0 && offset !== domNode.nodeValue.length;\n}\nfunction onSelectionChange(domSelection, editor, isActive) {\n  const {\n    anchorNode: anchorDOM,\n    anchorOffset,\n    focusNode: focusDOM,\n    focusOffset\n  } = domSelection;\n  if (isSelectionChangeFromDOMUpdate) {\n    isSelectionChangeFromDOMUpdate = false;\n\n    // If native DOM selection is on a DOM element, then\n    // we should continue as usual, as Lexical's selection\n    // may have normalized to a better child. If the DOM\n    // element is a text node, we can safely apply this\n    // optimization and skip the selection change entirely.\n    // We also need to check if the offset is at the boundary,\n    // because in this case, we might need to normalize to a\n    // sibling instead.\n    if (shouldSkipSelectionChange(anchorDOM, anchorOffset) && shouldSkipSelectionChange(focusDOM, focusOffset)) {\n      return;\n    }\n  }\n  updateEditor(editor, () => {\n    // Non-active editor don't need any extra logic for selection, it only needs update\n    // to reconcile selection (set it to null) to ensure that only one editor has non-null selection.\n    if (!isActive) {\n      $setSelection(null);\n      return;\n    }\n    if (!isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n      return;\n    }\n    const selection = $getSelection();\n\n    // Update the selection format\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      if (selection.isCollapsed()) {\n        // Badly interpreted range selection when collapsed - #1482\n        if (domSelection.type === 'Range' && domSelection.anchorNode === domSelection.focusNode) {\n          selection.dirty = true;\n        }\n\n        // If we have marked a collapsed selection format, and we're\n        // within the given time range  then attempt to use that format\n        // instead of getting the format from the anchor node.\n        const windowEvent = getWindow(editor).event;\n        const currentTimeStamp = windowEvent ? windowEvent.timeStamp : performance.now();\n        const [lastFormat, lastStyle, lastOffset, lastKey, timeStamp] = collapsedSelectionFormat;\n        const root = $getRoot();\n        const isRootTextContentEmpty = editor.isComposing() === false && root.getTextContent() === '';\n        if (currentTimeStamp < timeStamp + 200 && anchor.offset === lastOffset && anchor.key === lastKey) {\n          selection.format = lastFormat;\n          selection.style = lastStyle;\n        } else {\n          if (anchor.type === 'text') {\n            if (!$isTextNode(anchorNode)) {\n              throw Error(`Point.getNode() must return TextNode when type is text`);\n            }\n            selection.format = anchorNode.getFormat();\n            selection.style = anchorNode.getStyle();\n          } else if (anchor.type === 'element' && !isRootTextContentEmpty) {\n            selection.format = 0;\n            selection.style = '';\n          }\n        }\n      } else {\n        const anchorKey = anchor.key;\n        const focus = selection.focus;\n        const focusKey = focus.key;\n        const nodes = selection.getNodes();\n        const nodesLength = nodes.length;\n        const isBackward = selection.isBackward();\n        const startOffset = isBackward ? focusOffset : anchorOffset;\n        const endOffset = isBackward ? anchorOffset : focusOffset;\n        const startKey = isBackward ? focusKey : anchorKey;\n        const endKey = isBackward ? anchorKey : focusKey;\n        let combinedFormat = IS_ALL_FORMATTING;\n        let hasTextNodes = false;\n        for (let i = 0; i < nodesLength; i++) {\n          const node = nodes[i];\n          const textContentSize = node.getTextContentSize();\n          if ($isTextNode(node) && textContentSize !== 0 &&\n          // Exclude empty text nodes at boundaries resulting from user's selection\n          !(i === 0 && node.__key === startKey && startOffset === textContentSize || i === nodesLength - 1 && node.__key === endKey && endOffset === 0)) {\n            // TODO: what about style?\n            hasTextNodes = true;\n            combinedFormat &= node.getFormat();\n            if (combinedFormat === 0) {\n              break;\n            }\n          }\n        }\n        selection.format = hasTextNodes ? combinedFormat : 0;\n      }\n    }\n    dispatchCommand(editor, SELECTION_CHANGE_COMMAND, undefined);\n  });\n}\n\n// This is a work-around is mainly Chrome specific bug where if you select\n// the contents of an empty block, you cannot easily unselect anything.\n// This results in a tiny selection box that looks buggy/broken. This can\n// also help other browsers when selection might \"appear\" lost, when it\n// really isn't.\nfunction onClick(event, editor) {\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    const domSelection = getDOMSelection(editor._window);\n    const lastSelection = $getPreviousSelection();\n    if (domSelection) {\n      if ($isRangeSelection(selection)) {\n        const anchor = selection.anchor;\n        const anchorNode = anchor.getNode();\n        if (anchor.type === 'element' && anchor.offset === 0 && selection.isCollapsed() && !$isRootNode(anchorNode) && $getRoot().getChildrenSize() === 1 && anchorNode.getTopLevelElementOrThrow().isEmpty() && lastSelection !== null && selection.is(lastSelection)) {\n          domSelection.removeAllRanges();\n          selection.dirty = true;\n        } else if (event.detail === 3 && !selection.isCollapsed()) {\n          // Tripple click causing selection to overflow into the nearest element. In that\n          // case visually it looks like a single element content is selected, focus node\n          // is actually at the beginning of the next element (if present) and any manipulations\n          // with selection (formatting) are affecting second element as well\n          const focus = selection.focus;\n          const focusNode = focus.getNode();\n          if (anchorNode !== focusNode) {\n            if ($isElementNode(anchorNode)) {\n              anchorNode.select(0);\n            } else {\n              anchorNode.getParentOrThrow().select(0);\n            }\n          }\n        }\n      } else if (event.pointerType === 'touch') {\n        // This is used to update the selection on touch devices when the user clicks on text after a\n        // node selection. See isSelectionChangeFromMouseDown for the inverse\n        const domAnchorNode = domSelection.anchorNode;\n        if (domAnchorNode !== null) {\n          const nodeType = domAnchorNode.nodeType;\n          // If the user is attempting to click selection back onto text, then\n          // we should attempt create a range selection.\n          // When we click on an empty paragraph node or the end of a paragraph that ends\n          // with an image/poll, the nodeType will be ELEMENT_NODE\n          if (nodeType === DOM_ELEMENT_TYPE || nodeType === DOM_TEXT_TYPE) {\n            const newSelection = internalCreateRangeSelection(lastSelection, domSelection, editor, event);\n            $setSelection(newSelection);\n          }\n        }\n      }\n    }\n    dispatchCommand(editor, CLICK_COMMAND, event);\n  });\n}\nfunction onPointerDown(event, editor) {\n  // TODO implement text drag & drop\n  const target = event.target;\n  const pointerType = event.pointerType;\n  if (target instanceof Node && pointerType !== 'touch') {\n    updateEditor(editor, () => {\n      // Drag & drop should not recompute selection until mouse up; otherwise the initially\n      // selected content is lost.\n      if (!$isSelectionCapturedInDecorator(target)) {\n        isSelectionChangeFromMouseDown = true;\n      }\n    });\n  }\n}\nfunction getTargetRange(event) {\n  if (!event.getTargetRanges) {\n    return null;\n  }\n  const targetRanges = event.getTargetRanges();\n  if (targetRanges.length === 0) {\n    return null;\n  }\n  return targetRanges[0];\n}\nfunction $canRemoveText(anchorNode, focusNode) {\n  return anchorNode !== focusNode || $isElementNode(anchorNode) || $isElementNode(focusNode) || !anchorNode.isToken() || !focusNode.isToken();\n}\nfunction isPossiblyAndroidKeyPress(timeStamp) {\n  return lastKeyCode === 229 && timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY;\n}\nfunction onBeforeInput(event, editor) {\n  const inputType = event.inputType;\n  const targetRange = getTargetRange(event);\n\n  // We let the browser do its own thing for composition.\n  if (inputType === 'deleteCompositionText' ||\n  // If we're pasting in FF, we shouldn't get this event\n  // as the `paste` event should have triggered, unless the\n  // user has dom.event.clipboardevents.enabled disabled in\n  // about:config. In that case, we need to process the\n  // pasted content in the DOM mutation phase.\n  IS_FIREFOX && isFirefoxClipboardEvents(editor)) {\n    return;\n  } else if (inputType === 'insertCompositionText') {\n    return;\n  }\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    if (inputType === 'deleteContentBackward') {\n      if (selection === null) {\n        // Use previous selection\n        const prevSelection = $getPreviousSelection();\n        if (!$isRangeSelection(prevSelection)) {\n          return;\n        }\n        $setSelection(prevSelection.clone());\n      }\n      if ($isRangeSelection(selection)) {\n        const isSelectionAnchorSameAsFocus = selection.anchor.key === selection.focus.key;\n        if (isPossiblyAndroidKeyPress(event.timeStamp) && editor.isComposing() && isSelectionAnchorSameAsFocus) {\n          $setCompositionKey(null);\n          lastKeyDownTimeStamp = 0;\n          // Fixes an Android bug where selection flickers when backspacing\n          setTimeout(() => {\n            updateEditor(editor, () => {\n              $setCompositionKey(null);\n            });\n          }, ANDROID_COMPOSITION_LATENCY);\n          if ($isRangeSelection(selection)) {\n            const anchorNode = selection.anchor.getNode();\n            anchorNode.markDirty();\n            selection.format = anchorNode.getFormat();\n            if (!$isTextNode(anchorNode)) {\n              throw Error(`Anchor node must be a TextNode`);\n            }\n            selection.style = anchorNode.getStyle();\n          }\n        } else {\n          $setCompositionKey(null);\n          event.preventDefault();\n          // Chromium Android at the moment seems to ignore the preventDefault\n          // on 'deleteContentBackward' and still deletes the content. Which leads\n          // to multiple deletions. So we let the browser handle the deletion in this case.\n          const selectedNodeText = selection.anchor.getNode().getTextContent();\n          const hasSelectedAllTextInNode = selection.anchor.offset === 0 && selection.focus.offset === selectedNodeText.length;\n          const shouldLetBrowserHandleDelete = IS_ANDROID_CHROME && isSelectionAnchorSameAsFocus && !hasSelectedAllTextInNode;\n          if (!shouldLetBrowserHandleDelete) {\n            dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);\n          }\n        }\n        return;\n      }\n    }\n    if (!$isRangeSelection(selection)) {\n      return;\n    }\n    const data = event.data;\n\n    // This represents the case when two beforeinput events are triggered at the same time (without a\n    // full event loop ending at input). This happens with MacOS with the default keyboard settings,\n    // a combination of autocorrection + autocapitalization.\n    // Having Lexical run everything in controlled mode would fix the issue without additional code\n    // but this would kill the massive performance win from the most common typing event.\n    // Alternatively, when this happens we can prematurely update our EditorState based on the DOM\n    // content, a job that would usually be the input event's responsibility.\n    if (unprocessedBeforeInputData !== null) {\n      $updateSelectedTextFromDOM(false, editor, unprocessedBeforeInputData);\n    }\n    if ((!selection.dirty || unprocessedBeforeInputData !== null) && selection.isCollapsed() && !$isRootNode(selection.anchor.getNode()) && targetRange !== null) {\n      selection.applyDOMRange(targetRange);\n    }\n    unprocessedBeforeInputData = null;\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    if (inputType === 'insertText' || inputType === 'insertTranspose') {\n      if (data === '\\n') {\n        event.preventDefault();\n        dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n      } else if (data === DOUBLE_LINE_BREAK) {\n        event.preventDefault();\n        dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, undefined);\n      } else if (data == null && event.dataTransfer) {\n        // Gets around a Safari text replacement bug.\n        const text = event.dataTransfer.getData('text/plain');\n        event.preventDefault();\n        selection.insertRawText(text);\n      } else if (data != null && $shouldPreventDefaultAndInsertText(selection, targetRange, data, event.timeStamp, true)) {\n        event.preventDefault();\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);\n      } else {\n        unprocessedBeforeInputData = data;\n      }\n      lastBeforeInputInsertTextTimeStamp = event.timeStamp;\n      return;\n    }\n\n    // Prevent the browser from carrying out\n    // the input event, so we can control the\n    // output.\n    event.preventDefault();\n    switch (inputType) {\n      case 'insertFromYank':\n      case 'insertFromDrop':\n      case 'insertReplacementText':\n        {\n          dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);\n          break;\n        }\n      case 'insertFromComposition':\n        {\n          // This is the end of composition\n          $setCompositionKey(null);\n          dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);\n          break;\n        }\n      case 'insertLineBreak':\n        {\n          // Used for Android\n          $setCompositionKey(null);\n          dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n          break;\n        }\n      case 'insertParagraph':\n        {\n          // Used for Android\n          $setCompositionKey(null);\n\n          // Safari does not provide the type \"insertLineBreak\".\n          // So instead, we need to infer it from the keyboard event.\n          // We do not apply this logic to iOS to allow newline auto-capitalization\n          // work without creating linebreaks when pressing Enter\n          if (isInsertLineBreak && !IS_IOS) {\n            isInsertLineBreak = false;\n            dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n          } else {\n            dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, undefined);\n          }\n          break;\n        }\n      case 'insertFromPaste':\n      case 'insertFromPasteAsQuotation':\n        {\n          dispatchCommand(editor, PASTE_COMMAND, event);\n          break;\n        }\n      case 'deleteByComposition':\n        {\n          if ($canRemoveText(anchorNode, focusNode)) {\n            dispatchCommand(editor, REMOVE_TEXT_COMMAND, event);\n          }\n          break;\n        }\n      case 'deleteByDrag':\n      case 'deleteByCut':\n        {\n          dispatchCommand(editor, REMOVE_TEXT_COMMAND, event);\n          break;\n        }\n      case 'deleteContent':\n        {\n          dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);\n          break;\n        }\n      case 'deleteWordBackward':\n        {\n          dispatchCommand(editor, DELETE_WORD_COMMAND, true);\n          break;\n        }\n      case 'deleteWordForward':\n        {\n          dispatchCommand(editor, DELETE_WORD_COMMAND, false);\n          break;\n        }\n      case 'deleteHardLineBackward':\n      case 'deleteSoftLineBackward':\n        {\n          dispatchCommand(editor, DELETE_LINE_COMMAND, true);\n          break;\n        }\n      case 'deleteContentForward':\n      case 'deleteHardLineForward':\n      case 'deleteSoftLineForward':\n        {\n          dispatchCommand(editor, DELETE_LINE_COMMAND, false);\n          break;\n        }\n      case 'formatStrikeThrough':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'strikethrough');\n          break;\n        }\n      case 'formatBold':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'bold');\n          break;\n        }\n      case 'formatItalic':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'italic');\n          break;\n        }\n      case 'formatUnderline':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'underline');\n          break;\n        }\n      case 'historyUndo':\n        {\n          dispatchCommand(editor, UNDO_COMMAND, undefined);\n          break;\n        }\n      case 'historyRedo':\n        {\n          dispatchCommand(editor, REDO_COMMAND, undefined);\n          break;\n        }\n      // NO-OP\n    }\n  });\n}\n\nfunction onInput(event, editor) {\n  // We don't want the onInput to bubble, in the case of nested editors.\n  event.stopPropagation();\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    const data = event.data;\n    const targetRange = getTargetRange(event);\n    if (data != null && $isRangeSelection(selection) && $shouldPreventDefaultAndInsertText(selection, targetRange, data, event.timeStamp, false)) {\n      // Given we're over-riding the default behavior, we will need\n      // to ensure to disable composition before dispatching the\n      // insertText command for when changing the sequence for FF.\n      if (isFirefoxEndingComposition) {\n        onCompositionEndImpl(editor, data);\n        isFirefoxEndingComposition = false;\n      }\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      const domSelection = getDOMSelection(editor._window);\n      if (domSelection === null) {\n        return;\n      }\n      const offset = anchor.offset;\n      // If the content is the same as inserted, then don't dispatch an insertion.\n      // Given onInput doesn't take the current selection (it uses the previous)\n      // we can compare that against what the DOM currently says.\n      if (!CAN_USE_BEFORE_INPUT || selection.isCollapsed() || !$isTextNode(anchorNode) || domSelection.anchorNode === null || anchorNode.getTextContent().slice(0, offset) + data + anchorNode.getTextContent().slice(offset + selection.focus.offset) !== getAnchorTextFromDOM(domSelection.anchorNode)) {\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);\n      }\n      const textLength = data.length;\n\n      // Another hack for FF, as it's possible that the IME is still\n      // open, even though compositionend has already fired (sigh).\n      if (IS_FIREFOX && textLength > 1 && event.inputType === 'insertCompositionText' && !editor.isComposing()) {\n        selection.anchor.offset -= textLength;\n      }\n\n      // This ensures consistency on Android.\n      if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT && editor.isComposing()) {\n        lastKeyDownTimeStamp = 0;\n        $setCompositionKey(null);\n      }\n    } else {\n      const characterData = data !== null ? data : undefined;\n      $updateSelectedTextFromDOM(false, editor, characterData);\n\n      // onInput always fires after onCompositionEnd for FF.\n      if (isFirefoxEndingComposition) {\n        onCompositionEndImpl(editor, data || undefined);\n        isFirefoxEndingComposition = false;\n      }\n    }\n\n    // Also flush any other mutations that might have occurred\n    // since the change.\n    $flushMutations();\n  });\n  unprocessedBeforeInputData = null;\n}\nfunction onCompositionStart(event, editor) {\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    if ($isRangeSelection(selection) && !editor.isComposing()) {\n      const anchor = selection.anchor;\n      const node = selection.anchor.getNode();\n      $setCompositionKey(anchor.key);\n      if (\n      // If it has been 30ms since the last keydown, then we should\n      // apply the empty space heuristic. We can't do this for Safari,\n      // as the keydown fires after composition start.\n      event.timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY ||\n      // FF has issues around composing multibyte characters, so we also\n      // need to invoke the empty space heuristic below.\n      anchor.type === 'element' || !selection.isCollapsed() || node.getFormat() !== selection.format || $isTextNode(node) && node.getStyle() !== selection.style) {\n        // We insert a zero width character, ready for the composition\n        // to get inserted into the new node we create. If\n        // we don't do this, Safari will fail on us because\n        // there is no text node matching the selection.\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, COMPOSITION_START_CHAR);\n      }\n    }\n  });\n}\nfunction onCompositionEndImpl(editor, data) {\n  const compositionKey = editor._compositionKey;\n  $setCompositionKey(null);\n\n  // Handle termination of composition.\n  if (compositionKey !== null && data != null) {\n    // Composition can sometimes move to an adjacent DOM node when backspacing.\n    // So check for the empty case.\n    if (data === '') {\n      const node = $getNodeByKey(compositionKey);\n      const textNode = getDOMTextNode(editor.getElementByKey(compositionKey));\n      if (textNode !== null && textNode.nodeValue !== null && $isTextNode(node)) {\n        $updateTextNodeFromDOMContent(node, textNode.nodeValue, null, null, true);\n      }\n      return;\n    }\n\n    // Composition can sometimes be that of a new line. In which case, we need to\n    // handle that accordingly.\n    if (data[data.length - 1] === '\\n') {\n      const selection = $getSelection();\n      if ($isRangeSelection(selection)) {\n        // If the last character is a line break, we also need to insert\n        // a line break.\n        const focus = selection.focus;\n        selection.anchor.set(focus.key, focus.offset, focus.type);\n        dispatchCommand(editor, KEY_ENTER_COMMAND, null);\n        return;\n      }\n    }\n  }\n  $updateSelectedTextFromDOM(true, editor, data);\n}\nfunction onCompositionEnd(event, editor) {\n  // Firefox fires onCompositionEnd before onInput, but Chrome/Webkit,\n  // fire onInput before onCompositionEnd. To ensure the sequence works\n  // like Chrome/Webkit we use the isFirefoxEndingComposition flag to\n  // defer handling of onCompositionEnd in Firefox till we have processed\n  // the logic in onInput.\n  if (IS_FIREFOX) {\n    isFirefoxEndingComposition = true;\n  } else {\n    updateEditor(editor, () => {\n      onCompositionEndImpl(editor, event.data);\n    });\n  }\n}\nfunction onKeyDown(event, editor) {\n  lastKeyDownTimeStamp = event.timeStamp;\n  lastKeyCode = event.keyCode;\n  if (editor.isComposing()) {\n    return;\n  }\n  const {\n    keyCode,\n    shiftKey,\n    ctrlKey,\n    metaKey,\n    altKey\n  } = event;\n  if (dispatchCommand(editor, KEY_DOWN_COMMAND, event)) {\n    return;\n  }\n  if (isMoveForward(keyCode, ctrlKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_RIGHT_COMMAND, event);\n  } else if (isMoveToEnd(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, MOVE_TO_END, event);\n  } else if (isMoveBackward(keyCode, ctrlKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_LEFT_COMMAND, event);\n  } else if (isMoveToStart(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, MOVE_TO_START, event);\n  } else if (isMoveUp(keyCode, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_UP_COMMAND, event);\n  } else if (isMoveDown(keyCode, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_DOWN_COMMAND, event);\n  } else if (isLineBreak(keyCode, shiftKey)) {\n    isInsertLineBreak = true;\n    dispatchCommand(editor, KEY_ENTER_COMMAND, event);\n  } else if (isSpace(keyCode)) {\n    dispatchCommand(editor, KEY_SPACE_COMMAND, event);\n  } else if (isOpenLineBreak(keyCode, ctrlKey)) {\n    event.preventDefault();\n    isInsertLineBreak = true;\n    dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, true);\n  } else if (isParagraph(keyCode, shiftKey)) {\n    isInsertLineBreak = false;\n    dispatchCommand(editor, KEY_ENTER_COMMAND, event);\n  } else if (isDeleteBackward(keyCode, altKey, metaKey, ctrlKey)) {\n    if (isBackspace(keyCode)) {\n      dispatchCommand(editor, KEY_BACKSPACE_COMMAND, event);\n    } else {\n      event.preventDefault();\n      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);\n    }\n  } else if (isEscape(keyCode)) {\n    dispatchCommand(editor, KEY_ESCAPE_COMMAND, event);\n  } else if (isDeleteForward(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {\n    if (isDelete(keyCode)) {\n      dispatchCommand(editor, KEY_DELETE_COMMAND, event);\n    } else {\n      event.preventDefault();\n      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);\n    }\n  } else if (isDeleteWordBackward(keyCode, altKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_WORD_COMMAND, true);\n  } else if (isDeleteWordForward(keyCode, altKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_WORD_COMMAND, false);\n  } else if (isDeleteLineBackward(keyCode, metaKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_LINE_COMMAND, true);\n  } else if (isDeleteLineForward(keyCode, metaKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_LINE_COMMAND, false);\n  } else if (isBold(keyCode, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'bold');\n  } else if (isUnderline(keyCode, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'underline');\n  } else if (isItalic(keyCode, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'italic');\n  } else if (isTab(keyCode, altKey, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_TAB_COMMAND, event);\n  } else if (isUndo(keyCode, shiftKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, UNDO_COMMAND, undefined);\n  } else if (isRedo(keyCode, shiftKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, REDO_COMMAND, undefined);\n  } else {\n    const prevSelection = editor._editorState._selection;\n    if ($isNodeSelection(prevSelection)) {\n      if (isCopy(keyCode, shiftKey, metaKey, ctrlKey)) {\n        event.preventDefault();\n        dispatchCommand(editor, COPY_COMMAND, event);\n      } else if (isCut(keyCode, shiftKey, metaKey, ctrlKey)) {\n        event.preventDefault();\n        dispatchCommand(editor, CUT_COMMAND, event);\n      } else if (isSelectAll(keyCode, metaKey, ctrlKey)) {\n        event.preventDefault();\n        dispatchCommand(editor, SELECT_ALL_COMMAND, event);\n      }\n      // FF does it well (no need to override behavior)\n    } else if (!IS_FIREFOX && isSelectAll(keyCode, metaKey, ctrlKey)) {\n      event.preventDefault();\n      dispatchCommand(editor, SELECT_ALL_COMMAND, event);\n    }\n  }\n  if (isModifier(ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_MODIFIER_COMMAND, event);\n  }\n}\nfunction getRootElementRemoveHandles(rootElement) {\n  // @ts-expect-error: internal field\n  let eventHandles = rootElement.__lexicalEventHandles;\n  if (eventHandles === undefined) {\n    eventHandles = [];\n    // @ts-expect-error: internal field\n    rootElement.__lexicalEventHandles = eventHandles;\n  }\n  return eventHandles;\n}\n\n// Mapping root editors to their active nested editors, contains nested editors\n// mapping only, so if root editor is selected map will have no reference to free up memory\nconst activeNestedEditorsMap = new Map();\nfunction onDocumentSelectionChange(event) {\n  const target = event.target;\n  const targetWindow = target == null ? null : target.nodeType === 9 ? target.defaultView : target.ownerDocument.defaultView;\n  const domSelection = getDOMSelection(targetWindow);\n  if (domSelection === null) {\n    return;\n  }\n  const nextActiveEditor = getNearestEditorFromDOMNode(domSelection.anchorNode);\n  if (nextActiveEditor === null) {\n    return;\n  }\n  if (isSelectionChangeFromMouseDown) {\n    isSelectionChangeFromMouseDown = false;\n    updateEditor(nextActiveEditor, () => {\n      const lastSelection = $getPreviousSelection();\n      const domAnchorNode = domSelection.anchorNode;\n      if (domAnchorNode === null) {\n        return;\n      }\n      const nodeType = domAnchorNode.nodeType;\n      // If the user is attempting to click selection back onto text, then\n      // we should attempt create a range selection.\n      // When we click on an empty paragraph node or the end of a paragraph that ends\n      // with an image/poll, the nodeType will be ELEMENT_NODE\n      if (nodeType !== DOM_ELEMENT_TYPE && nodeType !== DOM_TEXT_TYPE) {\n        return;\n      }\n      const newSelection = internalCreateRangeSelection(lastSelection, domSelection, nextActiveEditor, event);\n      $setSelection(newSelection);\n    });\n  }\n\n  // When editor receives selection change event, we're checking if\n  // it has any sibling editors (within same parent editor) that were active\n  // before, and trigger selection change on it to nullify selection.\n  const editors = getEditorsToPropagate(nextActiveEditor);\n  const rootEditor = editors[editors.length - 1];\n  const rootEditorKey = rootEditor._key;\n  const activeNestedEditor = activeNestedEditorsMap.get(rootEditorKey);\n  const prevActiveEditor = activeNestedEditor || rootEditor;\n  if (prevActiveEditor !== nextActiveEditor) {\n    onSelectionChange(domSelection, prevActiveEditor, false);\n  }\n  onSelectionChange(domSelection, nextActiveEditor, true);\n\n  // If newly selected editor is nested, then add it to the map, clean map otherwise\n  if (nextActiveEditor !== rootEditor) {\n    activeNestedEditorsMap.set(rootEditorKey, nextActiveEditor);\n  } else if (activeNestedEditor) {\n    activeNestedEditorsMap.delete(rootEditorKey);\n  }\n}\nfunction stopLexicalPropagation(event) {\n  // We attach a special property to ensure the same event doesn't re-fire\n  // for parent editors.\n  // @ts-ignore\n  event._lexicalHandled = true;\n}\nfunction hasStoppedLexicalPropagation(event) {\n  // @ts-ignore\n  const stopped = event._lexicalHandled === true;\n  return stopped;\n}\nfunction addRootElementEvents(rootElement, editor) {\n  // We only want to have a single global selectionchange event handler, shared\n  // between all editor instances.\n  const doc = rootElement.ownerDocument;\n  const documentRootElementsCount = rootElementsRegistered.get(doc);\n  if (documentRootElementsCount === undefined) {\n    doc.addEventListener('selectionchange', onDocumentSelectionChange);\n  }\n  rootElementsRegistered.set(doc, documentRootElementsCount || 0 + 1);\n\n  // @ts-expect-error: internal field\n  rootElement.__lexicalEditor = editor;\n  const removeHandles = getRootElementRemoveHandles(rootElement);\n  for (let i = 0; i < rootElementEvents.length; i++) {\n    const [eventName, onEvent] = rootElementEvents[i];\n    const eventHandler = typeof onEvent === 'function' ? event => {\n      if (hasStoppedLexicalPropagation(event)) {\n        return;\n      }\n      stopLexicalPropagation(event);\n      if (editor.isEditable() || eventName === 'click') {\n        onEvent(event, editor);\n      }\n    } : event => {\n      if (hasStoppedLexicalPropagation(event)) {\n        return;\n      }\n      stopLexicalPropagation(event);\n      if (editor.isEditable()) {\n        switch (eventName) {\n          case 'cut':\n            return dispatchCommand(editor, CUT_COMMAND, event);\n          case 'copy':\n            return dispatchCommand(editor, COPY_COMMAND, event);\n          case 'paste':\n            return dispatchCommand(editor, PASTE_COMMAND, event);\n          case 'dragstart':\n            return dispatchCommand(editor, DRAGSTART_COMMAND, event);\n          case 'dragover':\n            return dispatchCommand(editor, DRAGOVER_COMMAND, event);\n          case 'dragend':\n            return dispatchCommand(editor, DRAGEND_COMMAND, event);\n          case 'focus':\n            return dispatchCommand(editor, FOCUS_COMMAND, event);\n          case 'blur':\n            {\n              return dispatchCommand(editor, BLUR_COMMAND, event);\n            }\n          case 'drop':\n            return dispatchCommand(editor, DROP_COMMAND, event);\n        }\n      }\n    };\n    rootElement.addEventListener(eventName, eventHandler);\n    removeHandles.push(() => {\n      rootElement.removeEventListener(eventName, eventHandler);\n    });\n  }\n}\nfunction removeRootElementEvents(rootElement) {\n  const doc = rootElement.ownerDocument;\n  const documentRootElementsCount = rootElementsRegistered.get(doc);\n  if (!(documentRootElementsCount !== undefined)) {\n    throw Error(`Root element not registered`);\n  } // We only want to have a single global selectionchange event handler, shared\n  // between all editor instances.\n  rootElementsRegistered.set(doc, documentRootElementsCount - 1);\n  if (documentRootElementsCount === 1) {\n    doc.removeEventListener('selectionchange', onDocumentSelectionChange);\n  }\n\n  // @ts-expect-error: internal field\n  const editor = rootElement.__lexicalEditor;\n  if (editor !== null && editor !== undefined) {\n    cleanActiveNestedEditorsMap(editor);\n    // @ts-expect-error: internal field\n    rootElement.__lexicalEditor = null;\n  }\n  const removeHandles = getRootElementRemoveHandles(rootElement);\n  for (let i = 0; i < removeHandles.length; i++) {\n    removeHandles[i]();\n  }\n\n  // @ts-expect-error: internal field\n  rootElement.__lexicalEventHandles = [];\n}\nfunction cleanActiveNestedEditorsMap(editor) {\n  if (editor._parentEditor !== null) {\n    // For nested editor cleanup map if this editor was marked as active\n    const editors = getEditorsToPropagate(editor);\n    const rootEditor = editors[editors.length - 1];\n    const rootEditorKey = rootEditor._key;\n    if (activeNestedEditorsMap.get(rootEditorKey) === editor) {\n      activeNestedEditorsMap.delete(rootEditorKey);\n    }\n  } else {\n    // For top-level editors cleanup map\n    activeNestedEditorsMap.delete(editor._key);\n  }\n}\nfunction markSelectionChangeFromDOMUpdate() {\n  isSelectionChangeFromDOMUpdate = true;\n}\nfunction markCollapsedSelectionFormat(format, style, offset, key, timeStamp) {\n  collapsedSelectionFormat = [format, style, offset, key, timeStamp];\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction removeNode(nodeToRemove, restoreSelection, preserveEmptyParent) {\n  errorOnReadOnly();\n  const key = nodeToRemove.__key;\n  const parent = nodeToRemove.getParent();\n  if (parent === null) {\n    return;\n  }\n  const selection = $maybeMoveChildrenSelectionToParent(nodeToRemove);\n  let selectionMoved = false;\n  if ($isRangeSelection(selection) && restoreSelection) {\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    if (anchor.key === key) {\n      moveSelectionPointToSibling(anchor, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());\n      selectionMoved = true;\n    }\n    if (focus.key === key) {\n      moveSelectionPointToSibling(focus, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());\n      selectionMoved = true;\n    }\n  } else if ($isNodeSelection(selection) && restoreSelection && nodeToRemove.isSelected()) {\n    nodeToRemove.selectPrevious();\n  }\n  if ($isRangeSelection(selection) && restoreSelection && !selectionMoved) {\n    // Doing this is O(n) so lets avoid it unless we need to do it\n    const index = nodeToRemove.getIndexWithinParent();\n    removeFromParent(nodeToRemove);\n    $updateElementSelectionOnCreateDeleteNode(selection, parent, index, -1);\n  } else {\n    removeFromParent(nodeToRemove);\n  }\n  if (!preserveEmptyParent && !$isRootOrShadowRoot(parent) && !parent.canBeEmpty() && parent.isEmpty()) {\n    removeNode(parent, restoreSelection);\n  }\n  if (restoreSelection && $isRootNode(parent) && parent.isEmpty()) {\n    parent.selectEnd();\n  }\n}\nclass LexicalNode {\n  // Allow us to look up the type including static props\n\n  /** @internal */\n\n  /** @internal */ //@ts-ignore We set the key in the constructor.\n  /** @internal */\n  /** @internal */\n  /** @internal */\n  // Flow doesn't support abstract classes unfortunately, so we can't _force_\n  // subclasses of Node to implement statics. All subclasses of Node should have\n  // a static getType and clone method though. We define getType and clone here so we can call it\n  // on any  Node, and we throw this error by default since the subclass should provide\n  // their own implementation.\n  /**\n   * Returns the string type of this node. Every node must\n   * implement this and it MUST BE UNIQUE amongst nodes registered\n   * on the editor.\n   *\n   */\n  static getType() {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .getType().`);\n    }\n  }\n\n  /**\n   * Clones this node, creating a new node with a different key\n   * and adding it to the EditorState (but not attaching it anywhere!). All nodes must\n   * implement this method.\n   *\n   */\n  static clone(_data) {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .clone().`);\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n  constructor(key) {\n    this.__type = this.constructor.getType();\n    this.__parent = null;\n    this.__prev = null;\n    this.__next = null;\n    $setNodeKey(this, key);\n    {\n      if (this.__type !== 'root') {\n        errorOnReadOnly();\n        errorOnTypeKlassMismatch(this.__type, this.constructor);\n      }\n    }\n  }\n  // Getters and Traversers\n\n  /**\n   * Returns the string type of this node.\n   */\n  getType() {\n    return this.__type;\n  }\n  isInline() {\n    {\n      throw Error(`LexicalNode: Node ${this.constructor.name} does not implement .isInline().`);\n    }\n  }\n\n  /**\n   * Returns true if there is a path between this node and the RootNode, false otherwise.\n   * This is a way of determining if the node is \"attached\" EditorState. Unattached nodes\n   * won't be reconciled and will ultimatelt be cleaned up by the Lexical GC.\n   */\n  isAttached() {\n    let nodeKey = this.__key;\n    while (nodeKey !== null) {\n      if (nodeKey === 'root') {\n        return true;\n      }\n      const node = $getNodeByKey(nodeKey);\n      if (node === null) {\n        break;\n      }\n      nodeKey = node.__parent;\n    }\n    return false;\n  }\n\n  /**\n   * Returns true if this node is contained within the provided Selection., false otherwise.\n   * Relies on the algorithms implemented in {@link BaseSelection.getNodes} to determine\n   * what's included.\n   *\n   * @param selection - The selection that we want to determine if the node is in.\n   */\n  isSelected(selection) {\n    const targetSelection = selection || $getSelection();\n    if (targetSelection == null) {\n      return false;\n    }\n    const isSelected = targetSelection.getNodes().some(n => n.__key === this.__key);\n    if ($isTextNode(this)) {\n      return isSelected;\n    }\n    // For inline images inside of element nodes.\n    // Without this change the image will be selected if the cursor is before or after it.\n    if ($isRangeSelection(targetSelection) && targetSelection.anchor.type === 'element' && targetSelection.focus.type === 'element' && targetSelection.anchor.key === targetSelection.focus.key && targetSelection.anchor.offset === targetSelection.focus.offset) {\n      return false;\n    }\n    return isSelected;\n  }\n\n  /**\n   * Returns this nodes key.\n   */\n  getKey() {\n    // Key is stable between copies\n    return this.__key;\n  }\n\n  /**\n   * Returns the zero-based index of this node within the parent.\n   */\n  getIndexWithinParent() {\n    const parent = this.getParent();\n    if (parent === null) {\n      return -1;\n    }\n    let node = parent.getFirstChild();\n    let index = 0;\n    while (node !== null) {\n      if (this.is(node)) {\n        return index;\n      }\n      index++;\n      node = node.getNextSibling();\n    }\n    return -1;\n  }\n\n  /**\n   * Returns the parent of this node, or null if none is found.\n   */\n  getParent() {\n    const parent = this.getLatest().__parent;\n    if (parent === null) {\n      return null;\n    }\n    return $getNodeByKey(parent);\n  }\n\n  /**\n   * Returns the parent of this node, or throws if none is found.\n   */\n  getParentOrThrow() {\n    const parent = this.getParent();\n    if (parent === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a parent.`);\n      }\n    }\n    return parent;\n  }\n\n  /**\n   * Returns the highest (in the EditorState tree)\n   * non-root ancestor of this node, or null if none is found. See {@link lexical!$isRootOrShadowRoot}\n   * for more information on which Elements comprise \"roots\".\n   */\n  getTopLevelElement() {\n    let node = this;\n    while (node !== null) {\n      const parent = node.getParent();\n      if ($isRootOrShadowRoot(parent)) {\n        if (!$isElementNode(node)) {\n          throw Error(`Children of root nodes must be elements`);\n        }\n        return node;\n      }\n      node = parent;\n    }\n    return null;\n  }\n\n  /**\n   * Returns the highest (in the EditorState tree)\n   * non-root ancestor of this node, or throws if none is found. See {@link lexical!$isRootOrShadowRoot}\n   * for more information on which Elements comprise \"roots\".\n   */\n  getTopLevelElementOrThrow() {\n    const parent = this.getTopLevelElement();\n    if (parent === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a top parent element.`);\n      }\n    }\n    return parent;\n  }\n\n  /**\n   * Returns a list of the every ancestor of this node,\n   * all the way up to the RootNode.\n   *\n   */\n  getParents() {\n    const parents = [];\n    let node = this.getParent();\n    while (node !== null) {\n      parents.push(node);\n      node = node.getParent();\n    }\n    return parents;\n  }\n\n  /**\n   * Returns a list of the keys of every ancestor of this node,\n   * all the way up to the RootNode.\n   *\n   */\n  getParentKeys() {\n    const parents = [];\n    let node = this.getParent();\n    while (node !== null) {\n      parents.push(node.__key);\n      node = node.getParent();\n    }\n    return parents;\n  }\n\n  /**\n   * Returns the \"previous\" siblings - that is, the node that comes\n   * before this one in the same parent.\n   *\n   */\n  getPreviousSibling() {\n    const self = this.getLatest();\n    const prevKey = self.__prev;\n    return prevKey === null ? null : $getNodeByKey(prevKey);\n  }\n\n  /**\n   * Returns the \"previous\" siblings - that is, the nodes that come between\n   * this one and the first child of it's parent, inclusive.\n   *\n   */\n  getPreviousSiblings() {\n    const siblings = [];\n    const parent = this.getParent();\n    if (parent === null) {\n      return siblings;\n    }\n    let node = parent.getFirstChild();\n    while (node !== null) {\n      if (node.is(this)) {\n        break;\n      }\n      siblings.push(node);\n      node = node.getNextSibling();\n    }\n    return siblings;\n  }\n\n  /**\n   * Returns the \"next\" siblings - that is, the node that comes\n   * after this one in the same parent\n   *\n   */\n  getNextSibling() {\n    const self = this.getLatest();\n    const nextKey = self.__next;\n    return nextKey === null ? null : $getNodeByKey(nextKey);\n  }\n\n  /**\n   * Returns all \"next\" siblings - that is, the nodes that come between this\n   * one and the last child of it's parent, inclusive.\n   *\n   */\n  getNextSiblings() {\n    const siblings = [];\n    let node = this.getNextSibling();\n    while (node !== null) {\n      siblings.push(node);\n      node = node.getNextSibling();\n    }\n    return siblings;\n  }\n\n  /**\n   * Returns the closest common ancestor of this node and the provided one or null\n   * if one cannot be found.\n   *\n   * @param node - the other node to find the common ancestor of.\n   */\n  getCommonAncestor(node) {\n    const a = this.getParents();\n    const b = node.getParents();\n    if ($isElementNode(this)) {\n      a.unshift(this);\n    }\n    if ($isElementNode(node)) {\n      b.unshift(node);\n    }\n    const aLength = a.length;\n    const bLength = b.length;\n    if (aLength === 0 || bLength === 0 || a[aLength - 1] !== b[bLength - 1]) {\n      return null;\n    }\n    const bSet = new Set(b);\n    for (let i = 0; i < aLength; i++) {\n      const ancestor = a[i];\n      if (bSet.has(ancestor)) {\n        return ancestor;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Returns true if the provided node is the exact same one as this node, from Lexical's perspective.\n   * Always use this instead of referential equality.\n   *\n   * @param object - the node to perform the equality comparison on.\n   */\n  is(object) {\n    if (object == null) {\n      return false;\n    }\n    return this.__key === object.__key;\n  }\n\n  /**\n   * Returns true if this node logical precedes the target node in the editor state.\n   *\n   * @param targetNode - the node we're testing to see if it's after this one.\n   */\n  isBefore(targetNode) {\n    if (this === targetNode) {\n      return false;\n    }\n    if (targetNode.isParentOf(this)) {\n      return true;\n    }\n    if (this.isParentOf(targetNode)) {\n      return false;\n    }\n    const commonAncestor = this.getCommonAncestor(targetNode);\n    let indexA = 0;\n    let indexB = 0;\n    let node = this;\n    while (true) {\n      const parent = node.getParentOrThrow();\n      if (parent === commonAncestor) {\n        indexA = node.getIndexWithinParent();\n        break;\n      }\n      node = parent;\n    }\n    node = targetNode;\n    while (true) {\n      const parent = node.getParentOrThrow();\n      if (parent === commonAncestor) {\n        indexB = node.getIndexWithinParent();\n        break;\n      }\n      node = parent;\n    }\n    return indexA < indexB;\n  }\n\n  /**\n   * Returns true if this node is the parent of the target node, false otherwise.\n   *\n   * @param targetNode - the would-be child node.\n   */\n  isParentOf(targetNode) {\n    const key = this.__key;\n    if (key === targetNode.__key) {\n      return false;\n    }\n    let node = targetNode;\n    while (node !== null) {\n      if (node.__key === key) {\n        return true;\n      }\n      node = node.getParent();\n    }\n    return false;\n  }\n\n  // TO-DO: this function can be simplified a lot\n  /**\n   * Returns a list of nodes that are between this node and\n   * the target node in the EditorState.\n   *\n   * @param targetNode - the node that marks the other end of the range of nodes to be returned.\n   */\n  getNodesBetween(targetNode) {\n    const isBefore = this.isBefore(targetNode);\n    const nodes = [];\n    const visited = new Set();\n    let node = this;\n    while (true) {\n      if (node === null) {\n        break;\n      }\n      const key = node.__key;\n      if (!visited.has(key)) {\n        visited.add(key);\n        nodes.push(node);\n      }\n      if (node === targetNode) {\n        break;\n      }\n      const child = $isElementNode(node) ? isBefore ? node.getFirstChild() : node.getLastChild() : null;\n      if (child !== null) {\n        node = child;\n        continue;\n      }\n      const nextSibling = isBefore ? node.getNextSibling() : node.getPreviousSibling();\n      if (nextSibling !== null) {\n        node = nextSibling;\n        continue;\n      }\n      const parent = node.getParentOrThrow();\n      if (!visited.has(parent.__key)) {\n        nodes.push(parent);\n      }\n      if (parent === targetNode) {\n        break;\n      }\n      let parentSibling = null;\n      let ancestor = parent;\n      do {\n        if (ancestor === null) {\n          {\n            throw Error(`getNodesBetween: ancestor is null`);\n          }\n        }\n        parentSibling = isBefore ? ancestor.getNextSibling() : ancestor.getPreviousSibling();\n        ancestor = ancestor.getParent();\n        if (ancestor !== null) {\n          if (parentSibling === null && !visited.has(ancestor.__key)) {\n            nodes.push(ancestor);\n          }\n        } else {\n          break;\n        }\n      } while (parentSibling === null);\n      node = parentSibling;\n    }\n    if (!isBefore) {\n      nodes.reverse();\n    }\n    return nodes;\n  }\n\n  /**\n   * Returns true if this node has been marked dirty during this update cycle.\n   *\n   */\n  isDirty() {\n    const editor = getActiveEditor();\n    const dirtyLeaves = editor._dirtyLeaves;\n    return dirtyLeaves !== null && dirtyLeaves.has(this.__key);\n  }\n\n  /**\n   * Returns the latest version of the node from the active EditorState.\n   * This is used to avoid getting values from stale node references.\n   *\n   */\n  getLatest() {\n    const latest = $getNodeByKey(this.__key);\n    if (latest === null) {\n      {\n        throw Error(`Lexical node does not exist in active editor state. Avoid using the same node references between nested closures from editorState.read/editor.update.`);\n      }\n    }\n    return latest;\n  }\n\n  /**\n   * Returns a mutable version of the node. Will throw an error if\n   * called outside of a Lexical Editor {@link LexicalEditor.update} callback.\n   *\n   */\n  getWritable() {\n    errorOnReadOnly();\n    const editorState = getActiveEditorState();\n    const editor = getActiveEditor();\n    const nodeMap = editorState._nodeMap;\n    const key = this.__key;\n    // Ensure we get the latest node from pending state\n    const latestNode = this.getLatest();\n    const parent = latestNode.__parent;\n    const cloneNotNeeded = editor._cloneNotNeeded;\n    const selection = $getSelection();\n    if (selection !== null) {\n      selection.setCachedNodes(null);\n    }\n    if (cloneNotNeeded.has(key)) {\n      // Transforms clear the dirty node set on each iteration to keep track on newly dirty nodes\n      internalMarkNodeAsDirty(latestNode);\n      return latestNode;\n    }\n    const constructor = latestNode.constructor;\n    const mutableNode = constructor.clone(latestNode);\n    mutableNode.__parent = parent;\n    mutableNode.__next = latestNode.__next;\n    mutableNode.__prev = latestNode.__prev;\n    if ($isElementNode(latestNode) && $isElementNode(mutableNode)) {\n      mutableNode.__first = latestNode.__first;\n      mutableNode.__last = latestNode.__last;\n      mutableNode.__size = latestNode.__size;\n      mutableNode.__indent = latestNode.__indent;\n      mutableNode.__format = latestNode.__format;\n      mutableNode.__dir = latestNode.__dir;\n    } else if ($isTextNode(latestNode) && $isTextNode(mutableNode)) {\n      mutableNode.__format = latestNode.__format;\n      mutableNode.__style = latestNode.__style;\n      mutableNode.__mode = latestNode.__mode;\n      mutableNode.__detail = latestNode.__detail;\n    }\n    cloneNotNeeded.add(key);\n    mutableNode.__key = key;\n    internalMarkNodeAsDirty(mutableNode);\n    // Update reference in node map\n    nodeMap.set(key, mutableNode);\n\n    // @ts-expect-error\n    return mutableNode;\n  }\n\n  /**\n   * Returns the text content of the node. Override this for\n   * custom nodes that should have a representation in plain text\n   * format (for copy + paste, for example)\n   *\n   */\n  getTextContent() {\n    return '';\n  }\n\n  /**\n   * Returns the length of the string produced by calling getTextContent on this node.\n   *\n   */\n  getTextContentSize() {\n    return this.getTextContent().length;\n  }\n\n  // View\n\n  /**\n   * Called during the reconciliation process to determine which nodes\n   * to insert into the DOM for this Lexical Node.\n   *\n   * This method must return exactly one HTMLElement. Nested elements are not supported.\n   *\n   * Do not attempt to update the Lexical EditorState during this phase of the update lifecyle.\n   *\n   * @param _config - allows access to things like the EditorTheme (to apply classes) during reconciliation.\n   * @param _editor - allows access to the editor for context during reconciliation.\n   *\n   * */\n  createDOM(_config, _editor) {\n    {\n      throw Error(`createDOM: base method not extended`);\n    }\n  }\n\n  /**\n   * Called when a node changes and should update the DOM\n   * in whatever way is necessary to make it align with any changes that might\n   * have happened during the update.\n   *\n   * Returning \"true\" here will cause lexical to unmount and recreate the DOM node\n   * (by calling createDOM). You would need to do this if the element tag changes,\n   * for instance.\n   *\n   * */\n  updateDOM(_prevNode, _dom, _config) {\n    {\n      throw Error(`updateDOM: base method not extended`);\n    }\n  }\n\n  /**\n   * Controls how the this node is serialized to HTML. This is important for\n   * copy and paste between Lexical and non-Lexical editors, or Lexical editors with different namespaces,\n   * in which case the primary transfer format is HTML. It's also important if you're serializing\n   * to HTML for any other reason via {@link @lexical/html!$generateHtmlFromNodes}. You could\n   * also use this method to build your own HTML renderer.\n   *\n   * */\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config, editor);\n    return {\n      element\n    };\n  }\n\n  /**\n   * Controls how the this node is serialized to JSON. This is important for\n   * copy and paste between Lexical editors sharing the same namespace. It's also important\n   * if you're serializing to JSON for persistent storage somewhere.\n   * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).\n   *\n   * */\n  exportJSON() {\n    {\n      throw Error(`exportJSON: base method not extended`);\n    }\n  }\n\n  /**\n   * Controls how the this node is deserialized from JSON. This is usually boilerplate,\n   * but provides an abstraction between the node implementation and serialized interface that can\n   * be important if you ever make breaking changes to a node schema (by adding or removing properties).\n   * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).\n   *\n   * */\n  static importJSON(_serializedNode) {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .importJSON().`);\n    }\n  }\n  /**\n   * @experimental\n   *\n   * Registers the returned function as a transform on the node during\n   * Editor initialization. Most such use cases should be addressed via\n   * the {@link LexicalEditor.registerNodeTransform} API.\n   *\n   * Experimental - use at your own risk.\n   */\n  static transform() {\n    return null;\n  }\n\n  // Setters and mutators\n\n  /**\n   * Removes this LexicalNode from the EditorState. If the node isn't re-inserted\n   * somewhere, the Lexical garbage collector will eventually clean it up.\n   *\n   * @param preserveEmptyParent - If falsy, the node's parent will be removed if\n   * it's empty after the removal operation. This is the default behavior, subject to\n   * other node heuristics such as {@link ElementNode#canBeEmpty}\n   * */\n  remove(preserveEmptyParent) {\n    removeNode(this, true, preserveEmptyParent);\n  }\n\n  /**\n   * Replaces this LexicalNode with the provided node, optionally transferring the children\n   * of the replaced node to the replacing node.\n   *\n   * @param replaceWith - The node to replace this one with.\n   * @param includeChildren - Whether or not to transfer the children of this node to the replacing node.\n   * */\n  replace(replaceWith, includeChildren) {\n    errorOnReadOnly();\n    let selection = $getSelection();\n    if (selection !== null) {\n      selection = selection.clone();\n    }\n    errorOnInsertTextNodeOnRoot(this, replaceWith);\n    const self = this.getLatest();\n    const toReplaceKey = this.__key;\n    const key = replaceWith.__key;\n    const writableReplaceWith = replaceWith.getWritable();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const size = writableParent.__size;\n    removeFromParent(writableReplaceWith);\n    const prevSibling = self.getPreviousSibling();\n    const nextSibling = self.getNextSibling();\n    const prevKey = self.__prev;\n    const nextKey = self.__next;\n    const parentKey = self.__parent;\n    removeNode(self, false, true);\n    if (prevSibling === null) {\n      writableParent.__first = key;\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      writablePrevSibling.__next = key;\n    }\n    writableReplaceWith.__prev = prevKey;\n    if (nextSibling === null) {\n      writableParent.__last = key;\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      writableNextSibling.__prev = key;\n    }\n    writableReplaceWith.__next = nextKey;\n    writableReplaceWith.__parent = parentKey;\n    writableParent.__size = size;\n    if (includeChildren) {\n      if (!($isElementNode(this) && $isElementNode(writableReplaceWith))) {\n        throw Error(`includeChildren should only be true for ElementNodes`);\n      }\n      this.getChildren().forEach(child => {\n        writableReplaceWith.append(child);\n      });\n    }\n    if ($isRangeSelection(selection)) {\n      $setSelection(selection);\n      const anchor = selection.anchor;\n      const focus = selection.focus;\n      if (anchor.key === toReplaceKey) {\n        $moveSelectionPointToEnd(anchor, writableReplaceWith);\n      }\n      if (focus.key === toReplaceKey) {\n        $moveSelectionPointToEnd(focus, writableReplaceWith);\n      }\n    }\n    if ($getCompositionKey() === toReplaceKey) {\n      $setCompositionKey(key);\n    }\n    return writableReplaceWith;\n  }\n\n  /**\n   * Inserts a node after this LexicalNode (as the next sibling).\n   *\n   * @param nodeToInsert - The node to insert after this one.\n   * @param restoreSelection - Whether or not to attempt to resolve the\n   * selection to the appropriate place after the operation is complete.\n   * */\n  insertAfter(nodeToInsert, restoreSelection = true) {\n    errorOnReadOnly();\n    errorOnInsertTextNodeOnRoot(this, nodeToInsert);\n    const writableSelf = this.getWritable();\n    const writableNodeToInsert = nodeToInsert.getWritable();\n    const oldParent = writableNodeToInsert.getParent();\n    const selection = $getSelection();\n    let elementAnchorSelectionOnNode = false;\n    let elementFocusSelectionOnNode = false;\n    if (oldParent !== null) {\n      // TODO: this is O(n), can we improve?\n      const oldIndex = nodeToInsert.getIndexWithinParent();\n      removeFromParent(writableNodeToInsert);\n      if ($isRangeSelection(selection)) {\n        const oldParentKey = oldParent.__key;\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        elementAnchorSelectionOnNode = anchor.type === 'element' && anchor.key === oldParentKey && anchor.offset === oldIndex + 1;\n        elementFocusSelectionOnNode = focus.type === 'element' && focus.key === oldParentKey && focus.offset === oldIndex + 1;\n      }\n    }\n    const nextSibling = this.getNextSibling();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const insertKey = writableNodeToInsert.__key;\n    const nextKey = writableSelf.__next;\n    if (nextSibling === null) {\n      writableParent.__last = insertKey;\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      writableNextSibling.__prev = insertKey;\n    }\n    writableParent.__size++;\n    writableSelf.__next = insertKey;\n    writableNodeToInsert.__next = nextKey;\n    writableNodeToInsert.__prev = writableSelf.__key;\n    writableNodeToInsert.__parent = writableSelf.__parent;\n    if (restoreSelection && $isRangeSelection(selection)) {\n      const index = this.getIndexWithinParent();\n      $updateElementSelectionOnCreateDeleteNode(selection, writableParent, index + 1);\n      const writableParentKey = writableParent.__key;\n      if (elementAnchorSelectionOnNode) {\n        selection.anchor.set(writableParentKey, index + 2, 'element');\n      }\n      if (elementFocusSelectionOnNode) {\n        selection.focus.set(writableParentKey, index + 2, 'element');\n      }\n    }\n    return nodeToInsert;\n  }\n\n  /**\n   * Inserts a node before this LexicalNode (as the previous sibling).\n   *\n   * @param nodeToInsert - The node to insert before this one.\n   * @param restoreSelection - Whether or not to attempt to resolve the\n   * selection to the appropriate place after the operation is complete.\n   * */\n  insertBefore(nodeToInsert, restoreSelection = true) {\n    errorOnReadOnly();\n    errorOnInsertTextNodeOnRoot(this, nodeToInsert);\n    const writableSelf = this.getWritable();\n    const writableNodeToInsert = nodeToInsert.getWritable();\n    const insertKey = writableNodeToInsert.__key;\n    removeFromParent(writableNodeToInsert);\n    const prevSibling = this.getPreviousSibling();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const prevKey = writableSelf.__prev;\n    // TODO: this is O(n), can we improve?\n    const index = this.getIndexWithinParent();\n    if (prevSibling === null) {\n      writableParent.__first = insertKey;\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      writablePrevSibling.__next = insertKey;\n    }\n    writableParent.__size++;\n    writableSelf.__prev = insertKey;\n    writableNodeToInsert.__prev = prevKey;\n    writableNodeToInsert.__next = writableSelf.__key;\n    writableNodeToInsert.__parent = writableSelf.__parent;\n    const selection = $getSelection();\n    if (restoreSelection && $isRangeSelection(selection)) {\n      const parent = this.getParentOrThrow();\n      $updateElementSelectionOnCreateDeleteNode(selection, parent, index);\n    }\n    return nodeToInsert;\n  }\n\n  /**\n   * Whether or not this node has a required parent. Used during copy + paste operations\n   * to normalize nodes that would otherwise be orphaned. For example, ListItemNodes without\n   * a ListNode parent or TextNodes with a ParagraphNode parent.\n   *\n   * */\n  isParentRequired() {\n    return false;\n  }\n\n  /**\n   * The creation logic for any required parent. Should be implemented if {@link isParentRequired} returns true.\n   *\n   * */\n  createParentElementNode() {\n    return $createParagraphNode();\n  }\n  selectStart() {\n    return this.selectPrevious();\n  }\n  selectEnd() {\n    return this.selectNext(0, 0);\n  }\n\n  /**\n   * Moves selection to the previous sibling of this node, at the specified offsets.\n   *\n   * @param anchorOffset - The anchor offset for selection.\n   * @param focusOffset -  The focus offset for selection\n   * */\n  selectPrevious(anchorOffset, focusOffset) {\n    errorOnReadOnly();\n    const prevSibling = this.getPreviousSibling();\n    const parent = this.getParentOrThrow();\n    if (prevSibling === null) {\n      return parent.select(0, 0);\n    }\n    if ($isElementNode(prevSibling)) {\n      return prevSibling.select();\n    } else if (!$isTextNode(prevSibling)) {\n      const index = prevSibling.getIndexWithinParent() + 1;\n      return parent.select(index, index);\n    }\n    return prevSibling.select(anchorOffset, focusOffset);\n  }\n\n  /**\n   * Moves selection to the next sibling of this node, at the specified offsets.\n   *\n   * @param anchorOffset - The anchor offset for selection.\n   * @param focusOffset -  The focus offset for selection\n   * */\n  selectNext(anchorOffset, focusOffset) {\n    errorOnReadOnly();\n    const nextSibling = this.getNextSibling();\n    const parent = this.getParentOrThrow();\n    if (nextSibling === null) {\n      return parent.select();\n    }\n    if ($isElementNode(nextSibling)) {\n      return nextSibling.select(0, 0);\n    } else if (!$isTextNode(nextSibling)) {\n      const index = nextSibling.getIndexWithinParent();\n      return parent.select(index, index);\n    }\n    return nextSibling.select(anchorOffset, focusOffset);\n  }\n\n  /**\n   * Marks a node dirty, triggering transforms and\n   * forcing it to be reconciled during the update cycle.\n   *\n   * */\n  markDirty() {\n    this.getWritable();\n  }\n}\nfunction errorOnTypeKlassMismatch(type, klass) {\n  const registeredNode = getActiveEditor()._nodes.get(type);\n  // Common error - split in its own invariant\n  if (registeredNode === undefined) {\n    {\n      throw Error(`Create node: Attempted to create node ${klass.name} that was not configured to be used on the editor.`);\n    }\n  }\n  const editorKlass = registeredNode.klass;\n  if (editorKlass !== klass) {\n    {\n      throw Error(`Create node: Type ${type} in node ${klass.name} does not match registered node ${editorKlass.name} with the same type`);\n    }\n  }\n}\n\n/**\n * Insert a series of nodes after this LexicalNode (as next siblings)\n *\n * @param firstToInsert - The first node to insert after this one.\n * @param lastToInsert - The last node to insert after this one. Must be a\n * later sibling of FirstNode. If not provided, it will be its last sibling.\n */\nfunction insertRangeAfter(node, firstToInsert, lastToInsert) {\n  const lastToInsert2 = lastToInsert || firstToInsert.getParentOrThrow().getLastChild();\n  let current = firstToInsert;\n  const nodesToInsert = [firstToInsert];\n  while (current !== lastToInsert2) {\n    if (!current.getNextSibling()) {\n      {\n        throw Error(`insertRangeAfter: lastToInsert must be a later sibling of firstToInsert`);\n      }\n    }\n    current = current.getNextSibling();\n    nodesToInsert.push(current);\n  }\n  let currentNode = node;\n  for (const nodeToInsert of nodesToInsert) {\n    currentNode = currentNode.insertAfter(nodeToInsert);\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/** @noInheritDoc */\nclass LineBreakNode extends LexicalNode {\n  static getType() {\n    return 'linebreak';\n  }\n  static clone(node) {\n    return new LineBreakNode(node.__key);\n  }\n  constructor(key) {\n    super(key);\n  }\n  getTextContent() {\n    return '\\n';\n  }\n  createDOM() {\n    return document.createElement('br');\n  }\n  updateDOM() {\n    return false;\n  }\n  static importDOM() {\n    return {\n      br: node => {\n        if (isOnlyChild(node)) {\n          return null;\n        }\n        return {\n          conversion: convertLineBreakElement,\n          priority: 0\n        };\n      }\n    };\n  }\n  static importJSON(serializedLineBreakNode) {\n    return $createLineBreakNode();\n  }\n  exportJSON() {\n    return {\n      type: 'linebreak',\n      version: 1\n    };\n  }\n}\nfunction convertLineBreakElement(node) {\n  return {\n    node: $createLineBreakNode()\n  };\n}\nfunction $createLineBreakNode() {\n  return $applyNodeReplacement(new LineBreakNode());\n}\nfunction $isLineBreakNode(node) {\n  return node instanceof LineBreakNode;\n}\nfunction isOnlyChild(node) {\n  const parentElement = node.parentElement;\n  if (parentElement !== null) {\n    const firstChild = parentElement.firstChild;\n    if (firstChild === node || firstChild.nextSibling === node && isWhitespaceDomTextNode(firstChild)) {\n      const lastChild = parentElement.lastChild;\n      if (lastChild === node || lastChild.previousSibling === node && isWhitespaceDomTextNode(lastChild)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction isWhitespaceDomTextNode(node) {\n  return node.nodeType === DOM_TEXT_TYPE && /^( |\\t|\\r?\\n)+$/.test(node.textContent || '');\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction getElementOuterTag(node, format) {\n  if (format & IS_CODE) {\n    return 'code';\n  }\n  if (format & IS_HIGHLIGHT) {\n    return 'mark';\n  }\n  if (format & IS_SUBSCRIPT) {\n    return 'sub';\n  }\n  if (format & IS_SUPERSCRIPT) {\n    return 'sup';\n  }\n  return null;\n}\nfunction getElementInnerTag(node, format) {\n  if (format & IS_BOLD) {\n    return 'strong';\n  }\n  if (format & IS_ITALIC) {\n    return 'em';\n  }\n  return 'span';\n}\nfunction setTextThemeClassNames(tag, prevFormat, nextFormat, dom, textClassNames) {\n  const domClassList = dom.classList;\n  // Firstly we handle the base theme.\n  let classNames = getCachedClassNameArray(textClassNames, 'base');\n  if (classNames !== undefined) {\n    domClassList.add(...classNames);\n  }\n  // Secondly we handle the special case: underline + strikethrough.\n  // We have to do this as we need a way to compose the fact that\n  // the same CSS property will need to be used: text-decoration.\n  // In an ideal world we shouldn't have to do this, but there's no\n  // easy workaround for many atomic CSS systems today.\n  classNames = getCachedClassNameArray(textClassNames, 'underlineStrikethrough');\n  let hasUnderlineStrikethrough = false;\n  const prevUnderlineStrikethrough = prevFormat & IS_UNDERLINE && prevFormat & IS_STRIKETHROUGH;\n  const nextUnderlineStrikethrough = nextFormat & IS_UNDERLINE && nextFormat & IS_STRIKETHROUGH;\n  if (classNames !== undefined) {\n    if (nextUnderlineStrikethrough) {\n      hasUnderlineStrikethrough = true;\n      if (!prevUnderlineStrikethrough) {\n        domClassList.add(...classNames);\n      }\n    } else if (prevUnderlineStrikethrough) {\n      domClassList.remove(...classNames);\n    }\n  }\n  for (const key in TEXT_TYPE_TO_FORMAT) {\n    const format = key;\n    const flag = TEXT_TYPE_TO_FORMAT[format];\n    classNames = getCachedClassNameArray(textClassNames, key);\n    if (classNames !== undefined) {\n      if (nextFormat & flag) {\n        if (hasUnderlineStrikethrough && (key === 'underline' || key === 'strikethrough')) {\n          if (prevFormat & flag) {\n            domClassList.remove(...classNames);\n          }\n          continue;\n        }\n        if ((prevFormat & flag) === 0 || prevUnderlineStrikethrough && key === 'underline' || key === 'strikethrough') {\n          domClassList.add(...classNames);\n        }\n      } else if (prevFormat & flag) {\n        domClassList.remove(...classNames);\n      }\n    }\n  }\n}\nfunction diffComposedText(a, b) {\n  const aLength = a.length;\n  const bLength = b.length;\n  let left = 0;\n  let right = 0;\n  while (left < aLength && left < bLength && a[left] === b[left]) {\n    left++;\n  }\n  while (right + left < aLength && right + left < bLength && a[aLength - right - 1] === b[bLength - right - 1]) {\n    right++;\n  }\n  return [left, aLength - left - right, b.slice(left, bLength - right)];\n}\nfunction setTextContent(nextText, dom, node) {\n  const firstChild = dom.firstChild;\n  const isComposing = node.isComposing();\n  // Always add a suffix if we're composing a node\n  const suffix = isComposing ? COMPOSITION_SUFFIX : '';\n  const text = nextText + suffix;\n  if (firstChild == null) {\n    dom.textContent = text;\n  } else {\n    const nodeValue = firstChild.nodeValue;\n    if (nodeValue !== text) {\n      if (isComposing || IS_FIREFOX) {\n        // We also use the diff composed text for general text in FF to avoid\n        // the spellcheck red line from flickering.\n        const [index, remove, insert] = diffComposedText(nodeValue, text);\n        if (remove !== 0) {\n          // @ts-expect-error\n          firstChild.deleteData(index, remove);\n        }\n        // @ts-expect-error\n        firstChild.insertData(index, insert);\n      } else {\n        firstChild.nodeValue = text;\n      }\n    }\n  }\n}\nfunction createTextInnerDOM(innerDOM, node, innerTag, format, text, config) {\n  setTextContent(text, innerDOM, node);\n  const theme = config.theme;\n  // Apply theme class names\n  const textClassNames = theme.text;\n  if (textClassNames !== undefined) {\n    setTextThemeClassNames(innerTag, 0, format, innerDOM, textClassNames);\n  }\n}\nfunction wrapElementWith(element, tag) {\n  const el = document.createElement(tag);\n  el.appendChild(element);\n  return el;\n}\n\n/** @noInheritDoc */\nclass TextNode extends LexicalNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'text';\n  }\n  static clone(node) {\n    return new TextNode(node.__text, node.__key);\n  }\n  constructor(text, key) {\n    super(key);\n    this.__text = text;\n    this.__format = 0;\n    this.__style = '';\n    this.__mode = 0;\n    this.__detail = 0;\n  }\n\n  /**\n   * Returns a 32-bit integer that represents the TextFormatTypes currently applied to the\n   * TextNode. You probably don't want to use this method directly - consider using TextNode.hasFormat instead.\n   *\n   * @returns a number representing the format of the text node.\n   */\n  getFormat() {\n    const self = this.getLatest();\n    return self.__format;\n  }\n\n  /**\n   * Returns a 32-bit integer that represents the TextDetailTypes currently applied to the\n   * TextNode. You probably don't want to use this method directly - consider using TextNode.isDirectionless\n   * or TextNode.isUnmergeable instead.\n   *\n   * @returns a number representing the detail of the text node.\n   */\n  getDetail() {\n    const self = this.getLatest();\n    return self.__detail;\n  }\n\n  /**\n   * Returns the mode (TextModeType) of the TextNode, which may be \"normal\", \"token\", or \"segmented\"\n   *\n   * @returns TextModeType.\n   */\n  getMode() {\n    const self = this.getLatest();\n    return TEXT_TYPE_TO_MODE[self.__mode];\n  }\n\n  /**\n   * Returns the styles currently applied to the node. This is analogous to CSSText in the DOM.\n   *\n   * @returns CSSText-like string of styles applied to the underlying DOM node.\n   */\n  getStyle() {\n    const self = this.getLatest();\n    return self.__style;\n  }\n\n  /**\n   * Returns whether or not the node is in \"token\" mode. TextNodes in token mode can be navigated through character-by-character\n   * with a RangeSelection, but are deleted as a single entity (not invdividually by character).\n   *\n   * @returns true if the node is in token mode, false otherwise.\n   */\n  isToken() {\n    const self = this.getLatest();\n    return self.__mode === IS_TOKEN;\n  }\n\n  /**\n   *\n   * @returns true if Lexical detects that an IME or other 3rd-party script is attempting to\n   * mutate the TextNode, false otherwise.\n   */\n  isComposing() {\n    return this.__key === $getCompositionKey();\n  }\n\n  /**\n   * Returns whether or not the node is in \"segemented\" mode. TextNodes in segemented mode can be navigated through character-by-character\n   * with a RangeSelection, but are deleted in space-delimited \"segments\".\n   *\n   * @returns true if the node is in segmented mode, false otherwise.\n   */\n  isSegmented() {\n    const self = this.getLatest();\n    return self.__mode === IS_SEGMENTED;\n  }\n  /**\n   * Returns whether or not the node is \"directionless\". Directionless nodes don't respect changes between RTL and LTR modes.\n   *\n   * @returns true if the node is directionless, false otherwise.\n   */\n  isDirectionless() {\n    const self = this.getLatest();\n    return (self.__detail & IS_DIRECTIONLESS) !== 0;\n  }\n  /**\n   * Returns whether or not the node is unmergeable. In some scenarios, Lexical tries to merge\n   * adjacent TextNodes into a single TextNode. If a TextNode is unmergeable, this won't happen.\n   *\n   * @returns true if the node is unmergeable, false otherwise.\n   */\n  isUnmergeable() {\n    const self = this.getLatest();\n    return (self.__detail & IS_UNMERGEABLE) !== 0;\n  }\n\n  /**\n   * Returns whether or not the node has the provided format applied. Use this with the human-readable TextFormatType\n   * string values to get the format of a TextNode.\n   *\n   * @param type - the TextFormatType to check for.\n   *\n   * @returns true if the node has the provided format, false otherwise.\n   */\n  hasFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.getFormat() & formatFlag) !== 0;\n  }\n\n  /**\n   * Returns whether or not the node is simple text. Simple text is defined as a TextNode that has the string type \"text\"\n   * (i.e., not a subclass) and has no mode applied to it (i.e., not segmented or token).\n   *\n   * @returns true if the node is simple text, false otherwise.\n   */\n  isSimpleText() {\n    return this.__type === 'text' && this.__mode === 0;\n  }\n\n  /**\n   * Returns the text content of the node as a string.\n   *\n   * @returns a string representing the text content of the node.\n   */\n  getTextContent() {\n    const self = this.getLatest();\n    return self.__text;\n  }\n\n  /**\n   * Returns the format flags applied to the node as a 32-bit integer.\n   *\n   * @returns a number representing the TextFormatTypes applied to the node.\n   */\n  getFormatFlags(type, alignWithFormat) {\n    const self = this.getLatest();\n    const format = self.__format;\n    return toggleTextFormatType(format, type, alignWithFormat);\n  }\n\n  /**\n   *\n   * @returns true if the text node supports font styling, false otherwise.\n   */\n  canHaveFormat() {\n    return true;\n  }\n\n  // View\n\n  createDOM(config, editor) {\n    const format = this.__format;\n    const outerTag = getElementOuterTag(this, format);\n    const innerTag = getElementInnerTag(this, format);\n    const tag = outerTag === null ? innerTag : outerTag;\n    const dom = document.createElement(tag);\n    let innerDOM = dom;\n    if (this.hasFormat('code')) {\n      dom.setAttribute('spellcheck', 'false');\n    }\n    if (outerTag !== null) {\n      innerDOM = document.createElement(innerTag);\n      dom.appendChild(innerDOM);\n    }\n    const text = this.__text;\n    createTextInnerDOM(innerDOM, this, innerTag, format, text, config);\n    const style = this.__style;\n    if (style !== '') {\n      dom.style.cssText = style;\n    }\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    const nextText = this.__text;\n    const prevFormat = prevNode.__format;\n    const nextFormat = this.__format;\n    const prevOuterTag = getElementOuterTag(this, prevFormat);\n    const nextOuterTag = getElementOuterTag(this, nextFormat);\n    const prevInnerTag = getElementInnerTag(this, prevFormat);\n    const nextInnerTag = getElementInnerTag(this, nextFormat);\n    const prevTag = prevOuterTag === null ? prevInnerTag : prevOuterTag;\n    const nextTag = nextOuterTag === null ? nextInnerTag : nextOuterTag;\n    if (prevTag !== nextTag) {\n      return true;\n    }\n    if (prevOuterTag === nextOuterTag && prevInnerTag !== nextInnerTag) {\n      // should always be an element\n      const prevInnerDOM = dom.firstChild;\n      if (prevInnerDOM == null) {\n        {\n          throw Error(`updateDOM: prevInnerDOM is null or undefined`);\n        }\n      }\n      const nextInnerDOM = document.createElement(nextInnerTag);\n      createTextInnerDOM(nextInnerDOM, this, nextInnerTag, nextFormat, nextText, config);\n      dom.replaceChild(nextInnerDOM, prevInnerDOM);\n      return false;\n    }\n    let innerDOM = dom;\n    if (nextOuterTag !== null) {\n      if (prevOuterTag !== null) {\n        innerDOM = dom.firstChild;\n        if (innerDOM == null) {\n          {\n            throw Error(`updateDOM: innerDOM is null or undefined`);\n          }\n        }\n      }\n    }\n    setTextContent(nextText, innerDOM, this);\n    const theme = config.theme;\n    // Apply theme class names\n    const textClassNames = theme.text;\n    if (textClassNames !== undefined && prevFormat !== nextFormat) {\n      setTextThemeClassNames(nextInnerTag, prevFormat, nextFormat, innerDOM, textClassNames);\n    }\n    const prevStyle = prevNode.__style;\n    const nextStyle = this.__style;\n    if (prevStyle !== nextStyle) {\n      dom.style.cssText = nextStyle;\n    }\n    return false;\n  }\n  static importDOM() {\n    return {\n      '#text': () => ({\n        conversion: convertTextDOMNode,\n        priority: 0\n      }),\n      b: () => ({\n        conversion: convertBringAttentionToElement,\n        priority: 0\n      }),\n      code: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      em: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      i: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      s: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      span: () => ({\n        conversion: convertSpanElement,\n        priority: 0\n      }),\n      strong: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      sub: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      sup: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      u: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createTextNode(serializedNode.text);\n    node.setFormat(serializedNode.format);\n    node.setDetail(serializedNode.detail);\n    node.setMode(serializedNode.mode);\n    node.setStyle(serializedNode.style);\n    return node;\n  }\n\n  // This improves Lexical's basic text output in copy+paste plus\n  // for headless mode where people might use Lexical to generate\n  // HTML content and not have the ability to use CSS classes.\n  exportDOM(editor) {\n    let {\n      element\n    } = super.exportDOM(editor);\n    if (!(element !== null && isHTMLElement(element))) {\n      throw Error(`Expected TextNode createDOM to always return a HTMLElement`);\n    }\n    element.style.whiteSpace = 'pre-wrap';\n    // This is the only way to properly add support for most clients,\n    // even if it's semantically incorrect to have to resort to using\n    // <b>, <u>, <s>, <i> elements.\n    if (this.hasFormat('bold')) {\n      element = wrapElementWith(element, 'b');\n    }\n    if (this.hasFormat('italic')) {\n      element = wrapElementWith(element, 'i');\n    }\n    if (this.hasFormat('strikethrough')) {\n      element = wrapElementWith(element, 's');\n    }\n    if (this.hasFormat('underline')) {\n      element = wrapElementWith(element, 'u');\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      detail: this.getDetail(),\n      format: this.getFormat(),\n      mode: this.getMode(),\n      style: this.getStyle(),\n      text: this.getTextContent(),\n      type: 'text',\n      version: 1\n    };\n  }\n\n  // Mutators\n  selectionTransform(prevSelection, nextSelection) {\n    return;\n  }\n\n  /**\n   * Sets the node format to the provided TextFormatType or 32-bit integer. Note that the TextFormatType\n   * version of the argument can only specify one format and doing so will remove all other formats that\n   * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleFormat}\n   *\n   * @param format - TextFormatType or 32-bit integer representing the node format.\n   *\n   * @returns this TextNode.\n   * // TODO 0.12 This should just be a `string`.\n   */\n  setFormat(format) {\n    const self = this.getWritable();\n    self.__format = typeof format === 'string' ? TEXT_TYPE_TO_FORMAT[format] : format;\n    return self;\n  }\n\n  /**\n   * Sets the node detail to the provided TextDetailType or 32-bit integer. Note that the TextDetailType\n   * version of the argument can only specify one detail value and doing so will remove all other detail values that\n   * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleDirectionless}\n   * or {@link TextNode.togglerUnmergeable}\n   *\n   * @param detail - TextDetailType or 32-bit integer representing the node detail.\n   *\n   * @returns this TextNode.\n   * // TODO 0.12 This should just be a `string`.\n   */\n  setDetail(detail) {\n    const self = this.getWritable();\n    self.__detail = typeof detail === 'string' ? DETAIL_TYPE_TO_DETAIL[detail] : detail;\n    return self;\n  }\n\n  /**\n   * Sets the node style to the provided CSSText-like string. Set this property as you\n   * would an HTMLElement style attribute to apply inline styles to the underlying DOM Element.\n   *\n   * @param style - CSSText to be applied to the underlying HTMLElement.\n   *\n   * @returns this TextNode.\n   */\n  setStyle(style) {\n    const self = this.getWritable();\n    self.__style = style;\n    return self;\n  }\n\n  /**\n   * Applies the provided format to this TextNode if it's not present. Removes it if it's present.\n   * The subscript and superscript formats are mutually exclusive.\n   * Prefer using this method to turn specific formats on and off.\n   *\n   * @param type - TextFormatType to toggle.\n   *\n   * @returns this TextNode.\n   */\n  toggleFormat(type) {\n    const format = this.getFormat();\n    const newFormat = toggleTextFormatType(format, type, null);\n    return this.setFormat(newFormat);\n  }\n\n  /**\n   * Toggles the directionless detail value of the node. Prefer using this method over setDetail.\n   *\n   * @returns this TextNode.\n   */\n  toggleDirectionless() {\n    const self = this.getWritable();\n    self.__detail ^= IS_DIRECTIONLESS;\n    return self;\n  }\n\n  /**\n   * Toggles the unmergeable detail value of the node. Prefer using this method over setDetail.\n   *\n   * @returns this TextNode.\n   */\n  toggleUnmergeable() {\n    const self = this.getWritable();\n    self.__detail ^= IS_UNMERGEABLE;\n    return self;\n  }\n\n  /**\n   * Sets the mode of the node.\n   *\n   * @returns this TextNode.\n   */\n  setMode(type) {\n    const mode = TEXT_MODE_TO_TYPE[type];\n    if (this.__mode === mode) {\n      return this;\n    }\n    const self = this.getWritable();\n    self.__mode = mode;\n    return self;\n  }\n\n  /**\n   * Sets the text content of the node.\n   *\n   * @param text - the string to set as the text value of the node.\n   *\n   * @returns this TextNode.\n   */\n  setTextContent(text) {\n    if (this.__text === text) {\n      return this;\n    }\n    const self = this.getWritable();\n    self.__text = text;\n    return self;\n  }\n\n  /**\n   * Sets the current Lexical selection to be a RangeSelection with anchor and focus on this TextNode at the provided offsets.\n   *\n   * @param _anchorOffset - the offset at which the Selection anchor will be placed.\n   * @param _focusOffset - the offset at which the Selection focus will be placed.\n   *\n   * @returns the new RangeSelection.\n   */\n  select(_anchorOffset, _focusOffset) {\n    errorOnReadOnly();\n    let anchorOffset = _anchorOffset;\n    let focusOffset = _focusOffset;\n    const selection = $getSelection();\n    const text = this.getTextContent();\n    const key = this.__key;\n    if (typeof text === 'string') {\n      const lastOffset = text.length;\n      if (anchorOffset === undefined) {\n        anchorOffset = lastOffset;\n      }\n      if (focusOffset === undefined) {\n        focusOffset = lastOffset;\n      }\n    } else {\n      anchorOffset = 0;\n      focusOffset = 0;\n    }\n    if (!$isRangeSelection(selection)) {\n      return internalMakeRangeSelection(key, anchorOffset, key, focusOffset, 'text', 'text');\n    } else {\n      const compositionKey = $getCompositionKey();\n      if (compositionKey === selection.anchor.key || compositionKey === selection.focus.key) {\n        $setCompositionKey(key);\n      }\n      selection.setTextNodeRange(this, anchorOffset, this, focusOffset);\n    }\n    return selection;\n  }\n  selectStart() {\n    return this.select(0, 0);\n  }\n  selectEnd() {\n    const size = this.getTextContentSize();\n    return this.select(size, size);\n  }\n\n  /**\n   * Inserts the provided text into this TextNode at the provided offset, deleting the number of characters\n   * specified. Can optionally calculate a new selection after the operation is complete.\n   *\n   * @param offset - the offset at which the splice operation should begin.\n   * @param delCount - the number of characters to delete, starting from the offset.\n   * @param newText - the text to insert into the TextNode at the offset.\n   * @param moveSelection - optional, whether or not to move selection to the end of the inserted substring.\n   *\n   * @returns this TextNode.\n   */\n  spliceText(offset, delCount, newText, moveSelection) {\n    const writableSelf = this.getWritable();\n    const text = writableSelf.__text;\n    const handledTextLength = newText.length;\n    let index = offset;\n    if (index < 0) {\n      index = handledTextLength + index;\n      if (index < 0) {\n        index = 0;\n      }\n    }\n    const selection = $getSelection();\n    if (moveSelection && $isRangeSelection(selection)) {\n      const newOffset = offset + handledTextLength;\n      selection.setTextNodeRange(writableSelf, newOffset, writableSelf, newOffset);\n    }\n    const updatedText = text.slice(0, index) + newText + text.slice(index + delCount);\n    writableSelf.__text = updatedText;\n    return writableSelf;\n  }\n\n  /**\n   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes\n   * when a user event would cause text to be inserted before them in the editor. If true, Lexical will attempt\n   * to insert text into this node. If false, it will insert the text in a new sibling node.\n   *\n   * @returns true if text can be inserted before the node, false otherwise.\n   */\n  canInsertTextBefore() {\n    return true;\n  }\n\n  /**\n   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes\n   * when a user event would cause text to be inserted after them in the editor. If true, Lexical will attempt\n   * to insert text into this node. If false, it will insert the text in a new sibling node.\n   *\n   * @returns true if text can be inserted after the node, false otherwise.\n   */\n  canInsertTextAfter() {\n    return true;\n  }\n\n  /**\n   * Splits this TextNode at the provided character offsets, forming new TextNodes from the substrings\n   * formed by the split, and inserting those new TextNodes into the editor, replacing the one that was split.\n   *\n   * @param splitOffsets - rest param of the text content character offsets at which this node should be split.\n   *\n   * @returns an Array containing the newly-created TextNodes.\n   */\n  splitText(...splitOffsets) {\n    errorOnReadOnly();\n    const self = this.getLatest();\n    const textContent = self.getTextContent();\n    const key = self.__key;\n    const compositionKey = $getCompositionKey();\n    const offsetsSet = new Set(splitOffsets);\n    const parts = [];\n    const textLength = textContent.length;\n    let string = '';\n    for (let i = 0; i < textLength; i++) {\n      if (string !== '' && offsetsSet.has(i)) {\n        parts.push(string);\n        string = '';\n      }\n      string += textContent[i];\n    }\n    if (string !== '') {\n      parts.push(string);\n    }\n    const partsLength = parts.length;\n    if (partsLength === 0) {\n      return [];\n    } else if (parts[0] === textContent) {\n      return [self];\n    }\n    const firstPart = parts[0];\n    const parent = self.getParentOrThrow();\n    let writableNode;\n    const format = self.getFormat();\n    const style = self.getStyle();\n    const detail = self.__detail;\n    let hasReplacedSelf = false;\n    if (self.isSegmented()) {\n      // Create a new TextNode\n      writableNode = $createTextNode(firstPart);\n      writableNode.__format = format;\n      writableNode.__style = style;\n      writableNode.__detail = detail;\n      hasReplacedSelf = true;\n    } else {\n      // For the first part, update the existing node\n      writableNode = self.getWritable();\n      writableNode.__text = firstPart;\n    }\n\n    // Handle selection\n    const selection = $getSelection();\n\n    // Then handle all other parts\n    const splitNodes = [writableNode];\n    let textSize = firstPart.length;\n    for (let i = 1; i < partsLength; i++) {\n      const part = parts[i];\n      const partSize = part.length;\n      const sibling = $createTextNode(part).getWritable();\n      sibling.__format = format;\n      sibling.__style = style;\n      sibling.__detail = detail;\n      const siblingKey = sibling.__key;\n      const nextTextSize = textSize + partSize;\n      if ($isRangeSelection(selection)) {\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        if (anchor.key === key && anchor.type === 'text' && anchor.offset > textSize && anchor.offset <= nextTextSize) {\n          anchor.key = siblingKey;\n          anchor.offset -= textSize;\n          selection.dirty = true;\n        }\n        if (focus.key === key && focus.type === 'text' && focus.offset > textSize && focus.offset <= nextTextSize) {\n          focus.key = siblingKey;\n          focus.offset -= textSize;\n          selection.dirty = true;\n        }\n      }\n      if (compositionKey === key) {\n        $setCompositionKey(siblingKey);\n      }\n      textSize = nextTextSize;\n      splitNodes.push(sibling);\n    }\n\n    // Insert the nodes into the parent's children\n    internalMarkSiblingsAsDirty(this);\n    const writableParent = parent.getWritable();\n    const insertionIndex = this.getIndexWithinParent();\n    if (hasReplacedSelf) {\n      writableParent.splice(insertionIndex, 0, splitNodes);\n      this.remove();\n    } else {\n      writableParent.splice(insertionIndex, 1, splitNodes);\n    }\n    if ($isRangeSelection(selection)) {\n      $updateElementSelectionOnCreateDeleteNode(selection, parent, insertionIndex, partsLength - 1);\n    }\n    return splitNodes;\n  }\n\n  /**\n   * Merges the target TextNode into this TextNode, removing the target node.\n   *\n   * @param target - the TextNode to merge into this one.\n   *\n   * @returns this TextNode.\n   */\n  mergeWithSibling(target) {\n    const isBefore = target === this.getPreviousSibling();\n    if (!isBefore && target !== this.getNextSibling()) {\n      {\n        throw Error(`mergeWithSibling: sibling must be a previous or next sibling`);\n      }\n    }\n    const key = this.__key;\n    const targetKey = target.__key;\n    const text = this.__text;\n    const textLength = text.length;\n    const compositionKey = $getCompositionKey();\n    if (compositionKey === targetKey) {\n      $setCompositionKey(key);\n    }\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor;\n      const focus = selection.focus;\n      if (anchor !== null && anchor.key === targetKey) {\n        adjustPointOffsetForMergedSibling(anchor, isBefore, key, target, textLength);\n        selection.dirty = true;\n      }\n      if (focus !== null && focus.key === targetKey) {\n        adjustPointOffsetForMergedSibling(focus, isBefore, key, target, textLength);\n        selection.dirty = true;\n      }\n    }\n    const targetText = target.__text;\n    const newText = isBefore ? targetText + text : text + targetText;\n    this.setTextContent(newText);\n    const writableSelf = this.getWritable();\n    target.remove();\n    return writableSelf;\n  }\n\n  /**\n   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes\n   * when used with the registerLexicalTextEntity function. If you're using registerLexicalTextEntity, the\n   * node class that you create and replace matched text with should return true from this method.\n   *\n   * @returns true if the node is to be treated as a \"text entity\", false otherwise.\n   */\n  isTextEntity() {\n    return false;\n  }\n}\nfunction convertSpanElement(domNode) {\n  // domNode is a <span> since we matched it by nodeName\n  const span = domNode;\n  // Google Docs uses span tags + font-weight for bold text\n  const hasBoldFontWeight = span.style.fontWeight === '700';\n  // Google Docs uses span tags + text-decoration: line-through for strikethrough text\n  const hasLinethroughTextDecoration = span.style.textDecoration === 'line-through';\n  // Google Docs uses span tags + font-style for italic text\n  const hasItalicFontStyle = span.style.fontStyle === 'italic';\n  // Google Docs uses span tags + text-decoration: underline for underline text\n  const hasUnderlineTextDecoration = span.style.textDecoration === 'underline';\n  // Google Docs uses span tags + vertical-align to specify subscript and superscript\n  const verticalAlign = span.style.verticalAlign;\n  return {\n    forChild: lexicalNode => {\n      if (!$isTextNode(lexicalNode)) {\n        return lexicalNode;\n      }\n      if (hasBoldFontWeight) {\n        lexicalNode.toggleFormat('bold');\n      }\n      if (hasLinethroughTextDecoration) {\n        lexicalNode.toggleFormat('strikethrough');\n      }\n      if (hasItalicFontStyle) {\n        lexicalNode.toggleFormat('italic');\n      }\n      if (hasUnderlineTextDecoration) {\n        lexicalNode.toggleFormat('underline');\n      }\n      if (verticalAlign === 'sub') {\n        lexicalNode.toggleFormat('subscript');\n      }\n      if (verticalAlign === 'super') {\n        lexicalNode.toggleFormat('superscript');\n      }\n      return lexicalNode;\n    },\n    node: null\n  };\n}\nfunction convertBringAttentionToElement(domNode) {\n  // domNode is a <b> since we matched it by nodeName\n  const b = domNode;\n  // Google Docs wraps all copied HTML in a <b> with font-weight normal\n  const hasNormalFontWeight = b.style.fontWeight === 'normal';\n  return {\n    forChild: lexicalNode => {\n      if ($isTextNode(lexicalNode) && !hasNormalFontWeight) {\n        lexicalNode.toggleFormat('bold');\n      }\n      return lexicalNode;\n    },\n    node: null\n  };\n}\nconst preParentCache = new WeakMap();\nfunction isNodePre(node) {\n  return node.nodeName === 'PRE' || node.nodeType === DOM_ELEMENT_TYPE && node.style !== undefined && node.style.whiteSpace !== undefined && node.style.whiteSpace.startsWith('pre');\n}\nfunction findParentPreDOMNode(node) {\n  let cached;\n  let parent = node.parentNode;\n  const visited = [node];\n  while (parent !== null && (cached = preParentCache.get(parent)) === undefined && !isNodePre(parent)) {\n    visited.push(parent);\n    parent = parent.parentNode;\n  }\n  const resultNode = cached === undefined ? parent : cached;\n  for (let i = 0; i < visited.length; i++) {\n    preParentCache.set(visited[i], resultNode);\n  }\n  return resultNode;\n}\nfunction convertTextDOMNode(domNode) {\n  const domNode_ = domNode;\n  const parentDom = domNode.parentElement;\n  if (!(parentDom !== null)) {\n    throw Error(`Expected parentElement of Text not to be null`);\n  }\n  let textContent = domNode_.textContent || '';\n  // No collapse and preserve segment break for pre, pre-wrap and pre-line\n  if (findParentPreDOMNode(domNode_) !== null) {\n    const parts = textContent.split(/(\\r?\\n|\\t)/);\n    const nodes = [];\n    const length = parts.length;\n    for (let i = 0; i < length; i++) {\n      const part = parts[i];\n      if (part === '\\n' || part === '\\r\\n') {\n        nodes.push($createLineBreakNode());\n      } else if (part === '\\t') {\n        nodes.push($createTabNode());\n      } else if (part !== '') {\n        nodes.push($createTextNode(part));\n      }\n    }\n    return {\n      node: nodes\n    };\n  }\n  textContent = textContent.replace(/\\r/g, '').replace(/[ \\t\\n]+/g, ' ');\n  if (textContent === '') {\n    return {\n      node: null\n    };\n  }\n  if (textContent[0] === ' ') {\n    // Traverse backward while in the same line. If content contains new line or tab -> pontential\n    // delete, other elements can borrow from this one. Deletion depends on whether it's also the\n    // last space (see next condition: textContent[textContent.length - 1] === ' '))\n    let previousText = domNode_;\n    let isStartOfLine = true;\n    while (previousText !== null && (previousText = findTextInLine(previousText, false)) !== null) {\n      const previousTextContent = previousText.textContent || '';\n      if (previousTextContent.length > 0) {\n        if (/[ \\t\\n]$/.test(previousTextContent)) {\n          textContent = textContent.slice(1);\n        }\n        isStartOfLine = false;\n        break;\n      }\n    }\n    if (isStartOfLine) {\n      textContent = textContent.slice(1);\n    }\n  }\n  if (textContent[textContent.length - 1] === ' ') {\n    // Traverse forward while in the same line, preserve if next inline will require a space\n    let nextText = domNode_;\n    let isEndOfLine = true;\n    while (nextText !== null && (nextText = findTextInLine(nextText, true)) !== null) {\n      const nextTextContent = (nextText.textContent || '').replace(/^( |\\t|\\r?\\n)+/, '');\n      if (nextTextContent.length > 0) {\n        isEndOfLine = false;\n        break;\n      }\n    }\n    if (isEndOfLine) {\n      textContent = textContent.slice(0, textContent.length - 1);\n    }\n  }\n  if (textContent === '') {\n    return {\n      node: null\n    };\n  }\n  return {\n    node: $createTextNode(textContent)\n  };\n}\nconst inlineParents = new RegExp(/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/, 'i');\nfunction findTextInLine(text, forward) {\n  let node = text;\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    let sibling;\n    while ((sibling = forward ? node.nextSibling : node.previousSibling) === null) {\n      const parentElement = node.parentElement;\n      if (parentElement === null) {\n        return null;\n      }\n      node = parentElement;\n    }\n    node = sibling;\n    if (node.nodeType === DOM_ELEMENT_TYPE) {\n      const display = node.style.display;\n      if (display === '' && node.nodeName.match(inlineParents) === null || display !== '' && !display.startsWith('inline')) {\n        return null;\n      }\n    }\n    let descendant = node;\n    while ((descendant = forward ? node.firstChild : node.lastChild) !== null) {\n      node = descendant;\n    }\n    if (node.nodeType === DOM_TEXT_TYPE) {\n      return node;\n    } else if (node.nodeName === 'BR') {\n      return null;\n    }\n  }\n}\nconst nodeNameToTextFormat = {\n  code: 'code',\n  em: 'italic',\n  i: 'italic',\n  s: 'strikethrough',\n  strong: 'bold',\n  sub: 'subscript',\n  sup: 'superscript',\n  u: 'underline'\n};\nfunction convertTextFormatElement(domNode) {\n  const format = nodeNameToTextFormat[domNode.nodeName.toLowerCase()];\n  if (format === undefined) {\n    return {\n      node: null\n    };\n  }\n  return {\n    forChild: lexicalNode => {\n      if ($isTextNode(lexicalNode) && !lexicalNode.hasFormat(format)) {\n        lexicalNode.toggleFormat(format);\n      }\n      return lexicalNode;\n    },\n    node: null\n  };\n}\nfunction $createTextNode(text = '') {\n  return $applyNodeReplacement(new TextNode(text));\n}\nfunction $isTextNode(node) {\n  return node instanceof TextNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/** @noInheritDoc */\nclass TabNode extends TextNode {\n  static getType() {\n    return 'tab';\n  }\n  static clone(node) {\n    const newNode = new TabNode(node.__key);\n    // TabNode __text can be either '\\t' or ''. insertText will remove the empty Node\n    newNode.__text = node.__text;\n    newNode.__format = node.__format;\n    newNode.__style = node.__style;\n    return newNode;\n  }\n  constructor(key) {\n    super('\\t', key);\n    this.__detail = IS_UNMERGEABLE;\n  }\n  static importDOM() {\n    return null;\n  }\n  static importJSON(serializedTabNode) {\n    const node = $createTabNode();\n    node.setFormat(serializedTabNode.format);\n    node.setStyle(serializedTabNode.style);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      type: 'tab',\n      version: 1\n    };\n  }\n  setTextContent(_text) {\n    {\n      throw Error(`TabNode does not support setTextContent`);\n    }\n  }\n  setDetail(_detail) {\n    {\n      throw Error(`TabNode does not support setDetail`);\n    }\n  }\n  setMode(_type) {\n    {\n      throw Error(`TabNode does not support setMode`);\n    }\n  }\n  canInsertTextBefore() {\n    return false;\n  }\n  canInsertTextAfter() {\n    return false;\n  }\n}\nfunction $createTabNode() {\n  return $applyNodeReplacement(new TabNode());\n}\nfunction $isTabNode(node) {\n  return node instanceof TabNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nclass Point {\n  constructor(key, offset, type) {\n    this._selection = null;\n    this.key = key;\n    this.offset = offset;\n    this.type = type;\n  }\n  is(point) {\n    return this.key === point.key && this.offset === point.offset && this.type === point.type;\n  }\n  isBefore(b) {\n    let aNode = this.getNode();\n    let bNode = b.getNode();\n    const aOffset = this.offset;\n    const bOffset = b.offset;\n    if ($isElementNode(aNode)) {\n      const aNodeDescendant = aNode.getDescendantByIndex(aOffset);\n      aNode = aNodeDescendant != null ? aNodeDescendant : aNode;\n    }\n    if ($isElementNode(bNode)) {\n      const bNodeDescendant = bNode.getDescendantByIndex(bOffset);\n      bNode = bNodeDescendant != null ? bNodeDescendant : bNode;\n    }\n    if (aNode === bNode) {\n      return aOffset < bOffset;\n    }\n    return aNode.isBefore(bNode);\n  }\n  getNode() {\n    const key = this.key;\n    const node = $getNodeByKey(key);\n    if (node === null) {\n      {\n        throw Error(`Point.getNode: node not found`);\n      }\n    }\n    return node;\n  }\n  set(key, offset, type) {\n    const selection = this._selection;\n    const oldKey = this.key;\n    this.key = key;\n    this.offset = offset;\n    this.type = type;\n    if (!isCurrentlyReadOnlyMode()) {\n      if ($getCompositionKey() === oldKey) {\n        $setCompositionKey(key);\n      }\n      if (selection !== null) {\n        selection.setCachedNodes(null);\n        selection.dirty = true;\n      }\n    }\n  }\n}\nfunction $createPoint(key, offset, type) {\n  // @ts-expect-error: intentionally cast as we use a class for perf reasons\n  return new Point(key, offset, type);\n}\nfunction selectPointOnNode(point, node) {\n  let key = node.__key;\n  let offset = point.offset;\n  let type = 'element';\n  if ($isTextNode(node)) {\n    type = 'text';\n    const textContentLength = node.getTextContentSize();\n    if (offset > textContentLength) {\n      offset = textContentLength;\n    }\n  } else if (!$isElementNode(node)) {\n    const nextSibling = node.getNextSibling();\n    if ($isTextNode(nextSibling)) {\n      key = nextSibling.__key;\n      offset = 0;\n      type = 'text';\n    } else {\n      const parentNode = node.getParent();\n      if (parentNode) {\n        key = parentNode.__key;\n        offset = node.getIndexWithinParent() + 1;\n      }\n    }\n  }\n  point.set(key, offset, type);\n}\nfunction $moveSelectionPointToEnd(point, node) {\n  if ($isElementNode(node)) {\n    const lastNode = node.getLastDescendant();\n    if ($isElementNode(lastNode) || $isTextNode(lastNode)) {\n      selectPointOnNode(point, lastNode);\n    } else {\n      selectPointOnNode(point, node);\n    }\n  } else {\n    selectPointOnNode(point, node);\n  }\n}\nfunction $transferStartingElementPointToTextPoint(start, end, format, style) {\n  const element = start.getNode();\n  const placementNode = element.getChildAtIndex(start.offset);\n  const textNode = $createTextNode();\n  const target = $isRootNode(element) ? $createParagraphNode().append(textNode) : textNode;\n  textNode.setFormat(format);\n  textNode.setStyle(style);\n  if (placementNode === null) {\n    element.append(target);\n  } else {\n    placementNode.insertBefore(target);\n  }\n  // Transfer the element point to a text point.\n  if (start.is(end)) {\n    end.set(textNode.__key, 0, 'text');\n  }\n  start.set(textNode.__key, 0, 'text');\n}\nfunction $setPointValues(point, key, offset, type) {\n  point.key = key;\n  point.offset = offset;\n  point.type = type;\n}\nclass NodeSelection {\n  constructor(objects) {\n    this._cachedNodes = null;\n    this._nodes = objects;\n    this.dirty = false;\n  }\n  getCachedNodes() {\n    return this._cachedNodes;\n  }\n  setCachedNodes(nodes) {\n    this._cachedNodes = nodes;\n  }\n  is(selection) {\n    if (!$isNodeSelection(selection)) {\n      return false;\n    }\n    const a = this._nodes;\n    const b = selection._nodes;\n    return a.size === b.size && Array.from(a).every(key => b.has(key));\n  }\n  isCollapsed() {\n    return false;\n  }\n  isBackward() {\n    return false;\n  }\n  getStartEndPoints() {\n    return null;\n  }\n  add(key) {\n    this.dirty = true;\n    this._nodes.add(key);\n    this._cachedNodes = null;\n  }\n  delete(key) {\n    this.dirty = true;\n    this._nodes.delete(key);\n    this._cachedNodes = null;\n  }\n  clear() {\n    this.dirty = true;\n    this._nodes.clear();\n    this._cachedNodes = null;\n  }\n  has(key) {\n    return this._nodes.has(key);\n  }\n  clone() {\n    return new NodeSelection(new Set(this._nodes));\n  }\n  extract() {\n    return this.getNodes();\n  }\n  insertRawText(text) {\n    // Do nothing?\n  }\n  insertText() {\n    // Do nothing?\n  }\n  insertNodes(nodes) {\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const lastSelectedNode = selectedNodes[selectedNodesLength - 1];\n    let selectionAtEnd;\n    // Insert nodes\n    if ($isTextNode(lastSelectedNode)) {\n      selectionAtEnd = lastSelectedNode.select();\n    } else {\n      const index = lastSelectedNode.getIndexWithinParent() + 1;\n      selectionAtEnd = lastSelectedNode.getParentOrThrow().select(index, index);\n    }\n    selectionAtEnd.insertNodes(nodes);\n    // Remove selected nodes\n    for (let i = 0; i < selectedNodesLength; i++) {\n      selectedNodes[i].remove();\n    }\n  }\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const objects = this._nodes;\n    const nodes = [];\n    for (const object of objects) {\n      const node = $getNodeByKey(object);\n      if (node !== null) {\n        nodes.push(node);\n      }\n    }\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n  getTextContent() {\n    const nodes = this.getNodes();\n    let textContent = '';\n    for (let i = 0; i < nodes.length; i++) {\n      textContent += nodes[i].getTextContent();\n    }\n    return textContent;\n  }\n}\nfunction $isRangeSelection(x) {\n  return x instanceof RangeSelection;\n}\nclass RangeSelection {\n  constructor(anchor, focus, format, style) {\n    this.anchor = anchor;\n    this.focus = focus;\n    anchor._selection = this;\n    focus._selection = this;\n    this._cachedNodes = null;\n    this.format = format;\n    this.style = style;\n    this.dirty = false;\n  }\n  getCachedNodes() {\n    return this._cachedNodes;\n  }\n  setCachedNodes(nodes) {\n    this._cachedNodes = nodes;\n  }\n\n  /**\n   * Used to check if the provided selections is equal to this one by value,\n   * inluding anchor, focus, format, and style properties.\n   * @param selection - the Selection to compare this one to.\n   * @returns true if the Selections are equal, false otherwise.\n   */\n  is(selection) {\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    return this.anchor.is(selection.anchor) && this.focus.is(selection.focus) && this.format === selection.format && this.style === selection.style;\n  }\n\n  /**\n   * Returns whether the Selection is \"collapsed\", meaning the anchor and focus are\n   * the same node and have the same offset.\n   *\n   * @returns true if the Selection is collapsed, false otherwise.\n   */\n  isCollapsed() {\n    return this.anchor.is(this.focus);\n  }\n\n  /**\n   * Gets all the nodes in the Selection. Uses caching to make it generally suitable\n   * for use in hot paths.\n   *\n   * @returns an Array containing all the nodes in the Selection\n   */\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBefore = anchor.isBefore(focus);\n    const firstPoint = isBefore ? anchor : focus;\n    const lastPoint = isBefore ? focus : anchor;\n    let firstNode = firstPoint.getNode();\n    let lastNode = lastPoint.getNode();\n    const startOffset = firstPoint.offset;\n    const endOffset = lastPoint.offset;\n    if ($isElementNode(firstNode)) {\n      const firstNodeDescendant = firstNode.getDescendantByIndex(startOffset);\n      firstNode = firstNodeDescendant != null ? firstNodeDescendant : firstNode;\n    }\n    if ($isElementNode(lastNode)) {\n      let lastNodeDescendant = lastNode.getDescendantByIndex(endOffset);\n      // We don't want to over-select, as node selection infers the child before\n      // the last descendant, not including that descendant.\n      if (lastNodeDescendant !== null && lastNodeDescendant !== firstNode && lastNode.getChildAtIndex(endOffset) === lastNodeDescendant) {\n        lastNodeDescendant = lastNodeDescendant.getPreviousSibling();\n      }\n      lastNode = lastNodeDescendant != null ? lastNodeDescendant : lastNode;\n    }\n    let nodes;\n    if (firstNode.is(lastNode)) {\n      if ($isElementNode(firstNode) && firstNode.getChildrenSize() > 0) {\n        nodes = [];\n      } else {\n        nodes = [firstNode];\n      }\n    } else {\n      nodes = firstNode.getNodesBetween(lastNode);\n    }\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n\n  /**\n   * Sets this Selection to be of type \"text\" at the provided anchor and focus values.\n   *\n   * @param anchorNode - the anchor node to set on the Selection\n   * @param anchorOffset - the offset to set on the Selection\n   * @param focusNode - the focus node to set on the Selection\n   * @param focusOffset - the focus offset to set on the Selection\n   */\n  setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset) {\n    $setPointValues(this.anchor, anchorNode.__key, anchorOffset, 'text');\n    $setPointValues(this.focus, focusNode.__key, focusOffset, 'text');\n    this._cachedNodes = null;\n    this.dirty = true;\n  }\n\n  /**\n   * Gets the (plain) text content of all the nodes in the selection.\n   *\n   * @returns a string representing the text content of all the nodes in the Selection\n   */\n  getTextContent() {\n    const nodes = this.getNodes();\n    if (nodes.length === 0) {\n      return '';\n    }\n    const firstNode = nodes[0];\n    const lastNode = nodes[nodes.length - 1];\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBefore = anchor.isBefore(focus);\n    const [anchorOffset, focusOffset] = $getCharacterOffsets(this);\n    let textContent = '';\n    let prevWasElement = true;\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if ($isElementNode(node) && !node.isInline()) {\n        if (!prevWasElement) {\n          textContent += '\\n';\n        }\n        if (node.isEmpty()) {\n          prevWasElement = false;\n        } else {\n          prevWasElement = true;\n        }\n      } else {\n        prevWasElement = false;\n        if ($isTextNode(node)) {\n          let text = node.getTextContent();\n          if (node === firstNode) {\n            if (node === lastNode) {\n              if (anchor.type !== 'element' || focus.type !== 'element' || focus.offset === anchor.offset) {\n                text = anchorOffset < focusOffset ? text.slice(anchorOffset, focusOffset) : text.slice(focusOffset, anchorOffset);\n              }\n            } else {\n              text = isBefore ? text.slice(anchorOffset) : text.slice(focusOffset);\n            }\n          } else if (node === lastNode) {\n            text = isBefore ? text.slice(0, focusOffset) : text.slice(0, anchorOffset);\n          }\n          textContent += text;\n        } else if (($isDecoratorNode(node) || $isLineBreakNode(node)) && (node !== lastNode || !this.isCollapsed())) {\n          textContent += node.getTextContent();\n        }\n      }\n    }\n    return textContent;\n  }\n\n  /**\n   * Attempts to map a DOM selection range onto this Lexical Selection,\n   * setting the anchor, focus, and type accordingly\n   *\n   * @param range a DOM Selection range conforming to the StaticRange interface.\n   */\n  applyDOMRange(range) {\n    const editor = getActiveEditor();\n    const currentEditorState = editor.getEditorState();\n    const lastSelection = currentEditorState._selection;\n    const resolvedSelectionPoints = internalResolveSelectionPoints(range.startContainer, range.startOffset, range.endContainer, range.endOffset, editor, lastSelection);\n    if (resolvedSelectionPoints === null) {\n      return;\n    }\n    const [anchorPoint, focusPoint] = resolvedSelectionPoints;\n    $setPointValues(this.anchor, anchorPoint.key, anchorPoint.offset, anchorPoint.type);\n    $setPointValues(this.focus, focusPoint.key, focusPoint.offset, focusPoint.type);\n    this._cachedNodes = null;\n  }\n\n  /**\n   * Creates a new RangeSelection, copying over all the property values from this one.\n   *\n   * @returns a new RangeSelection with the same property values as this one.\n   */\n  clone() {\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const selection = new RangeSelection($createPoint(anchor.key, anchor.offset, anchor.type), $createPoint(focus.key, focus.offset, focus.type), this.format, this.style);\n    return selection;\n  }\n\n  /**\n   * Toggles the provided format on all the TextNodes in the Selection.\n   *\n   * @param format a string TextFormatType to toggle on the TextNodes in the selection\n   */\n  toggleFormat(format) {\n    this.format = toggleTextFormatType(this.format, format, null);\n    this.dirty = true;\n  }\n\n  /**\n   * Sets the value of the style property on the Selection\n   *\n   * @param style - the style to set at the value of the style property.\n   */\n  setStyle(style) {\n    this.style = style;\n    this.dirty = true;\n  }\n\n  /**\n   * Returns whether the provided TextFormatType is present on the Selection. This will be true if any node in the Selection\n   * has the specified format.\n   *\n   * @param type the TextFormatType to check for.\n   * @returns true if the provided format is currently toggled on on the Selection, false otherwise.\n   */\n  hasFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.format & formatFlag) !== 0;\n  }\n\n  /**\n   * Attempts to insert the provided text into the EditorState at the current Selection.\n   * converts tabs, newlines, and carriage returns into LexicalNodes.\n   *\n   * @param text the text to insert into the Selection\n   */\n  insertRawText(text) {\n    const parts = text.split(/(\\r?\\n|\\t)/);\n    const nodes = [];\n    const length = parts.length;\n    for (let i = 0; i < length; i++) {\n      const part = parts[i];\n      if (part === '\\n' || part === '\\r\\n') {\n        nodes.push($createLineBreakNode());\n      } else if (part === '\\t') {\n        nodes.push($createTabNode());\n      } else {\n        nodes.push($createTextNode(part));\n      }\n    }\n    this.insertNodes(nodes);\n  }\n\n  /**\n   * Attempts to insert the provided text into the EditorState at the current Selection as a new\n   * Lexical TextNode, according to a series of insertion heuristics based on the selection type and position.\n   *\n   * @param text the text to insert into the Selection\n   */\n  insertText(text) {\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBefore = this.isCollapsed() || anchor.isBefore(focus);\n    const format = this.format;\n    const style = this.style;\n    if (isBefore && anchor.type === 'element') {\n      $transferStartingElementPointToTextPoint(anchor, focus, format, style);\n    } else if (!isBefore && focus.type === 'element') {\n      $transferStartingElementPointToTextPoint(focus, anchor, format, style);\n    }\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const firstPoint = isBefore ? anchor : focus;\n    const endPoint = isBefore ? focus : anchor;\n    const startOffset = firstPoint.offset;\n    const endOffset = endPoint.offset;\n    let firstNode = selectedNodes[0];\n    if (!$isTextNode(firstNode)) {\n      {\n        throw Error(`insertText: first node is not a text node`);\n      }\n    }\n    const firstNodeText = firstNode.getTextContent();\n    const firstNodeTextLength = firstNodeText.length;\n    const firstNodeParent = firstNode.getParentOrThrow();\n    const lastIndex = selectedNodesLength - 1;\n    let lastNode = selectedNodes[lastIndex];\n    if (this.isCollapsed() && startOffset === firstNodeTextLength && (firstNode.isSegmented() || firstNode.isToken() || !firstNode.canInsertTextAfter() || !firstNodeParent.canInsertTextAfter() && firstNode.getNextSibling() === null)) {\n      let nextSibling = firstNode.getNextSibling();\n      if (!$isTextNode(nextSibling) || !nextSibling.canInsertTextBefore() || $isTokenOrSegmented(nextSibling)) {\n        nextSibling = $createTextNode();\n        nextSibling.setFormat(format);\n        if (!firstNodeParent.canInsertTextAfter()) {\n          firstNodeParent.insertAfter(nextSibling);\n        } else {\n          firstNode.insertAfter(nextSibling);\n        }\n      }\n      nextSibling.select(0, 0);\n      firstNode = nextSibling;\n      if (text !== '') {\n        this.insertText(text);\n        return;\n      }\n    } else if (this.isCollapsed() && startOffset === 0 && (firstNode.isSegmented() || firstNode.isToken() || !firstNode.canInsertTextBefore() || !firstNodeParent.canInsertTextBefore() && firstNode.getPreviousSibling() === null)) {\n      let prevSibling = firstNode.getPreviousSibling();\n      if (!$isTextNode(prevSibling) || $isTokenOrSegmented(prevSibling)) {\n        prevSibling = $createTextNode();\n        prevSibling.setFormat(format);\n        if (!firstNodeParent.canInsertTextBefore()) {\n          firstNodeParent.insertBefore(prevSibling);\n        } else {\n          firstNode.insertBefore(prevSibling);\n        }\n      }\n      prevSibling.select();\n      firstNode = prevSibling;\n      if (text !== '') {\n        this.insertText(text);\n        return;\n      }\n    } else if (firstNode.isSegmented() && startOffset !== firstNodeTextLength) {\n      const textNode = $createTextNode(firstNode.getTextContent());\n      textNode.setFormat(format);\n      firstNode.replace(textNode);\n      firstNode = textNode;\n    } else if (!this.isCollapsed() && text !== '') {\n      // When the firstNode or lastNode parents are elements that\n      // do not allow text to be inserted before or after, we first\n      // clear the content. Then we normalize selection, then insert\n      // the new content.\n      const lastNodeParent = lastNode.getParent();\n      if (!firstNodeParent.canInsertTextBefore() || !firstNodeParent.canInsertTextAfter() || $isElementNode(lastNodeParent) && (!lastNodeParent.canInsertTextBefore() || !lastNodeParent.canInsertTextAfter())) {\n        this.insertText('');\n        normalizeSelectionPointsForBoundaries(this.anchor, this.focus, null);\n        this.insertText(text);\n        return;\n      }\n    }\n    if (selectedNodesLength === 1) {\n      if (firstNode.isToken()) {\n        const textNode = $createTextNode(text);\n        textNode.select();\n        firstNode.replace(textNode);\n        return;\n      }\n      const firstNodeFormat = firstNode.getFormat();\n      const firstNodeStyle = firstNode.getStyle();\n      if (startOffset === endOffset && (firstNodeFormat !== format || firstNodeStyle !== style)) {\n        if (firstNode.getTextContent() === '') {\n          firstNode.setFormat(format);\n          firstNode.setStyle(style);\n        } else {\n          const textNode = $createTextNode(text);\n          textNode.setFormat(format);\n          textNode.setStyle(style);\n          textNode.select();\n          if (startOffset === 0) {\n            firstNode.insertBefore(textNode, false);\n          } else {\n            const [targetNode] = firstNode.splitText(startOffset);\n            targetNode.insertAfter(textNode, false);\n          }\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          if (textNode.isComposing() && this.anchor.type === 'text') {\n            this.anchor.offset -= text.length;\n          }\n          return;\n        }\n      } else if ($isTabNode(firstNode)) {\n        // We don't need to check for delCount because there is only the entire selected node case\n        // that can hit here for content size 1 and with canInsertTextBeforeAfter false\n        const textNode = $createTextNode(text);\n        textNode.setFormat(format);\n        textNode.setStyle(style);\n        textNode.select();\n        firstNode.replace(textNode);\n        return;\n      }\n      const delCount = endOffset - startOffset;\n      firstNode = firstNode.spliceText(startOffset, delCount, text, true);\n      if (firstNode.getTextContent() === '') {\n        firstNode.remove();\n      } else if (this.anchor.type === 'text') {\n        if (firstNode.isComposing()) {\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          this.anchor.offset -= text.length;\n        } else {\n          this.format = firstNodeFormat;\n          this.style = firstNodeStyle;\n        }\n      }\n    } else {\n      const markedNodeKeysForKeep = new Set([...firstNode.getParentKeys(), ...lastNode.getParentKeys()]);\n\n      // We have to get the parent elements before the next section,\n      // as in that section we might mutate the lastNode.\n      const firstElement = $isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();\n      let lastElement = $isElementNode(lastNode) ? lastNode : lastNode.getParentOrThrow();\n      let lastElementChild = lastNode;\n\n      // If the last element is inline, we should instead look at getting\n      // the nodes of its parent, rather than itself. This behavior will\n      // then better match how text node insertions work. We will need to\n      // also update the last element's child accordingly as we do this.\n      if (!firstElement.is(lastElement) && lastElement.isInline()) {\n        // Keep traversing till we have a non-inline element parent.\n        do {\n          lastElementChild = lastElement;\n          lastElement = lastElement.getParentOrThrow();\n        } while (lastElement.isInline());\n      }\n\n      // Handle mutations to the last node.\n      if (endPoint.type === 'text' && (endOffset !== 0 || lastNode.getTextContent() === '') || endPoint.type === 'element' && lastNode.getIndexWithinParent() < endOffset) {\n        if ($isTextNode(lastNode) && !lastNode.isToken() && endOffset !== lastNode.getTextContentSize()) {\n          if (lastNode.isSegmented()) {\n            const textNode = $createTextNode(lastNode.getTextContent());\n            lastNode.replace(textNode);\n            lastNode = textNode;\n          }\n          // root node selections only select whole nodes, so no text splice is necessary\n          if (!$isRootNode(endPoint.getNode()) && endPoint.type === 'text') {\n            lastNode = lastNode.spliceText(0, endOffset, '');\n          }\n          markedNodeKeysForKeep.add(lastNode.__key);\n        } else {\n          const lastNodeParent = lastNode.getParentOrThrow();\n          if (!lastNodeParent.canBeEmpty() && lastNodeParent.getChildrenSize() === 1) {\n            lastNodeParent.remove();\n          } else {\n            lastNode.remove();\n          }\n        }\n      } else {\n        markedNodeKeysForKeep.add(lastNode.__key);\n      }\n\n      // Either move the remaining nodes of the last parent to after\n      // the first child, or remove them entirely. If the last parent\n      // is the same as the first parent, this logic also works.\n      const lastNodeChildren = lastElement.getChildren();\n      const selectedNodesSet = new Set(selectedNodes);\n      const firstAndLastElementsAreEqual = firstElement.is(lastElement);\n\n      // We choose a target to insert all nodes after. In the case of having\n      // and inline starting parent element with a starting node that has no\n      // siblings, we should insert after the starting parent element, otherwise\n      // we will incorrectly merge into the starting parent element.\n      // TODO: should we keep on traversing parents if we're inside another\n      // nested inline element?\n      const insertionTarget = firstElement.isInline() && firstNode.getNextSibling() === null ? firstElement : firstNode;\n      for (let i = lastNodeChildren.length - 1; i >= 0; i--) {\n        const lastNodeChild = lastNodeChildren[i];\n        if (lastNodeChild.is(firstNode) || $isElementNode(lastNodeChild) && lastNodeChild.isParentOf(firstNode)) {\n          break;\n        }\n        if (lastNodeChild.isAttached()) {\n          if (!selectedNodesSet.has(lastNodeChild) || lastNodeChild.is(lastElementChild)) {\n            if (!firstAndLastElementsAreEqual) {\n              insertionTarget.insertAfter(lastNodeChild, false);\n            }\n          } else {\n            lastNodeChild.remove();\n          }\n        }\n      }\n      if (!firstAndLastElementsAreEqual) {\n        // Check if we have already moved out all the nodes of the\n        // last parent, and if so, traverse the parent tree and mark\n        // them all as being able to deleted too.\n        let parent = lastElement;\n        let lastRemovedParent = null;\n        while (parent !== null) {\n          const children = parent.getChildren();\n          const childrenLength = children.length;\n          if (childrenLength === 0 || children[childrenLength - 1].is(lastRemovedParent)) {\n            markedNodeKeysForKeep.delete(parent.__key);\n            lastRemovedParent = parent;\n          }\n          parent = parent.getParent();\n        }\n      }\n\n      // Ensure we do splicing after moving of nodes, as splicing\n      // can have side-effects (in the case of hashtags).\n      if (!firstNode.isToken()) {\n        firstNode = firstNode.spliceText(startOffset, firstNodeTextLength - startOffset, text, true);\n        if (firstNode.getTextContent() === '') {\n          firstNode.remove();\n        } else if (firstNode.isComposing() && this.anchor.type === 'text') {\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          this.anchor.offset -= text.length;\n        }\n      } else if (startOffset === firstNodeTextLength) {\n        firstNode.select();\n      } else {\n        const textNode = $createTextNode(text);\n        textNode.select();\n        firstNode.replace(textNode);\n      }\n\n      // Remove all selected nodes that haven't already been removed.\n      for (let i = 1; i < selectedNodesLength; i++) {\n        const selectedNode = selectedNodes[i];\n        const key = selectedNode.__key;\n        if (!markedNodeKeysForKeep.has(key)) {\n          selectedNode.remove();\n        }\n      }\n    }\n  }\n\n  /**\n   * Removes the text in the Selection, adjusting the EditorState accordingly.\n   */\n  removeText() {\n    this.insertText('');\n  }\n\n  /**\n   * Applies the provided format to the TextNodes in the Selection, splitting or\n   * merging nodes as necessary.\n   *\n   * @param formatType the format type to apply to the nodes in the Selection.\n   */\n  formatText(formatType) {\n    if (this.isCollapsed()) {\n      this.toggleFormat(formatType);\n      // When changing format, we should stop composition\n      $setCompositionKey(null);\n      return;\n    }\n    const selectedNodes = this.getNodes();\n    const selectedTextNodes = [];\n    for (const selectedNode of selectedNodes) {\n      if ($isTextNode(selectedNode)) {\n        selectedTextNodes.push(selectedNode);\n      }\n    }\n    const selectedTextNodesLength = selectedTextNodes.length;\n    if (selectedTextNodesLength === 0) {\n      this.toggleFormat(formatType);\n      // When changing format, we should stop composition\n      $setCompositionKey(null);\n      return;\n    }\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBackward = this.isBackward();\n    const startPoint = isBackward ? focus : anchor;\n    const endPoint = isBackward ? anchor : focus;\n    let firstIndex = 0;\n    let firstNode = selectedTextNodes[0];\n    let startOffset = startPoint.type === 'element' ? 0 : startPoint.offset;\n\n    // In case selection started at the end of text node use next text node\n    if (startPoint.type === 'text' && startOffset === firstNode.getTextContentSize()) {\n      firstIndex = 1;\n      firstNode = selectedTextNodes[1];\n      startOffset = 0;\n    }\n    if (firstNode == null) {\n      return;\n    }\n    const firstNextFormat = firstNode.getFormatFlags(formatType, null);\n    const lastIndex = selectedTextNodesLength - 1;\n    let lastNode = selectedTextNodes[lastIndex];\n    const endOffset = endPoint.type === 'text' ? endPoint.offset : lastNode.getTextContentSize();\n\n    // Single node selected\n    if (firstNode.is(lastNode)) {\n      // No actual text is selected, so do nothing.\n      if (startOffset === endOffset) {\n        return;\n      }\n      // The entire node is selected, so just format it\n      if (startOffset === 0 && endOffset === firstNode.getTextContentSize()) {\n        firstNode.setFormat(firstNextFormat);\n      } else {\n        // Node is partially selected, so split it into two nodes\n        // add style the selected one.\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        replacement.setFormat(firstNextFormat);\n\n        // Update selection only if starts/ends on text node\n        if (startPoint.type === 'text') {\n          startPoint.set(replacement.__key, 0, 'text');\n        }\n        if (endPoint.type === 'text') {\n          endPoint.set(replacement.__key, endOffset - startOffset, 'text');\n        }\n      }\n      this.format = firstNextFormat;\n      return;\n    }\n    // Multiple nodes selected\n    // The entire first node isn't selected, so split it\n    if (startOffset !== 0) {\n      [, firstNode] = firstNode.splitText(startOffset);\n      startOffset = 0;\n    }\n    firstNode.setFormat(firstNextFormat);\n    const lastNextFormat = lastNode.getFormatFlags(formatType, firstNextFormat);\n    // If the offset is 0, it means no actual characters are selected,\n    // so we skip formatting the last node altogether.\n    if (endOffset > 0) {\n      if (endOffset !== lastNode.getTextContentSize()) {\n        [lastNode] = lastNode.splitText(endOffset);\n      }\n      lastNode.setFormat(lastNextFormat);\n    }\n\n    // Process all text nodes in between\n    for (let i = firstIndex + 1; i < lastIndex; i++) {\n      const textNode = selectedTextNodes[i];\n      if (!textNode.isToken()) {\n        const nextFormat = textNode.getFormatFlags(formatType, lastNextFormat);\n        textNode.setFormat(nextFormat);\n      }\n    }\n\n    // Update selection only if starts/ends on text node\n    if (startPoint.type === 'text') {\n      startPoint.set(firstNode.__key, startOffset, 'text');\n    }\n    if (endPoint.type === 'text') {\n      endPoint.set(lastNode.__key, endOffset, 'text');\n    }\n    this.format = firstNextFormat | lastNextFormat;\n  }\n\n  /**\n   * Attempts to \"intelligently\" insert an arbitrary list of Lexical nodes into the EditorState at the\n   * current Selection according to a set of heuristics that determine how surrounding nodes\n   * should be changed, replaced, or moved to accomodate the incoming ones.\n   *\n   * @param nodes - the nodes to insert\n   */\n  insertNodes(nodes) {\n    if (nodes.length === 0) {\n      return;\n    }\n    if (this.anchor.key === 'root') {\n      this.insertParagraph();\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection)) {\n        throw Error(`Expected RangeSelection after insertParagraph`);\n      }\n      return selection.insertNodes(nodes);\n    }\n    const firstPoint = this.isBackward() ? this.focus : this.anchor;\n    const firstBlock = $getAncestor(firstPoint.getNode(), INTERNAL_$isBlock);\n    const last = nodes[nodes.length - 1];\n\n    // CASE 1: insert inside a code block\n    if ('__language' in firstBlock && $isElementNode(firstBlock)) {\n      if ('__language' in nodes[0]) {\n        this.insertText(nodes[0].getTextContent());\n      } else {\n        const index = removeTextAndSplitBlock(this);\n        firstBlock.splice(index, 0, nodes);\n        last.selectEnd();\n      }\n      return;\n    }\n\n    // CASE 2: All elements of the array are inline\n    const notInline = node => ($isElementNode(node) || $isDecoratorNode(node)) && !node.isInline();\n    if (!nodes.some(notInline)) {\n      if (!$isElementNode(firstBlock)) {\n        throw Error(`Expected 'firstBlock' to be an ElementNode`);\n      }\n      const index = removeTextAndSplitBlock(this);\n      firstBlock.splice(index, 0, nodes);\n      last.selectEnd();\n      return;\n    }\n\n    // CASE 3: At least 1 element of the array is not inline\n    const blocksParent = $wrapInlineNodes(nodes);\n    const nodeToSelect = blocksParent.getLastDescendant();\n    const blocks = blocksParent.getChildren();\n    const isLI = node => '__value' in node && '__checked' in node;\n    const isMergeable = node => $isElementNode(node) && INTERNAL_$isBlock(node) && !node.isEmpty() && $isElementNode(firstBlock) && (!firstBlock.isEmpty() || isLI(firstBlock));\n    const shouldInsert = !$isElementNode(firstBlock) || !firstBlock.isEmpty();\n    const insertedParagraph = shouldInsert ? this.insertParagraph() : null;\n    const lastToInsert = blocks[blocks.length - 1];\n    let firstToInsert = blocks[0];\n    if (isMergeable(firstToInsert)) {\n      if (!$isElementNode(firstBlock)) {\n        throw Error(`Expected 'firstBlock' to be an ElementNode`);\n      }\n      firstBlock.append(...firstToInsert.getChildren());\n      firstToInsert = blocks[1];\n    }\n    if (firstToInsert) {\n      insertRangeAfter(firstBlock, firstToInsert);\n    }\n    const lastInsertedBlock = $getAncestor(nodeToSelect, INTERNAL_$isBlock);\n    if (insertedParagraph && $isElementNode(lastInsertedBlock) && (isLI(insertedParagraph) || INTERNAL_$isBlock(lastToInsert))) {\n      lastInsertedBlock.append(...insertedParagraph.getChildren());\n      insertedParagraph.remove();\n    }\n    if ($isElementNode(firstBlock) && firstBlock.isEmpty()) {\n      firstBlock.remove();\n    }\n    nodeToSelect.selectEnd();\n\n    // To understand this take a look at the test \"can wrap post-linebreak nodes into new element\"\n    const lastChild = $isElementNode(firstBlock) ? firstBlock.getLastChild() : null;\n    if ($isLineBreakNode(lastChild) && lastInsertedBlock !== firstBlock) {\n      lastChild.remove();\n    }\n  }\n\n  /**\n   * Inserts a new ParagraphNode into the EditorState at the current Selection\n   *\n   * @returns the newly inserted node.\n   */\n  insertParagraph() {\n    if (this.anchor.key === 'root') {\n      const paragraph = $createParagraphNode();\n      $getRoot().splice(this.anchor.offset, 0, [paragraph]);\n      paragraph.select();\n      return paragraph;\n    }\n    const index = removeTextAndSplitBlock(this);\n    const block = $getAncestor(this.anchor.getNode(), INTERNAL_$isBlock);\n    if (!$isElementNode(block)) {\n      throw Error(`Expected ancestor to be an ElementNode`);\n    }\n    const firstToAppend = block.getChildAtIndex(index);\n    const nodesToInsert = firstToAppend ? [firstToAppend, ...firstToAppend.getNextSiblings()] : [];\n    const newBlock = block.insertNewAfter(this, false);\n    if (newBlock) {\n      newBlock.append(...nodesToInsert);\n      newBlock.selectStart();\n      return newBlock;\n    }\n    // if newBlock is null, it means that block is of type CodeNode.\n    return null;\n  }\n\n  /**\n   * Inserts a logical linebreak, which may be a new LineBreakNode or a new ParagraphNode, into the EditorState at the\n   * current Selection.\n   */\n  insertLineBreak(selectStart) {\n    const lineBreak = $createLineBreakNode();\n    this.insertNodes([lineBreak]);\n    // this is used in MacOS with the command 'ctrl-O' (openLineBreak)\n    if (selectStart) {\n      const parent = lineBreak.getParentOrThrow();\n      const index = lineBreak.getIndexWithinParent();\n      parent.select(index, index);\n    }\n  }\n\n  /**\n   * Extracts the nodes in the Selection, splitting nodes where necessary\n   * to get offset-level precision.\n   *\n   * @returns The nodes in the Selection\n   */\n  extract() {\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const lastIndex = selectedNodesLength - 1;\n    const anchor = this.anchor;\n    const focus = this.focus;\n    let firstNode = selectedNodes[0];\n    let lastNode = selectedNodes[lastIndex];\n    const [anchorOffset, focusOffset] = $getCharacterOffsets(this);\n    if (selectedNodesLength === 0) {\n      return [];\n    } else if (selectedNodesLength === 1) {\n      if ($isTextNode(firstNode) && !this.isCollapsed()) {\n        const startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        const endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const node = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        return node != null ? [node] : [];\n      }\n      return [firstNode];\n    }\n    const isBefore = anchor.isBefore(focus);\n    if ($isTextNode(firstNode)) {\n      const startOffset = isBefore ? anchorOffset : focusOffset;\n      if (startOffset === firstNode.getTextContentSize()) {\n        selectedNodes.shift();\n      } else if (startOffset !== 0) {\n        [, firstNode] = firstNode.splitText(startOffset);\n        selectedNodes[0] = firstNode;\n      }\n    }\n    if ($isTextNode(lastNode)) {\n      const lastNodeText = lastNode.getTextContent();\n      const lastNodeTextLength = lastNodeText.length;\n      const endOffset = isBefore ? focusOffset : anchorOffset;\n      if (endOffset === 0) {\n        selectedNodes.pop();\n      } else if (endOffset !== lastNodeTextLength) {\n        [lastNode] = lastNode.splitText(endOffset);\n        selectedNodes[lastIndex] = lastNode;\n      }\n    }\n    return selectedNodes;\n  }\n\n  /**\n   * Modifies the Selection according to the parameters and a set of heuristics that account for\n   * various node types. Can be used to safely move or extend selection by one logical \"unit\" without\n   * dealing explicitly with all the possible node types.\n   *\n   * @param alter the type of modification to perform\n   * @param isBackward whether or not selection is backwards\n   * @param granularity the granularity at which to apply the modification\n   */\n  modify(alter, isBackward, granularity) {\n    const focus = this.focus;\n    const anchor = this.anchor;\n    const collapse = alter === 'move';\n\n    // Handle the selection movement around decorators.\n    const possibleNode = $getAdjacentNode(focus, isBackward);\n    if ($isDecoratorNode(possibleNode) && !possibleNode.isIsolated()) {\n      // Make it possible to move selection from range selection to\n      // node selection on the node.\n      if (collapse && possibleNode.isKeyboardSelectable()) {\n        const nodeSelection = $createNodeSelection();\n        nodeSelection.add(possibleNode.__key);\n        $setSelection(nodeSelection);\n        return;\n      }\n      const sibling = isBackward ? possibleNode.getPreviousSibling() : possibleNode.getNextSibling();\n      if (!$isTextNode(sibling)) {\n        const parent = possibleNode.getParentOrThrow();\n        let offset;\n        let elementKey;\n        if ($isElementNode(sibling)) {\n          elementKey = sibling.__key;\n          offset = isBackward ? sibling.getChildrenSize() : 0;\n        } else {\n          offset = possibleNode.getIndexWithinParent();\n          elementKey = parent.__key;\n          if (!isBackward) {\n            offset++;\n          }\n        }\n        focus.set(elementKey, offset, 'element');\n        if (collapse) {\n          anchor.set(elementKey, offset, 'element');\n        }\n        return;\n      } else {\n        const siblingKey = sibling.__key;\n        const offset = isBackward ? sibling.getTextContent().length : 0;\n        focus.set(siblingKey, offset, 'text');\n        if (collapse) {\n          anchor.set(siblingKey, offset, 'text');\n        }\n        return;\n      }\n    }\n    const editor = getActiveEditor();\n    const domSelection = getDOMSelection(editor._window);\n    if (!domSelection) {\n      return;\n    }\n    const blockCursorElement = editor._blockCursorElement;\n    const rootElement = editor._rootElement;\n    // Remove the block cursor element if it exists. This will ensure selection\n    // works as intended. If we leave it in the DOM all sorts of strange bugs\n    // occur. :/\n    if (rootElement !== null && blockCursorElement !== null && $isElementNode(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty()) {\n      removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n    }\n    // We use the DOM selection.modify API here to \"tell\" us what the selection\n    // will be. We then use it to update the Lexical selection accordingly. This\n    // is much more reliable than waiting for a beforeinput and using the ranges\n    // from getTargetRanges(), and is also better than trying to do it ourselves\n    // using Intl.Segmenter or other workarounds that struggle with word segments\n    // and line segments (especially with word wrapping and non-Roman languages).\n    moveNativeSelection(domSelection, alter, isBackward ? 'backward' : 'forward', granularity);\n    // Guard against no ranges\n    if (domSelection.rangeCount > 0) {\n      const range = domSelection.getRangeAt(0);\n      // Apply the DOM selection to our Lexical selection.\n      const anchorNode = this.anchor.getNode();\n      const root = $isRootNode(anchorNode) ? anchorNode : $getNearestRootOrShadowRoot(anchorNode);\n      this.applyDOMRange(range);\n      this.dirty = true;\n      if (!collapse) {\n        // Validate selection; make sure that the new extended selection respects shadow roots\n        const nodes = this.getNodes();\n        const validNodes = [];\n        let shrinkSelection = false;\n        for (let i = 0; i < nodes.length; i++) {\n          const nextNode = nodes[i];\n          if ($hasAncestor(nextNode, root)) {\n            validNodes.push(nextNode);\n          } else {\n            shrinkSelection = true;\n          }\n        }\n        if (shrinkSelection && validNodes.length > 0) {\n          // validNodes length check is a safeguard against an invalid selection; as getNodes()\n          // will return an empty array in this case\n          if (isBackward) {\n            const firstValidNode = validNodes[0];\n            if ($isElementNode(firstValidNode)) {\n              firstValidNode.selectStart();\n            } else {\n              firstValidNode.getParentOrThrow().selectStart();\n            }\n          } else {\n            const lastValidNode = validNodes[validNodes.length - 1];\n            if ($isElementNode(lastValidNode)) {\n              lastValidNode.selectEnd();\n            } else {\n              lastValidNode.getParentOrThrow().selectEnd();\n            }\n          }\n        }\n\n        // Because a range works on start and end, we might need to flip\n        // the anchor and focus points to match what the DOM has, not what\n        // the range has specifically.\n        if (domSelection.anchorNode !== range.startContainer || domSelection.anchorOffset !== range.startOffset) {\n          $swapPoints(this);\n        }\n      }\n    }\n  }\n  /**\n   * Helper for handling forward character and word deletion that prevents element nodes\n   * like a table, columns layout being destroyed\n   *\n   * @param anchor the anchor\n   * @param anchorNode the anchor node in the selection\n   * @param isBackward whether or not selection is backwards\n   */\n  forwardDeletion(anchor, anchorNode, isBackward) {\n    if (!isBackward && (\n    // Delete forward handle case\n    anchor.type === 'element' && $isElementNode(anchorNode) && anchor.offset === anchorNode.getChildrenSize() || anchor.type === 'text' && anchor.offset === anchorNode.getTextContentSize())) {\n      const parent = anchorNode.getParent();\n      const nextSibling = anchorNode.getNextSibling() || (parent === null ? null : parent.getNextSibling());\n      if ($isElementNode(nextSibling) && nextSibling.isShadowRoot()) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Performs one logical character deletion operation on the EditorState based on the current Selection.\n   * Handles different node types.\n   *\n   * @param isBackward whether or not the selection is backwards.\n   */\n  deleteCharacter(isBackward) {\n    const wasCollapsed = this.isCollapsed();\n    if (this.isCollapsed()) {\n      const anchor = this.anchor;\n      let anchorNode = anchor.getNode();\n      if (this.forwardDeletion(anchor, anchorNode, isBackward)) {\n        return;\n      }\n\n      // Handle the deletion around decorators.\n      const focus = this.focus;\n      const possibleNode = $getAdjacentNode(focus, isBackward);\n      if ($isDecoratorNode(possibleNode) && !possibleNode.isIsolated()) {\n        // Make it possible to move selection from range selection to\n        // node selection on the node.\n        if (possibleNode.isKeyboardSelectable() && $isElementNode(anchorNode) && anchorNode.getChildrenSize() === 0) {\n          anchorNode.remove();\n          const nodeSelection = $createNodeSelection();\n          nodeSelection.add(possibleNode.__key);\n          $setSelection(nodeSelection);\n        } else {\n          possibleNode.remove();\n          const editor = getActiveEditor();\n          editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n        }\n        return;\n      } else if (!isBackward && $isElementNode(possibleNode) && $isElementNode(anchorNode) && anchorNode.isEmpty()) {\n        anchorNode.remove();\n        possibleNode.selectStart();\n        return;\n      }\n      this.modify('extend', isBackward, 'character');\n      if (!this.isCollapsed()) {\n        const focusNode = focus.type === 'text' ? focus.getNode() : null;\n        anchorNode = anchor.type === 'text' ? anchor.getNode() : null;\n        if (focusNode !== null && focusNode.isSegmented()) {\n          const offset = focus.offset;\n          const textContentSize = focusNode.getTextContentSize();\n          if (focusNode.is(anchorNode) || isBackward && offset !== textContentSize || !isBackward && offset !== 0) {\n            $removeSegment(focusNode, isBackward, offset);\n            return;\n          }\n        } else if (anchorNode !== null && anchorNode.isSegmented()) {\n          const offset = anchor.offset;\n          const textContentSize = anchorNode.getTextContentSize();\n          if (anchorNode.is(focusNode) || isBackward && offset !== 0 || !isBackward && offset !== textContentSize) {\n            $removeSegment(anchorNode, isBackward, offset);\n            return;\n          }\n        }\n        $updateCaretSelectionForUnicodeCharacter(this, isBackward);\n      } else if (isBackward && anchor.offset === 0) {\n        // Special handling around rich text nodes\n        const element = anchor.type === 'element' ? anchor.getNode() : anchor.getNode().getParentOrThrow();\n        if (element.collapseAtStart(this)) {\n          return;\n        }\n      }\n    }\n    this.removeText();\n    if (isBackward && !wasCollapsed && this.isCollapsed() && this.anchor.type === 'element' && this.anchor.offset === 0) {\n      const anchorNode = this.anchor.getNode();\n      if (anchorNode.isEmpty() && $isRootNode(anchorNode.getParent()) && anchorNode.getIndexWithinParent() === 0) {\n        anchorNode.collapseAtStart(this);\n      }\n    }\n  }\n\n  /**\n   * Performs one logical line deletion operation on the EditorState based on the current Selection.\n   * Handles different node types.\n   *\n   * @param isBackward whether or not the selection is backwards.\n   */\n  deleteLine(isBackward) {\n    if (this.isCollapsed()) {\n      if (this.anchor.type === 'text') {\n        this.modify('extend', isBackward, 'lineboundary');\n      }\n\n      // If selection is extended to cover text edge then extend it one character more\n      // to delete its parent element. Otherwise text content will be deleted but empty\n      // parent node will remain\n      const endPoint = isBackward ? this.focus : this.anchor;\n      if (endPoint.offset === 0) {\n        this.modify('extend', isBackward, 'character');\n      }\n    }\n    this.removeText();\n  }\n\n  /**\n   * Performs one logical word deletion operation on the EditorState based on the current Selection.\n   * Handles different node types.\n   *\n   * @param isBackward whether or not the selection is backwards.\n   */\n  deleteWord(isBackward) {\n    if (this.isCollapsed()) {\n      const anchor = this.anchor;\n      const anchorNode = anchor.getNode();\n      if (this.forwardDeletion(anchor, anchorNode, isBackward)) {\n        return;\n      }\n      this.modify('extend', isBackward, 'word');\n    }\n    this.removeText();\n  }\n\n  /**\n   * Returns whether the Selection is \"backwards\", meaning the focus\n   * logically precedes the anchor in the EditorState.\n   * @returns true if the Selection is backwards, false otherwise.\n   */\n  isBackward() {\n    return this.focus.isBefore(this.anchor);\n  }\n  getStartEndPoints() {\n    return [this.anchor, this.focus];\n  }\n}\nfunction $isNodeSelection(x) {\n  return x instanceof NodeSelection;\n}\nfunction getCharacterOffset(point) {\n  const offset = point.offset;\n  if (point.type === 'text') {\n    return offset;\n  }\n  const parent = point.getNode();\n  return offset === parent.getChildrenSize() ? parent.getTextContent().length : 0;\n}\nfunction $getCharacterOffsets(selection) {\n  const anchorAndFocus = selection.getStartEndPoints();\n  if (anchorAndFocus === null) {\n    return [0, 0];\n  }\n  const [anchor, focus] = anchorAndFocus;\n  if (anchor.type === 'element' && focus.type === 'element' && anchor.key === focus.key && anchor.offset === focus.offset) {\n    return [0, 0];\n  }\n  return [getCharacterOffset(anchor), getCharacterOffset(focus)];\n}\nfunction $swapPoints(selection) {\n  const focus = selection.focus;\n  const anchor = selection.anchor;\n  const anchorKey = anchor.key;\n  const anchorOffset = anchor.offset;\n  const anchorType = anchor.type;\n  $setPointValues(anchor, focus.key, focus.offset, focus.type);\n  $setPointValues(focus, anchorKey, anchorOffset, anchorType);\n  selection._cachedNodes = null;\n}\nfunction moveNativeSelection(domSelection, alter, direction, granularity) {\n  // Selection.modify() method applies a change to the current selection or cursor position,\n  // but is still non-standard in some browsers.\n  domSelection.modify(alter, direction, granularity);\n}\nfunction $updateCaretSelectionForUnicodeCharacter(selection, isBackward) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if (anchorNode === focusNode && anchor.type === 'text' && focus.type === 'text') {\n    // Handling of multibyte characters\n    const anchorOffset = anchor.offset;\n    const focusOffset = focus.offset;\n    const isBefore = anchorOffset < focusOffset;\n    const startOffset = isBefore ? anchorOffset : focusOffset;\n    const endOffset = isBefore ? focusOffset : anchorOffset;\n    const characterOffset = endOffset - 1;\n    if (startOffset !== characterOffset) {\n      const text = anchorNode.getTextContent().slice(startOffset, endOffset);\n      if (!doesContainGrapheme(text)) {\n        if (isBackward) {\n          focus.offset = characterOffset;\n        } else {\n          anchor.offset = characterOffset;\n        }\n      }\n    }\n  }\n}\nfunction $removeSegment(node, isBackward, offset) {\n  const textNode = node;\n  const textContent = textNode.getTextContent();\n  const split = textContent.split(/(?=\\s)/g);\n  const splitLength = split.length;\n  let segmentOffset = 0;\n  let restoreOffset = 0;\n  for (let i = 0; i < splitLength; i++) {\n    const text = split[i];\n    const isLast = i === splitLength - 1;\n    restoreOffset = segmentOffset;\n    segmentOffset += text.length;\n    if (isBackward && segmentOffset === offset || segmentOffset > offset || isLast) {\n      split.splice(i, 1);\n      if (isLast) {\n        restoreOffset = undefined;\n      }\n      break;\n    }\n  }\n  const nextTextContent = split.join('').trim();\n  if (nextTextContent === '') {\n    textNode.remove();\n  } else {\n    textNode.setTextContent(nextTextContent);\n    textNode.select(restoreOffset, restoreOffset);\n  }\n}\nfunction shouldResolveAncestor(resolvedElement, resolvedOffset, lastPoint) {\n  const parent = resolvedElement.getParent();\n  return lastPoint === null || parent === null || !parent.canBeEmpty() || parent !== lastPoint.getNode();\n}\nfunction internalResolveSelectionPoint(dom, offset, lastPoint, editor) {\n  let resolvedOffset = offset;\n  let resolvedNode;\n  // If we have selection on an element, we will\n  // need to figure out (using the offset) what text\n  // node should be selected.\n\n  if (dom.nodeType === DOM_ELEMENT_TYPE) {\n    // Resolve element to a ElementNode, or TextNode, or null\n    let moveSelectionToEnd = false;\n    // Given we're moving selection to another node, selection is\n    // definitely dirty.\n    // We use the anchor to find which child node to select\n    const childNodes = dom.childNodes;\n    const childNodesLength = childNodes.length;\n    // If the anchor is the same as length, then this means we\n    // need to select the very last text node.\n    if (resolvedOffset === childNodesLength) {\n      moveSelectionToEnd = true;\n      resolvedOffset = childNodesLength - 1;\n    }\n    let childDOM = childNodes[resolvedOffset];\n    let hasBlockCursor = false;\n    if (childDOM === editor._blockCursorElement) {\n      childDOM = childNodes[resolvedOffset + 1];\n      hasBlockCursor = true;\n    } else if (editor._blockCursorElement !== null) {\n      resolvedOffset--;\n    }\n    resolvedNode = getNodeFromDOM(childDOM);\n    if ($isTextNode(resolvedNode)) {\n      resolvedOffset = getTextNodeOffset(resolvedNode, moveSelectionToEnd);\n    } else {\n      let resolvedElement = getNodeFromDOM(dom);\n      // Ensure resolvedElement is actually a element.\n      if (resolvedElement === null) {\n        return null;\n      }\n      if ($isElementNode(resolvedElement)) {\n        let child = resolvedElement.getChildAtIndex(resolvedOffset);\n        if ($isElementNode(child) && shouldResolveAncestor(child, resolvedOffset, lastPoint)) {\n          const descendant = moveSelectionToEnd ? child.getLastDescendant() : child.getFirstDescendant();\n          if (descendant === null) {\n            resolvedElement = child;\n            resolvedOffset = 0;\n          } else {\n            child = descendant;\n            resolvedElement = $isElementNode(child) ? child : child.getParentOrThrow();\n          }\n        }\n        if ($isTextNode(child)) {\n          resolvedNode = child;\n          resolvedElement = null;\n          resolvedOffset = getTextNodeOffset(child, moveSelectionToEnd);\n        } else if (child !== resolvedElement && moveSelectionToEnd && !hasBlockCursor) {\n          resolvedOffset++;\n        }\n      } else {\n        const index = resolvedElement.getIndexWithinParent();\n        // When selecting decorators, there can be some selection issues when using resolvedOffset,\n        // and instead we should be checking if we're using the offset\n        if (offset === 0 && $isDecoratorNode(resolvedElement) && getNodeFromDOM(dom) === resolvedElement) {\n          resolvedOffset = index;\n        } else {\n          resolvedOffset = index + 1;\n        }\n        resolvedElement = resolvedElement.getParentOrThrow();\n      }\n      if ($isElementNode(resolvedElement)) {\n        return $createPoint(resolvedElement.__key, resolvedOffset, 'element');\n      }\n    }\n  } else {\n    // TextNode or null\n    resolvedNode = getNodeFromDOM(dom);\n  }\n  if (!$isTextNode(resolvedNode)) {\n    return null;\n  }\n  return $createPoint(resolvedNode.__key, resolvedOffset, 'text');\n}\nfunction resolveSelectionPointOnBoundary(point, isBackward, isCollapsed) {\n  const offset = point.offset;\n  const node = point.getNode();\n  if (offset === 0) {\n    const prevSibling = node.getPreviousSibling();\n    const parent = node.getParent();\n    if (!isBackward) {\n      if ($isElementNode(prevSibling) && !isCollapsed && prevSibling.isInline()) {\n        point.key = prevSibling.__key;\n        point.offset = prevSibling.getChildrenSize();\n        // @ts-expect-error: intentional\n        point.type = 'element';\n      } else if ($isTextNode(prevSibling)) {\n        point.key = prevSibling.__key;\n        point.offset = prevSibling.getTextContent().length;\n      }\n    } else if ((isCollapsed || !isBackward) && prevSibling === null && $isElementNode(parent) && parent.isInline()) {\n      const parentSibling = parent.getPreviousSibling();\n      if ($isTextNode(parentSibling)) {\n        point.key = parentSibling.__key;\n        point.offset = parentSibling.getTextContent().length;\n      }\n    }\n  } else if (offset === node.getTextContent().length) {\n    const nextSibling = node.getNextSibling();\n    const parent = node.getParent();\n    if (isBackward && $isElementNode(nextSibling) && nextSibling.isInline()) {\n      point.key = nextSibling.__key;\n      point.offset = 0;\n      // @ts-expect-error: intentional\n      point.type = 'element';\n    } else if ((isCollapsed || isBackward) && nextSibling === null && $isElementNode(parent) && parent.isInline() && !parent.canInsertTextAfter()) {\n      const parentSibling = parent.getNextSibling();\n      if ($isTextNode(parentSibling)) {\n        point.key = parentSibling.__key;\n        point.offset = 0;\n      }\n    }\n  }\n}\nfunction normalizeSelectionPointsForBoundaries(anchor, focus, lastSelection) {\n  if (anchor.type === 'text' && focus.type === 'text') {\n    const isBackward = anchor.isBefore(focus);\n    const isCollapsed = anchor.is(focus);\n\n    // Attempt to normalize the offset to the previous sibling if we're at the\n    // start of a text node and the sibling is a text node or inline element.\n    resolveSelectionPointOnBoundary(anchor, isBackward, isCollapsed);\n    resolveSelectionPointOnBoundary(focus, !isBackward, isCollapsed);\n    if (isCollapsed) {\n      focus.key = anchor.key;\n      focus.offset = anchor.offset;\n      focus.type = anchor.type;\n    }\n    const editor = getActiveEditor();\n    if (editor.isComposing() && editor._compositionKey !== anchor.key && $isRangeSelection(lastSelection)) {\n      const lastAnchor = lastSelection.anchor;\n      const lastFocus = lastSelection.focus;\n      $setPointValues(anchor, lastAnchor.key, lastAnchor.offset, lastAnchor.type);\n      $setPointValues(focus, lastFocus.key, lastFocus.offset, lastFocus.type);\n    }\n  }\n}\nfunction internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection) {\n  if (anchorDOM === null || focusDOM === null || !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n    return null;\n  }\n  const resolvedAnchorPoint = internalResolveSelectionPoint(anchorDOM, anchorOffset, $isRangeSelection(lastSelection) ? lastSelection.anchor : null, editor);\n  if (resolvedAnchorPoint === null) {\n    return null;\n  }\n  const resolvedFocusPoint = internalResolveSelectionPoint(focusDOM, focusOffset, $isRangeSelection(lastSelection) ? lastSelection.focus : null, editor);\n  if (resolvedFocusPoint === null) {\n    return null;\n  }\n  if (resolvedAnchorPoint.type === 'element' && resolvedFocusPoint.type === 'element') {\n    const anchorNode = getNodeFromDOM(anchorDOM);\n    const focusNode = getNodeFromDOM(focusDOM);\n    // Ensure if we're selecting the content of a decorator that we\n    // return null for this point, as it's not in the controlled scope\n    // of Lexical.\n    if ($isDecoratorNode(anchorNode) && $isDecoratorNode(focusNode)) {\n      return null;\n    }\n  }\n\n  // Handle normalization of selection when it is at the boundaries.\n  normalizeSelectionPointsForBoundaries(resolvedAnchorPoint, resolvedFocusPoint, lastSelection);\n  return [resolvedAnchorPoint, resolvedFocusPoint];\n}\nfunction $isBlockElementNode(node) {\n  return $isElementNode(node) && !node.isInline();\n}\n\n// This is used to make a selection when the existing\n// selection is null, i.e. forcing selection on the editor\n// when it current exists outside the editor.\n\nfunction internalMakeRangeSelection(anchorKey, anchorOffset, focusKey, focusOffset, anchorType, focusType) {\n  const editorState = getActiveEditorState();\n  const selection = new RangeSelection($createPoint(anchorKey, anchorOffset, anchorType), $createPoint(focusKey, focusOffset, focusType), 0, '');\n  selection.dirty = true;\n  editorState._selection = selection;\n  return selection;\n}\nfunction $createRangeSelection() {\n  const anchor = $createPoint('root', 0, 'element');\n  const focus = $createPoint('root', 0, 'element');\n  return new RangeSelection(anchor, focus, 0, '');\n}\nfunction $createNodeSelection() {\n  return new NodeSelection(new Set());\n}\nfunction internalCreateSelection(editor) {\n  const currentEditorState = editor.getEditorState();\n  const lastSelection = currentEditorState._selection;\n  const domSelection = getDOMSelection(editor._window);\n  if ($isRangeSelection(lastSelection) || lastSelection == null) {\n    return internalCreateRangeSelection(lastSelection, domSelection, editor, null);\n  }\n  return lastSelection.clone();\n}\nfunction internalCreateRangeSelection(lastSelection, domSelection, editor, event) {\n  const windowObj = editor._window;\n  if (windowObj === null) {\n    return null;\n  }\n  // When we create a selection, we try to use the previous\n  // selection where possible, unless an actual user selection\n  // change has occurred. When we do need to create a new selection\n  // we validate we can have text nodes for both anchor and focus\n  // nodes. If that holds true, we then return that selection\n  // as a mutable object that we use for the editor state for this\n  // update cycle. If a selection gets changed, and requires a\n  // update to native DOM selection, it gets marked as \"dirty\".\n  // If the selection changes, but matches with the existing\n  // DOM selection, then we only need to sync it. Otherwise,\n  // we generally bail out of doing an update to selection during\n  // reconciliation unless there are dirty nodes that need\n  // reconciling.\n\n  const windowEvent = event || windowObj.event;\n  const eventType = windowEvent ? windowEvent.type : undefined;\n  const isSelectionChange = eventType === 'selectionchange';\n  const useDOMSelection = !getIsProcessingMutations() && (isSelectionChange || eventType === 'beforeinput' || eventType === 'compositionstart' || eventType === 'compositionend' || eventType === 'click' && windowEvent && windowEvent.detail === 3 || eventType === 'drop' || eventType === undefined);\n  let anchorDOM, focusDOM, anchorOffset, focusOffset;\n  if (!$isRangeSelection(lastSelection) || useDOMSelection) {\n    if (domSelection === null) {\n      return null;\n    }\n    anchorDOM = domSelection.anchorNode;\n    focusDOM = domSelection.focusNode;\n    anchorOffset = domSelection.anchorOffset;\n    focusOffset = domSelection.focusOffset;\n    if (isSelectionChange && $isRangeSelection(lastSelection) && !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n      return lastSelection.clone();\n    }\n  } else {\n    return lastSelection.clone();\n  }\n  // Let's resolve the text nodes from the offsets and DOM nodes we have from\n  // native selection.\n  const resolvedSelectionPoints = internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection);\n  if (resolvedSelectionPoints === null) {\n    return null;\n  }\n  const [resolvedAnchorPoint, resolvedFocusPoint] = resolvedSelectionPoints;\n  return new RangeSelection(resolvedAnchorPoint, resolvedFocusPoint, !$isRangeSelection(lastSelection) ? 0 : lastSelection.format, !$isRangeSelection(lastSelection) ? '' : lastSelection.style);\n}\nfunction $getSelection() {\n  const editorState = getActiveEditorState();\n  return editorState._selection;\n}\nfunction $getPreviousSelection() {\n  const editor = getActiveEditor();\n  return editor._editorState._selection;\n}\nfunction $updateElementSelectionOnCreateDeleteNode(selection, parentNode, nodeOffset, times = 1) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if (!parentNode.is(anchorNode) && !parentNode.is(focusNode)) {\n    return;\n  }\n  const parentKey = parentNode.__key;\n  // Single node. We shift selection but never redimension it\n  if (selection.isCollapsed()) {\n    const selectionOffset = anchor.offset;\n    if (nodeOffset <= selectionOffset && times > 0 || nodeOffset < selectionOffset && times < 0) {\n      const newSelectionOffset = Math.max(0, selectionOffset + times);\n      anchor.set(parentKey, newSelectionOffset, 'element');\n      focus.set(parentKey, newSelectionOffset, 'element');\n      // The new selection might point to text nodes, try to resolve them\n      $updateSelectionResolveTextNodes(selection);\n    }\n  } else {\n    // Multiple nodes selected. We shift or redimension selection\n    const isBackward = selection.isBackward();\n    const firstPoint = isBackward ? focus : anchor;\n    const firstPointNode = firstPoint.getNode();\n    const lastPoint = isBackward ? anchor : focus;\n    const lastPointNode = lastPoint.getNode();\n    if (parentNode.is(firstPointNode)) {\n      const firstPointOffset = firstPoint.offset;\n      if (nodeOffset <= firstPointOffset && times > 0 || nodeOffset < firstPointOffset && times < 0) {\n        firstPoint.set(parentKey, Math.max(0, firstPointOffset + times), 'element');\n      }\n    }\n    if (parentNode.is(lastPointNode)) {\n      const lastPointOffset = lastPoint.offset;\n      if (nodeOffset <= lastPointOffset && times > 0 || nodeOffset < lastPointOffset && times < 0) {\n        lastPoint.set(parentKey, Math.max(0, lastPointOffset + times), 'element');\n      }\n    }\n  }\n  // The new selection might point to text nodes, try to resolve them\n  $updateSelectionResolveTextNodes(selection);\n}\nfunction $updateSelectionResolveTextNodes(selection) {\n  const anchor = selection.anchor;\n  const anchorOffset = anchor.offset;\n  const focus = selection.focus;\n  const focusOffset = focus.offset;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if (selection.isCollapsed()) {\n    if (!$isElementNode(anchorNode)) {\n      return;\n    }\n    const childSize = anchorNode.getChildrenSize();\n    const anchorOffsetAtEnd = anchorOffset >= childSize;\n    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n      if (anchorOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n      anchor.set(child.__key, newOffset, 'text');\n      focus.set(child.__key, newOffset, 'text');\n    }\n    return;\n  }\n  if ($isElementNode(anchorNode)) {\n    const childSize = anchorNode.getChildrenSize();\n    const anchorOffsetAtEnd = anchorOffset >= childSize;\n    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n      if (anchorOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n      anchor.set(child.__key, newOffset, 'text');\n    }\n  }\n  if ($isElementNode(focusNode)) {\n    const childSize = focusNode.getChildrenSize();\n    const focusOffsetAtEnd = focusOffset >= childSize;\n    const child = focusOffsetAtEnd ? focusNode.getChildAtIndex(childSize - 1) : focusNode.getChildAtIndex(focusOffset);\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n      if (focusOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n      focus.set(child.__key, newOffset, 'text');\n    }\n  }\n}\nfunction applySelectionTransforms(nextEditorState, editor) {\n  const prevEditorState = editor.getEditorState();\n  const prevSelection = prevEditorState._selection;\n  const nextSelection = nextEditorState._selection;\n  if ($isRangeSelection(nextSelection)) {\n    const anchor = nextSelection.anchor;\n    const focus = nextSelection.focus;\n    let anchorNode;\n    if (anchor.type === 'text') {\n      anchorNode = anchor.getNode();\n      anchorNode.selectionTransform(prevSelection, nextSelection);\n    }\n    if (focus.type === 'text') {\n      const focusNode = focus.getNode();\n      if (anchorNode !== focusNode) {\n        focusNode.selectionTransform(prevSelection, nextSelection);\n      }\n    }\n  }\n}\nfunction moveSelectionPointToSibling(point, node, parent, prevSibling, nextSibling) {\n  let siblingKey = null;\n  let offset = 0;\n  let type = null;\n  if (prevSibling !== null) {\n    siblingKey = prevSibling.__key;\n    if ($isTextNode(prevSibling)) {\n      offset = prevSibling.getTextContentSize();\n      type = 'text';\n    } else if ($isElementNode(prevSibling)) {\n      offset = prevSibling.getChildrenSize();\n      type = 'element';\n    }\n  } else {\n    if (nextSibling !== null) {\n      siblingKey = nextSibling.__key;\n      if ($isTextNode(nextSibling)) {\n        type = 'text';\n      } else if ($isElementNode(nextSibling)) {\n        type = 'element';\n      }\n    }\n  }\n  if (siblingKey !== null && type !== null) {\n    point.set(siblingKey, offset, type);\n  } else {\n    offset = node.getIndexWithinParent();\n    if (offset === -1) {\n      // Move selection to end of parent\n      offset = parent.getChildrenSize();\n    }\n    point.set(parent.__key, offset, 'element');\n  }\n}\nfunction adjustPointOffsetForMergedSibling(point, isBefore, key, target, textLength) {\n  if (point.type === 'text') {\n    point.key = key;\n    if (!isBefore) {\n      point.offset += textLength;\n    }\n  } else if (point.offset > target.getIndexWithinParent()) {\n    point.offset -= 1;\n  }\n}\nfunction updateDOMSelection(prevSelection, nextSelection, editor, domSelection, tags, rootElement, nodeCount) {\n  const anchorDOMNode = domSelection.anchorNode;\n  const focusDOMNode = domSelection.focusNode;\n  const anchorOffset = domSelection.anchorOffset;\n  const focusOffset = domSelection.focusOffset;\n  const activeElement = document.activeElement;\n\n  // TODO: make this not hard-coded, and add another config option\n  // that makes this configurable.\n  if (tags.has('collaboration') && activeElement !== rootElement || activeElement !== null && isSelectionCapturedInDecoratorInput(activeElement)) {\n    return;\n  }\n  if (!$isRangeSelection(nextSelection)) {\n    // We don't remove selection if the prevSelection is null because\n    // of editor.setRootElement(). If this occurs on init when the\n    // editor is already focused, then this can cause the editor to\n    // lose focus.\n    if (prevSelection !== null && isSelectionWithinEditor(editor, anchorDOMNode, focusDOMNode)) {\n      domSelection.removeAllRanges();\n    }\n    return;\n  }\n  const anchor = nextSelection.anchor;\n  const focus = nextSelection.focus;\n  const anchorKey = anchor.key;\n  const focusKey = focus.key;\n  const anchorDOM = getElementByKeyOrThrow(editor, anchorKey);\n  const focusDOM = getElementByKeyOrThrow(editor, focusKey);\n  const nextAnchorOffset = anchor.offset;\n  const nextFocusOffset = focus.offset;\n  const nextFormat = nextSelection.format;\n  const nextStyle = nextSelection.style;\n  const isCollapsed = nextSelection.isCollapsed();\n  let nextAnchorNode = anchorDOM;\n  let nextFocusNode = focusDOM;\n  let anchorFormatOrStyleChanged = false;\n  if (anchor.type === 'text') {\n    nextAnchorNode = getDOMTextNode(anchorDOM);\n    const anchorNode = anchor.getNode();\n    anchorFormatOrStyleChanged = anchorNode.getFormat() !== nextFormat || anchorNode.getStyle() !== nextStyle;\n  } else if ($isRangeSelection(prevSelection) && prevSelection.anchor.type === 'text') {\n    anchorFormatOrStyleChanged = true;\n  }\n  if (focus.type === 'text') {\n    nextFocusNode = getDOMTextNode(focusDOM);\n  }\n\n  // If we can't get an underlying text node for selection, then\n  // we should avoid setting selection to something incorrect.\n  if (nextAnchorNode === null || nextFocusNode === null) {\n    return;\n  }\n  if (isCollapsed && (prevSelection === null || anchorFormatOrStyleChanged || $isRangeSelection(prevSelection) && (prevSelection.format !== nextFormat || prevSelection.style !== nextStyle))) {\n    markCollapsedSelectionFormat(nextFormat, nextStyle, nextAnchorOffset, anchorKey, performance.now());\n  }\n\n  // Diff against the native DOM selection to ensure we don't do\n  // an unnecessary selection update. We also skip this check if\n  // we're moving selection to within an element, as this can\n  // sometimes be problematic around scrolling.\n  if (anchorOffset === nextAnchorOffset && focusOffset === nextFocusOffset && anchorDOMNode === nextAnchorNode && focusDOMNode === nextFocusNode &&\n  // Badly interpreted range selection when collapsed - #1482\n  !(domSelection.type === 'Range' && isCollapsed)) {\n    // If the root element does not have focus, ensure it has focus\n    if (activeElement === null || !rootElement.contains(activeElement)) {\n      rootElement.focus({\n        preventScroll: true\n      });\n    }\n    if (anchor.type !== 'element') {\n      return;\n    }\n  }\n\n  // Apply the updated selection to the DOM. Note: this will trigger\n  // a \"selectionchange\" event, although it will be asynchronous.\n  try {\n    domSelection.setBaseAndExtent(nextAnchorNode, nextAnchorOffset, nextFocusNode, nextFocusOffset);\n  } catch (error) {\n    // If we encounter an error, continue. This can sometimes\n    // occur with FF and there's no good reason as to why it\n    // should happen.\n  }\n  if (!tags.has('skip-scroll-into-view') && nextSelection.isCollapsed() && rootElement !== null && rootElement === document.activeElement) {\n    const selectionTarget = nextSelection instanceof RangeSelection && nextSelection.anchor.type === 'element' ? nextAnchorNode.childNodes[nextAnchorOffset] || null : domSelection.rangeCount > 0 ? domSelection.getRangeAt(0) : null;\n    if (selectionTarget !== null) {\n      let selectionRect;\n      if (selectionTarget instanceof Text) {\n        const range = document.createRange();\n        range.selectNode(selectionTarget);\n        selectionRect = range.getBoundingClientRect();\n      } else {\n        selectionRect = selectionTarget.getBoundingClientRect();\n      }\n      scrollIntoViewIfNeeded(editor, selectionRect, rootElement);\n    }\n  }\n  markSelectionChangeFromDOMUpdate();\n}\nfunction $insertNodes(nodes) {\n  let selection = $getSelection() || $getPreviousSelection();\n  if (selection === null) {\n    selection = $getRoot().selectEnd();\n  }\n  selection.insertNodes(nodes);\n}\nfunction $getTextContent() {\n  const selection = $getSelection();\n  if (selection === null) {\n    return '';\n  }\n  return selection.getTextContent();\n}\nfunction removeTextAndSplitBlock(selection) {\n  if (!selection.isCollapsed()) {\n    selection.removeText();\n  }\n  const anchor = selection.anchor;\n  let node = anchor.getNode();\n  let offset = anchor.offset;\n  while (!INTERNAL_$isBlock(node)) {\n    [node, offset] = splitNodeAtPoint(node, offset);\n  }\n  return offset;\n}\nfunction splitNodeAtPoint(node, offset) {\n  const parent = node.getParent();\n  if (!parent) {\n    const paragraph = $createParagraphNode();\n    $getRoot().append(paragraph);\n    paragraph.select();\n    return [$getRoot(), 0];\n  }\n  if ($isTextNode(node)) {\n    const split = node.splitText(offset);\n    if (split.length === 0) {\n      return [parent, node.getIndexWithinParent()];\n    }\n    const x = offset === 0 ? 0 : 1;\n    const index = split[0].getIndexWithinParent() + x;\n    return [parent, index];\n  }\n  if (!$isElementNode(node) || offset === 0) {\n    return [parent, node.getIndexWithinParent()];\n  }\n  const firstToAppend = node.getChildAtIndex(offset);\n  if (firstToAppend) {\n    const insertPoint = new RangeSelection($createPoint(node.__key, offset, 'element'), $createPoint(node.__key, offset, 'element'), 0, '');\n    const newElement = node.insertNewAfter(insertPoint);\n    if (newElement) {\n      newElement.append(firstToAppend, ...firstToAppend.getNextSiblings());\n    }\n  }\n  return [parent, node.getIndexWithinParent() + 1];\n}\nfunction $wrapInlineNodes(nodes) {\n  // We temporarily insert the topLevelNodes into an arbitrary ElementNode,\n  // since insertAfter does not work on nodes that have no parent (TO-DO: fix that).\n  const virtualRoot = $createParagraphNode();\n  let currentBlock = null;\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    const isLineBreakNode = $isLineBreakNode(node);\n    if (isLineBreakNode || $isDecoratorNode(node) && node.isInline() || $isElementNode(node) && node.isInline() || $isTextNode(node) || node.isParentRequired()) {\n      if (currentBlock === null) {\n        currentBlock = node.createParentElementNode();\n        virtualRoot.append(currentBlock);\n        // In the case of LineBreakNode, we just need to\n        // add an empty ParagraphNode to the topLevelBlocks.\n        if (isLineBreakNode) {\n          continue;\n        }\n      }\n      if (currentBlock !== null) {\n        currentBlock.append(node);\n      }\n    } else {\n      virtualRoot.append(node);\n      currentBlock = null;\n    }\n  }\n  return virtualRoot;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nlet activeEditorState = null;\nlet activeEditor = null;\nlet isReadOnlyMode = false;\nlet isAttemptingToRecoverFromReconcilerError = false;\nlet infiniteTransformCount = 0;\nconst observerOptions = {\n  characterData: true,\n  childList: true,\n  subtree: true\n};\nfunction isCurrentlyReadOnlyMode() {\n  return isReadOnlyMode || activeEditorState !== null && activeEditorState._readOnly;\n}\nfunction errorOnReadOnly() {\n  if (isReadOnlyMode) {\n    {\n      throw Error(`Cannot use method in read-only mode.`);\n    }\n  }\n}\nfunction errorOnInfiniteTransforms() {\n  if (infiniteTransformCount > 99) {\n    {\n      throw Error(`One or more transforms are endlessly triggering additional transforms. May have encountered infinite recursion caused by transforms that have their preconditions too lose and/or conflict with each other.`);\n    }\n  }\n}\nfunction getActiveEditorState() {\n  if (activeEditorState === null) {\n    {\n      throw Error(`Unable to find an active editor state. State helpers or node methods can only be used synchronously during the callback of editor.update() or editorState.read().`);\n    }\n  }\n  return activeEditorState;\n}\nfunction getActiveEditor() {\n  if (activeEditor === null) {\n    {\n      throw Error(`Unable to find an active editor. This method can only be used synchronously during the callback of editor.update().`);\n    }\n  }\n  return activeEditor;\n}\nfunction internalGetActiveEditor() {\n  return activeEditor;\n}\nfunction $applyTransforms(editor, node, transformsCache) {\n  const type = node.__type;\n  const registeredNode = getRegisteredNodeOrThrow(editor, type);\n  let transformsArr = transformsCache.get(type);\n  if (transformsArr === undefined) {\n    transformsArr = Array.from(registeredNode.transforms);\n    transformsCache.set(type, transformsArr);\n  }\n  const transformsArrLength = transformsArr.length;\n  for (let i = 0; i < transformsArrLength; i++) {\n    transformsArr[i](node);\n    if (!node.isAttached()) {\n      break;\n    }\n  }\n}\nfunction $isNodeValidForTransform(node, compositionKey) {\n  return node !== undefined &&\n  // We don't want to transform nodes being composed\n  node.__key !== compositionKey && node.isAttached();\n}\nfunction $normalizeAllDirtyTextNodes(editorState, editor) {\n  const dirtyLeaves = editor._dirtyLeaves;\n  const nodeMap = editorState._nodeMap;\n  for (const nodeKey of dirtyLeaves) {\n    const node = nodeMap.get(nodeKey);\n    if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {\n      $normalizeTextNode(node);\n    }\n  }\n}\n\n/**\n * Transform heuristic:\n * 1. We transform leaves first. If transforms generate additional dirty nodes we repeat step 1.\n * The reasoning behind this is that marking a leaf as dirty marks all its parent elements as dirty too.\n * 2. We transform elements. If element transforms generate additional dirty nodes we repeat step 1.\n * If element transforms only generate additional dirty elements we only repeat step 2.\n *\n * Note that to keep track of newly dirty nodes and subtrees we leverage the editor._dirtyNodes and\n * editor._subtrees which we reset in every loop.\n */\nfunction $applyAllTransforms(editorState, editor) {\n  const dirtyLeaves = editor._dirtyLeaves;\n  const dirtyElements = editor._dirtyElements;\n  const nodeMap = editorState._nodeMap;\n  const compositionKey = $getCompositionKey();\n  const transformsCache = new Map();\n  let untransformedDirtyLeaves = dirtyLeaves;\n  let untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n  let untransformedDirtyElements = dirtyElements;\n  let untransformedDirtyElementsLength = untransformedDirtyElements.size;\n  while (untransformedDirtyLeavesLength > 0 || untransformedDirtyElementsLength > 0) {\n    if (untransformedDirtyLeavesLength > 0) {\n      // We leverage editor._dirtyLeaves to track the new dirty leaves after the transforms\n      editor._dirtyLeaves = new Set();\n      for (const nodeKey of untransformedDirtyLeaves) {\n        const node = nodeMap.get(nodeKey);\n        if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {\n          $normalizeTextNode(node);\n        }\n        if (node !== undefined && $isNodeValidForTransform(node, compositionKey)) {\n          $applyTransforms(editor, node, transformsCache);\n        }\n        dirtyLeaves.add(nodeKey);\n      }\n      untransformedDirtyLeaves = editor._dirtyLeaves;\n      untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n\n      // We want to prioritize node transforms over element transforms\n      if (untransformedDirtyLeavesLength > 0) {\n        infiniteTransformCount++;\n        continue;\n      }\n    }\n\n    // All dirty leaves have been processed. Let's do elements!\n    // We have previously processed dirty leaves, so let's restart the editor leaves Set to track\n    // new ones caused by element transforms\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements = new Map();\n    for (const currentUntransformedDirtyElement of untransformedDirtyElements) {\n      const nodeKey = currentUntransformedDirtyElement[0];\n      const intentionallyMarkedAsDirty = currentUntransformedDirtyElement[1];\n      if (nodeKey !== 'root' && !intentionallyMarkedAsDirty) {\n        continue;\n      }\n      const node = nodeMap.get(nodeKey);\n      if (node !== undefined && $isNodeValidForTransform(node, compositionKey)) {\n        $applyTransforms(editor, node, transformsCache);\n      }\n      dirtyElements.set(nodeKey, intentionallyMarkedAsDirty);\n    }\n    untransformedDirtyLeaves = editor._dirtyLeaves;\n    untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n    untransformedDirtyElements = editor._dirtyElements;\n    untransformedDirtyElementsLength = untransformedDirtyElements.size;\n    infiniteTransformCount++;\n  }\n  editor._dirtyLeaves = dirtyLeaves;\n  editor._dirtyElements = dirtyElements;\n}\nfunction $parseSerializedNode(serializedNode) {\n  const internalSerializedNode = serializedNode;\n  return $parseSerializedNodeImpl(internalSerializedNode, getActiveEditor()._nodes);\n}\nfunction $parseSerializedNodeImpl(serializedNode, registeredNodes) {\n  const type = serializedNode.type;\n  const registeredNode = registeredNodes.get(type);\n  if (registeredNode === undefined) {\n    {\n      throw Error(`parseEditorState: type \"${type}\" + not found`);\n    }\n  }\n  const nodeClass = registeredNode.klass;\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .importJSON().`);\n    }\n  }\n  const node = nodeClass.importJSON(serializedNode);\n  const children = serializedNode.children;\n  if ($isElementNode(node) && Array.isArray(children)) {\n    for (let i = 0; i < children.length; i++) {\n      const serializedJSONChildNode = children[i];\n      const childNode = $parseSerializedNodeImpl(serializedJSONChildNode, registeredNodes);\n      node.append(childNode);\n    }\n  }\n  return node;\n}\nfunction parseEditorState(serializedEditorState, editor, updateFn) {\n  const editorState = createEmptyEditorState();\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previousDirtyElements = editor._dirtyElements;\n  const previousDirtyLeaves = editor._dirtyLeaves;\n  const previousCloneNotNeeded = editor._cloneNotNeeded;\n  const previousDirtyType = editor._dirtyType;\n  editor._dirtyElements = new Map();\n  editor._dirtyLeaves = new Set();\n  editor._cloneNotNeeded = new Set();\n  editor._dirtyType = 0;\n  activeEditorState = editorState;\n  isReadOnlyMode = false;\n  activeEditor = editor;\n  try {\n    const registeredNodes = editor._nodes;\n    const serializedNode = serializedEditorState.root;\n    $parseSerializedNodeImpl(serializedNode, registeredNodes);\n    if (updateFn) {\n      updateFn();\n    }\n\n    // Make the editorState immutable\n    editorState._readOnly = true;\n    {\n      handleDEVOnlyPendingUpdateGuarantees(editorState);\n    }\n  } catch (error) {\n    if (error instanceof Error) {\n      editor._onError(error);\n    }\n  } finally {\n    editor._dirtyElements = previousDirtyElements;\n    editor._dirtyLeaves = previousDirtyLeaves;\n    editor._cloneNotNeeded = previousCloneNotNeeded;\n    editor._dirtyType = previousDirtyType;\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n  }\n  return editorState;\n}\n\n// This technically isn't an update but given we need\n// exposure to the module's active bindings, we have this\n// function here\n\nfunction readEditorState(editorState, callbackFn) {\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  activeEditorState = editorState;\n  isReadOnlyMode = true;\n  activeEditor = null;\n  try {\n    return callbackFn();\n  } finally {\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n  }\n}\nfunction handleDEVOnlyPendingUpdateGuarantees(pendingEditorState) {\n  // Given we can't Object.freeze the nodeMap as it's a Map,\n  // we instead replace its set, clear and delete methods.\n  const nodeMap = pendingEditorState._nodeMap;\n  nodeMap.set = () => {\n    throw new Error('Cannot call set() on a frozen Lexical node map');\n  };\n  nodeMap.clear = () => {\n    throw new Error('Cannot call clear() on a frozen Lexical node map');\n  };\n  nodeMap.delete = () => {\n    throw new Error('Cannot call delete() on a frozen Lexical node map');\n  };\n}\nfunction commitPendingUpdates(editor, recoveryEditorState) {\n  const pendingEditorState = editor._pendingEditorState;\n  const rootElement = editor._rootElement;\n  const shouldSkipDOM = editor._headless || rootElement === null;\n  if (pendingEditorState === null) {\n    return;\n  }\n\n  // ======\n  // Reconciliation has started.\n  // ======\n\n  const currentEditorState = editor._editorState;\n  const currentSelection = currentEditorState._selection;\n  const pendingSelection = pendingEditorState._selection;\n  const needsUpdate = editor._dirtyType !== NO_DIRTY_NODES;\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previouslyUpdating = editor._updating;\n  const observer = editor._observer;\n  let mutatedNodes = null;\n  editor._pendingEditorState = null;\n  editor._editorState = pendingEditorState;\n  if (!shouldSkipDOM && needsUpdate && observer !== null) {\n    activeEditor = editor;\n    activeEditorState = pendingEditorState;\n    isReadOnlyMode = false;\n    // We don't want updates to sync block the reconciliation.\n    editor._updating = true;\n    try {\n      const dirtyType = editor._dirtyType;\n      const dirtyElements = editor._dirtyElements;\n      const dirtyLeaves = editor._dirtyLeaves;\n      observer.disconnect();\n      mutatedNodes = reconcileRoot(currentEditorState, pendingEditorState, editor, dirtyType, dirtyElements, dirtyLeaves);\n    } catch (error) {\n      // Report errors\n      if (error instanceof Error) {\n        editor._onError(error);\n      }\n\n      // Reset editor and restore incoming editor state to the DOM\n      if (!isAttemptingToRecoverFromReconcilerError) {\n        resetEditor(editor, null, rootElement, pendingEditorState);\n        initMutationObserver(editor);\n        editor._dirtyType = FULL_RECONCILE;\n        isAttemptingToRecoverFromReconcilerError = true;\n        commitPendingUpdates(editor, currentEditorState);\n        isAttemptingToRecoverFromReconcilerError = false;\n      } else {\n        // To avoid a possible situation of infinite loops, lets throw\n        throw error;\n      }\n      return;\n    } finally {\n      observer.observe(rootElement, observerOptions);\n      editor._updating = previouslyUpdating;\n      activeEditorState = previousActiveEditorState;\n      isReadOnlyMode = previousReadOnlyMode;\n      activeEditor = previousActiveEditor;\n    }\n  }\n  if (!pendingEditorState._readOnly) {\n    pendingEditorState._readOnly = true;\n    {\n      handleDEVOnlyPendingUpdateGuarantees(pendingEditorState);\n      if ($isRangeSelection(pendingSelection)) {\n        Object.freeze(pendingSelection.anchor);\n        Object.freeze(pendingSelection.focus);\n      }\n      Object.freeze(pendingSelection);\n    }\n  }\n  const dirtyLeaves = editor._dirtyLeaves;\n  const dirtyElements = editor._dirtyElements;\n  const normalizedNodes = editor._normalizedNodes;\n  const tags = editor._updateTags;\n  const deferred = editor._deferred;\n  if (needsUpdate) {\n    editor._dirtyType = NO_DIRTY_NODES;\n    editor._cloneNotNeeded.clear();\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements = new Map();\n    editor._normalizedNodes = new Set();\n    editor._updateTags = new Set();\n  }\n  $garbageCollectDetachedDecorators(editor, pendingEditorState);\n\n  // ======\n  // Reconciliation has finished. Now update selection and trigger listeners.\n  // ======\n\n  const domSelection = shouldSkipDOM ? null : getDOMSelection(editor._window);\n\n  // Attempt to update the DOM selection, including focusing of the root element,\n  // and scroll into view if needed.\n  if (editor._editable &&\n  // domSelection will be null in headless\n  domSelection !== null && (needsUpdate || pendingSelection === null || pendingSelection.dirty)) {\n    activeEditor = editor;\n    activeEditorState = pendingEditorState;\n    try {\n      if (observer !== null) {\n        observer.disconnect();\n      }\n      if (needsUpdate || pendingSelection === null || pendingSelection.dirty) {\n        const blockCursorElement = editor._blockCursorElement;\n        if (blockCursorElement !== null) {\n          removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n        }\n        updateDOMSelection(currentSelection, pendingSelection, editor, domSelection, tags, rootElement);\n      }\n      updateDOMBlockCursorElement(editor, rootElement, pendingSelection);\n      if (observer !== null) {\n        observer.observe(rootElement, observerOptions);\n      }\n    } finally {\n      activeEditor = previousActiveEditor;\n      activeEditorState = previousActiveEditorState;\n    }\n  }\n  if (mutatedNodes !== null) {\n    triggerMutationListeners(editor, mutatedNodes, tags, dirtyLeaves, currentEditorState);\n  }\n  if (!$isRangeSelection(pendingSelection) && pendingSelection !== null && (currentSelection === null || !currentSelection.is(pendingSelection))) {\n    editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n  }\n  /**\n   * Capture pendingDecorators after garbage collecting detached decorators\n   */\n  const pendingDecorators = editor._pendingDecorators;\n  if (pendingDecorators !== null) {\n    editor._decorators = pendingDecorators;\n    editor._pendingDecorators = null;\n    triggerListeners('decorator', editor, true, pendingDecorators);\n  }\n\n  // If reconciler fails, we reset whole editor (so current editor state becomes empty)\n  // and attempt to re-render pendingEditorState. If that goes through we trigger\n  // listeners, but instead use recoverEditorState which is current editor state before reset\n  // This specifically important for collab that relies on prevEditorState from update\n  // listener to calculate delta of changed nodes/properties\n  triggerTextContentListeners(editor, recoveryEditorState || currentEditorState, pendingEditorState);\n  triggerListeners('update', editor, true, {\n    dirtyElements,\n    dirtyLeaves,\n    editorState: pendingEditorState,\n    normalizedNodes,\n    prevEditorState: recoveryEditorState || currentEditorState,\n    tags\n  });\n  triggerDeferredUpdateCallbacks(editor, deferred);\n  triggerEnqueuedUpdates(editor);\n}\nfunction triggerTextContentListeners(editor, currentEditorState, pendingEditorState) {\n  const currentTextContent = getEditorStateTextContent(currentEditorState);\n  const latestTextContent = getEditorStateTextContent(pendingEditorState);\n  if (currentTextContent !== latestTextContent) {\n    triggerListeners('textcontent', editor, true, latestTextContent);\n  }\n}\nfunction triggerMutationListeners(editor, mutatedNodes, updateTags, dirtyLeaves, prevEditorState) {\n  const listeners = Array.from(editor._listeners.mutation);\n  const listenersLength = listeners.length;\n  for (let i = 0; i < listenersLength; i++) {\n    const [listener, klass] = listeners[i];\n    const mutatedNodesByType = mutatedNodes.get(klass);\n    if (mutatedNodesByType !== undefined) {\n      listener(mutatedNodesByType, {\n        dirtyLeaves,\n        prevEditorState,\n        updateTags\n      });\n    }\n  }\n}\nfunction triggerListeners(type, editor, isCurrentlyEnqueuingUpdates, ...payload) {\n  const previouslyUpdating = editor._updating;\n  editor._updating = isCurrentlyEnqueuingUpdates;\n  try {\n    const listeners = Array.from(editor._listeners[type]);\n    for (let i = 0; i < listeners.length; i++) {\n      // @ts-ignore\n      listeners[i].apply(null, payload);\n    }\n  } finally {\n    editor._updating = previouslyUpdating;\n  }\n}\nfunction triggerCommandListeners(editor, type, payload) {\n  if (editor._updating === false || activeEditor !== editor) {\n    let returnVal = false;\n    editor.update(() => {\n      returnVal = triggerCommandListeners(editor, type, payload);\n    });\n    return returnVal;\n  }\n  const editors = getEditorsToPropagate(editor);\n  for (let i = 4; i >= 0; i--) {\n    for (let e = 0; e < editors.length; e++) {\n      const currentEditor = editors[e];\n      const commandListeners = currentEditor._commands;\n      const listenerInPriorityOrder = commandListeners.get(type);\n      if (listenerInPriorityOrder !== undefined) {\n        const listenersSet = listenerInPriorityOrder[i];\n        if (listenersSet !== undefined) {\n          const listeners = Array.from(listenersSet);\n          const listenersLength = listeners.length;\n          for (let j = 0; j < listenersLength; j++) {\n            if (listeners[j](payload, editor) === true) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n  }\n  return false;\n}\nfunction triggerEnqueuedUpdates(editor) {\n  const queuedUpdates = editor._updates;\n  if (queuedUpdates.length !== 0) {\n    const queuedUpdate = queuedUpdates.shift();\n    if (queuedUpdate) {\n      const [updateFn, options] = queuedUpdate;\n      beginUpdate(editor, updateFn, options);\n    }\n  }\n}\nfunction triggerDeferredUpdateCallbacks(editor, deferred) {\n  editor._deferred = [];\n  if (deferred.length !== 0) {\n    const previouslyUpdating = editor._updating;\n    editor._updating = true;\n    try {\n      for (let i = 0; i < deferred.length; i++) {\n        deferred[i]();\n      }\n    } finally {\n      editor._updating = previouslyUpdating;\n    }\n  }\n}\nfunction processNestedUpdates(editor, initialSkipTransforms) {\n  const queuedUpdates = editor._updates;\n  let skipTransforms = initialSkipTransforms || false;\n\n  // Updates might grow as we process them, we so we'll need\n  // to handle each update as we go until the updates array is\n  // empty.\n  while (queuedUpdates.length !== 0) {\n    const queuedUpdate = queuedUpdates.shift();\n    if (queuedUpdate) {\n      const [nextUpdateFn, options] = queuedUpdate;\n      let onUpdate;\n      let tag;\n      if (options !== undefined) {\n        onUpdate = options.onUpdate;\n        tag = options.tag;\n        if (options.skipTransforms) {\n          skipTransforms = true;\n        }\n        if (onUpdate) {\n          editor._deferred.push(onUpdate);\n        }\n        if (tag) {\n          editor._updateTags.add(tag);\n        }\n      }\n      nextUpdateFn();\n    }\n  }\n  return skipTransforms;\n}\nfunction beginUpdate(editor, updateFn, options) {\n  const updateTags = editor._updateTags;\n  let onUpdate;\n  let tag;\n  let skipTransforms = false;\n  let discrete = false;\n  if (options !== undefined) {\n    onUpdate = options.onUpdate;\n    tag = options.tag;\n    if (tag != null) {\n      updateTags.add(tag);\n    }\n    skipTransforms = options.skipTransforms || false;\n    discrete = options.discrete || false;\n  }\n  if (onUpdate) {\n    editor._deferred.push(onUpdate);\n  }\n  const currentEditorState = editor._editorState;\n  let pendingEditorState = editor._pendingEditorState;\n  let editorStateWasCloned = false;\n  if (pendingEditorState === null || pendingEditorState._readOnly) {\n    pendingEditorState = editor._pendingEditorState = cloneEditorState(pendingEditorState || currentEditorState);\n    editorStateWasCloned = true;\n  }\n  pendingEditorState._flushSync = discrete;\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previouslyUpdating = editor._updating;\n  activeEditorState = pendingEditorState;\n  isReadOnlyMode = false;\n  editor._updating = true;\n  activeEditor = editor;\n  try {\n    if (editorStateWasCloned) {\n      if (editor._headless) {\n        if (currentEditorState._selection !== null) {\n          pendingEditorState._selection = currentEditorState._selection.clone();\n        }\n      } else {\n        pendingEditorState._selection = internalCreateSelection(editor);\n      }\n    }\n    const startingCompositionKey = editor._compositionKey;\n    updateFn();\n    skipTransforms = processNestedUpdates(editor, skipTransforms);\n    applySelectionTransforms(pendingEditorState, editor);\n    if (editor._dirtyType !== NO_DIRTY_NODES) {\n      if (skipTransforms) {\n        $normalizeAllDirtyTextNodes(pendingEditorState, editor);\n      } else {\n        $applyAllTransforms(pendingEditorState, editor);\n      }\n      processNestedUpdates(editor);\n      $garbageCollectDetachedNodes(currentEditorState, pendingEditorState, editor._dirtyLeaves, editor._dirtyElements);\n    }\n    const endingCompositionKey = editor._compositionKey;\n    if (startingCompositionKey !== endingCompositionKey) {\n      pendingEditorState._flushSync = true;\n    }\n    const pendingSelection = pendingEditorState._selection;\n    if ($isRangeSelection(pendingSelection)) {\n      const pendingNodeMap = pendingEditorState._nodeMap;\n      const anchorKey = pendingSelection.anchor.key;\n      const focusKey = pendingSelection.focus.key;\n      if (pendingNodeMap.get(anchorKey) === undefined || pendingNodeMap.get(focusKey) === undefined) {\n        {\n          throw Error(`updateEditor: selection has been lost because the previously selected nodes have been removed and selection wasn't moved to another node. Ensure selection changes after removing/replacing a selected node.`);\n        }\n      }\n    } else if ($isNodeSelection(pendingSelection)) {\n      // TODO: we should also validate node selection?\n      if (pendingSelection._nodes.size === 0) {\n        pendingEditorState._selection = null;\n      }\n    }\n  } catch (error) {\n    // Report errors\n    if (error instanceof Error) {\n      editor._onError(error);\n    }\n\n    // Restore existing editor state to the DOM\n    editor._pendingEditorState = currentEditorState;\n    editor._dirtyType = FULL_RECONCILE;\n    editor._cloneNotNeeded.clear();\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements.clear();\n    commitPendingUpdates(editor);\n    return;\n  } finally {\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n    editor._updating = previouslyUpdating;\n    infiniteTransformCount = 0;\n  }\n  const shouldUpdate = editor._dirtyType !== NO_DIRTY_NODES || editorStateHasDirtySelection(pendingEditorState, editor);\n  if (shouldUpdate) {\n    if (pendingEditorState._flushSync) {\n      pendingEditorState._flushSync = false;\n      commitPendingUpdates(editor);\n    } else if (editorStateWasCloned) {\n      scheduleMicroTask(() => {\n        commitPendingUpdates(editor);\n      });\n    }\n  } else {\n    pendingEditorState._flushSync = false;\n    if (editorStateWasCloned) {\n      updateTags.clear();\n      editor._deferred = [];\n      editor._pendingEditorState = null;\n    }\n  }\n}\nfunction updateEditor(editor, updateFn, options) {\n  if (editor._updating) {\n    editor._updates.push([updateFn, options]);\n  } else {\n    beginUpdate(editor, updateFn, options);\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass DecoratorNode extends LexicalNode {\n  constructor(key) {\n    super(key);\n  }\n\n  /**\n   * The returned value is added to the LexicalEditor._decorators\n   */\n  decorate(editor, config) {\n    {\n      throw Error(`decorate: base method not extended`);\n    }\n  }\n  isIsolated() {\n    return false;\n  }\n  isInline() {\n    return true;\n  }\n  isKeyboardSelectable() {\n    return true;\n  }\n}\nfunction $isDecoratorNode(node) {\n  return node instanceof DecoratorNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/** @noInheritDoc */\nclass ElementNode extends LexicalNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  constructor(key) {\n    super(key);\n    this.__first = null;\n    this.__last = null;\n    this.__size = 0;\n    this.__format = 0;\n    this.__indent = 0;\n    this.__dir = null;\n  }\n  getFormat() {\n    const self = this.getLatest();\n    return self.__format;\n  }\n  getFormatType() {\n    const format = this.getFormat();\n    return ELEMENT_FORMAT_TO_TYPE[format] || '';\n  }\n  getIndent() {\n    const self = this.getLatest();\n    return self.__indent;\n  }\n  getChildren() {\n    const children = [];\n    let child = this.getFirstChild();\n    while (child !== null) {\n      children.push(child);\n      child = child.getNextSibling();\n    }\n    return children;\n  }\n  getChildrenKeys() {\n    const children = [];\n    let child = this.getFirstChild();\n    while (child !== null) {\n      children.push(child.__key);\n      child = child.getNextSibling();\n    }\n    return children;\n  }\n  getChildrenSize() {\n    const self = this.getLatest();\n    return self.__size;\n  }\n  isEmpty() {\n    return this.getChildrenSize() === 0;\n  }\n  isDirty() {\n    const editor = getActiveEditor();\n    const dirtyElements = editor._dirtyElements;\n    return dirtyElements !== null && dirtyElements.has(this.__key);\n  }\n  isLastChild() {\n    const self = this.getLatest();\n    const parentLastChild = this.getParentOrThrow().getLastChild();\n    return parentLastChild !== null && parentLastChild.is(self);\n  }\n  getAllTextNodes() {\n    const textNodes = [];\n    let child = this.getFirstChild();\n    while (child !== null) {\n      if ($isTextNode(child)) {\n        textNodes.push(child);\n      }\n      if ($isElementNode(child)) {\n        const subChildrenNodes = child.getAllTextNodes();\n        textNodes.push(...subChildrenNodes);\n      }\n      child = child.getNextSibling();\n    }\n    return textNodes;\n  }\n  getFirstDescendant() {\n    let node = this.getFirstChild();\n    while ($isElementNode(node)) {\n      const child = node.getFirstChild();\n      if (child === null) {\n        break;\n      }\n      node = child;\n    }\n    return node;\n  }\n  getLastDescendant() {\n    let node = this.getLastChild();\n    while ($isElementNode(node)) {\n      const child = node.getLastChild();\n      if (child === null) {\n        break;\n      }\n      node = child;\n    }\n    return node;\n  }\n  getDescendantByIndex(index) {\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    // For non-empty element nodes, we resolve its descendant\n    // (either a leaf node or the bottom-most element)\n    if (index >= childrenLength) {\n      const resolvedNode = children[childrenLength - 1];\n      return $isElementNode(resolvedNode) && resolvedNode.getLastDescendant() || resolvedNode || null;\n    }\n    const resolvedNode = children[index];\n    return $isElementNode(resolvedNode) && resolvedNode.getFirstDescendant() || resolvedNode || null;\n  }\n  getFirstChild() {\n    const self = this.getLatest();\n    const firstKey = self.__first;\n    return firstKey === null ? null : $getNodeByKey(firstKey);\n  }\n  getFirstChildOrThrow() {\n    const firstChild = this.getFirstChild();\n    if (firstChild === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a first child.`);\n      }\n    }\n    return firstChild;\n  }\n  getLastChild() {\n    const self = this.getLatest();\n    const lastKey = self.__last;\n    return lastKey === null ? null : $getNodeByKey(lastKey);\n  }\n  getLastChildOrThrow() {\n    const lastChild = this.getLastChild();\n    if (lastChild === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a last child.`);\n      }\n    }\n    return lastChild;\n  }\n  getChildAtIndex(index) {\n    const size = this.getChildrenSize();\n    let node;\n    let i;\n    if (index < size / 2) {\n      node = this.getFirstChild();\n      i = 0;\n      while (node !== null && i <= index) {\n        if (i === index) {\n          return node;\n        }\n        node = node.getNextSibling();\n        i++;\n      }\n      return null;\n    }\n    node = this.getLastChild();\n    i = size - 1;\n    while (node !== null && i >= index) {\n      if (i === index) {\n        return node;\n      }\n      node = node.getPreviousSibling();\n      i--;\n    }\n    return null;\n  }\n  getTextContent() {\n    let textContent = '';\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    for (let i = 0; i < childrenLength; i++) {\n      const child = children[i];\n      textContent += child.getTextContent();\n      if ($isElementNode(child) && i !== childrenLength - 1 && !child.isInline()) {\n        textContent += DOUBLE_LINE_BREAK;\n      }\n    }\n    return textContent;\n  }\n  getTextContentSize() {\n    let textContentSize = 0;\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    for (let i = 0; i < childrenLength; i++) {\n      const child = children[i];\n      textContentSize += child.getTextContentSize();\n      if ($isElementNode(child) && i !== childrenLength - 1 && !child.isInline()) {\n        textContentSize += DOUBLE_LINE_BREAK.length;\n      }\n    }\n    return textContentSize;\n  }\n  getDirection() {\n    const self = this.getLatest();\n    return self.__dir;\n  }\n  hasFormat(type) {\n    if (type !== '') {\n      const formatFlag = ELEMENT_TYPE_TO_FORMAT[type];\n      return (this.getFormat() & formatFlag) !== 0;\n    }\n    return false;\n  }\n\n  // Mutators\n\n  select(_anchorOffset, _focusOffset) {\n    errorOnReadOnly();\n    const selection = $getSelection();\n    let anchorOffset = _anchorOffset;\n    let focusOffset = _focusOffset;\n    const childrenCount = this.getChildrenSize();\n    if (!this.canBeEmpty()) {\n      if (_anchorOffset === 0 && _focusOffset === 0) {\n        const firstChild = this.getFirstChild();\n        if ($isTextNode(firstChild) || $isElementNode(firstChild)) {\n          return firstChild.select(0, 0);\n        }\n      } else if ((_anchorOffset === undefined || _anchorOffset === childrenCount) && (_focusOffset === undefined || _focusOffset === childrenCount)) {\n        const lastChild = this.getLastChild();\n        if ($isTextNode(lastChild) || $isElementNode(lastChild)) {\n          return lastChild.select();\n        }\n      }\n    }\n    if (anchorOffset === undefined) {\n      anchorOffset = childrenCount;\n    }\n    if (focusOffset === undefined) {\n      focusOffset = childrenCount;\n    }\n    const key = this.__key;\n    if (!$isRangeSelection(selection)) {\n      return internalMakeRangeSelection(key, anchorOffset, key, focusOffset, 'element', 'element');\n    } else {\n      selection.anchor.set(key, anchorOffset, 'element');\n      selection.focus.set(key, focusOffset, 'element');\n      selection.dirty = true;\n    }\n    return selection;\n  }\n  selectStart() {\n    const firstNode = this.getFirstDescendant();\n    return firstNode ? firstNode.selectStart() : this.select();\n  }\n  selectEnd() {\n    const lastNode = this.getLastDescendant();\n    return lastNode ? lastNode.selectEnd() : this.select();\n  }\n  clear() {\n    const writableSelf = this.getWritable();\n    const children = this.getChildren();\n    children.forEach(child => child.remove());\n    return writableSelf;\n  }\n  append(...nodesToAppend) {\n    return this.splice(this.getChildrenSize(), 0, nodesToAppend);\n  }\n  setDirection(direction) {\n    const self = this.getWritable();\n    self.__dir = direction;\n    return self;\n  }\n  setFormat(type) {\n    const self = this.getWritable();\n    self.__format = type !== '' ? ELEMENT_TYPE_TO_FORMAT[type] : 0;\n    return this;\n  }\n  setIndent(indentLevel) {\n    const self = this.getWritable();\n    self.__indent = indentLevel;\n    return this;\n  }\n  splice(start, deleteCount, nodesToInsert) {\n    const nodesToInsertLength = nodesToInsert.length;\n    const oldSize = this.getChildrenSize();\n    const writableSelf = this.getWritable();\n    const writableSelfKey = writableSelf.__key;\n    const nodesToInsertKeys = [];\n    const nodesToRemoveKeys = [];\n    const nodeAfterRange = this.getChildAtIndex(start + deleteCount);\n    let nodeBeforeRange = null;\n    let newSize = oldSize - deleteCount + nodesToInsertLength;\n    if (start !== 0) {\n      if (start === oldSize) {\n        nodeBeforeRange = this.getLastChild();\n      } else {\n        const node = this.getChildAtIndex(start);\n        if (node !== null) {\n          nodeBeforeRange = node.getPreviousSibling();\n        }\n      }\n    }\n    if (deleteCount > 0) {\n      let nodeToDelete = nodeBeforeRange === null ? this.getFirstChild() : nodeBeforeRange.getNextSibling();\n      for (let i = 0; i < deleteCount; i++) {\n        if (nodeToDelete === null) {\n          {\n            throw Error(`splice: sibling not found`);\n          }\n        }\n        const nextSibling = nodeToDelete.getNextSibling();\n        const nodeKeyToDelete = nodeToDelete.__key;\n        const writableNodeToDelete = nodeToDelete.getWritable();\n        removeFromParent(writableNodeToDelete);\n        nodesToRemoveKeys.push(nodeKeyToDelete);\n        nodeToDelete = nextSibling;\n      }\n    }\n    let prevNode = nodeBeforeRange;\n    for (let i = 0; i < nodesToInsertLength; i++) {\n      const nodeToInsert = nodesToInsert[i];\n      if (prevNode !== null && nodeToInsert.is(prevNode)) {\n        nodeBeforeRange = prevNode = prevNode.getPreviousSibling();\n      }\n      const writableNodeToInsert = nodeToInsert.getWritable();\n      if (writableNodeToInsert.__parent === writableSelfKey) {\n        newSize--;\n      }\n      removeFromParent(writableNodeToInsert);\n      const nodeKeyToInsert = nodeToInsert.__key;\n      if (prevNode === null) {\n        writableSelf.__first = nodeKeyToInsert;\n        writableNodeToInsert.__prev = null;\n      } else {\n        const writablePrevNode = prevNode.getWritable();\n        writablePrevNode.__next = nodeKeyToInsert;\n        writableNodeToInsert.__prev = writablePrevNode.__key;\n      }\n      if (nodeToInsert.__key === writableSelfKey) {\n        {\n          throw Error(`append: attempting to append self`);\n        }\n      }\n      // Set child parent to self\n      writableNodeToInsert.__parent = writableSelfKey;\n      nodesToInsertKeys.push(nodeKeyToInsert);\n      prevNode = nodeToInsert;\n    }\n    if (start + deleteCount === oldSize) {\n      if (prevNode !== null) {\n        const writablePrevNode = prevNode.getWritable();\n        writablePrevNode.__next = null;\n        writableSelf.__last = prevNode.__key;\n      }\n    } else if (nodeAfterRange !== null) {\n      const writableNodeAfterRange = nodeAfterRange.getWritable();\n      if (prevNode !== null) {\n        const writablePrevNode = prevNode.getWritable();\n        writableNodeAfterRange.__prev = prevNode.__key;\n        writablePrevNode.__next = nodeAfterRange.__key;\n      } else {\n        writableNodeAfterRange.__prev = null;\n      }\n    }\n    writableSelf.__size = newSize;\n\n    // In case of deletion we need to adjust selection, unlink removed nodes\n    // and clean up node itself if it becomes empty. None of these needed\n    // for insertion-only cases\n    if (nodesToRemoveKeys.length) {\n      // Adjusting selection, in case node that was anchor/focus will be deleted\n      const selection = $getSelection();\n      if ($isRangeSelection(selection)) {\n        const nodesToRemoveKeySet = new Set(nodesToRemoveKeys);\n        const nodesToInsertKeySet = new Set(nodesToInsertKeys);\n        const {\n          anchor,\n          focus\n        } = selection;\n        if (isPointRemoved(anchor, nodesToRemoveKeySet, nodesToInsertKeySet)) {\n          moveSelectionPointToSibling(anchor, anchor.getNode(), this, nodeBeforeRange, nodeAfterRange);\n        }\n        if (isPointRemoved(focus, nodesToRemoveKeySet, nodesToInsertKeySet)) {\n          moveSelectionPointToSibling(focus, focus.getNode(), this, nodeBeforeRange, nodeAfterRange);\n        }\n        // Cleanup if node can't be empty\n        if (newSize === 0 && !this.canBeEmpty() && !$isRootOrShadowRoot(this)) {\n          this.remove();\n        }\n      }\n    }\n    return writableSelf;\n  }\n  // JSON serialization\n  exportJSON() {\n    return {\n      children: [],\n      direction: this.getDirection(),\n      format: this.getFormatType(),\n      indent: this.getIndent(),\n      type: 'element',\n      version: 1\n    };\n  }\n  // These are intended to be extends for specific element heuristics.\n  insertNewAfter(selection, restoreSelection) {\n    return null;\n  }\n  canIndent() {\n    return true;\n  }\n  /*\n   * This method controls the behavior of a the node during backwards\n   * deletion (i.e., backspace) when selection is at the beginning of\n   * the node (offset 0)\n   */\n  collapseAtStart(selection) {\n    return false;\n  }\n  excludeFromCopy(destination) {\n    return false;\n  }\n  canReplaceWith(replacement) {\n    return true;\n  }\n  canInsertAfter(node) {\n    return true;\n  }\n  canBeEmpty() {\n    return true;\n  }\n  canInsertTextBefore() {\n    return true;\n  }\n  canInsertTextAfter() {\n    return true;\n  }\n  isInline() {\n    return false;\n  }\n  // A shadow root is a Node that behaves like RootNode. The shadow root (and RootNode) mark the\n  // end of the hiercharchy, most implementations should treat it as there's nothing (upwards)\n  // beyond this point. For example, node.getTopLevelElement(), when performed inside a TableCellNode\n  // will return the immediate first child underneath TableCellNode instead of RootNode.\n  isShadowRoot() {\n    return false;\n  }\n  canMergeWith(node) {\n    return false;\n  }\n  extractWithChild(child, selection, destination) {\n    return false;\n  }\n}\nfunction $isElementNode(node) {\n  return node instanceof ElementNode;\n}\nfunction isPointRemoved(point, nodesToRemoveKeySet, nodesToInsertKeySet) {\n  let node = point.getNode();\n  while (node) {\n    const nodeKey = node.__key;\n    if (nodesToRemoveKeySet.has(nodeKey) && !nodesToInsertKeySet.has(nodeKey)) {\n      return true;\n    }\n    node = node.getParent();\n  }\n  return false;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/** @noInheritDoc */\nclass RootNode extends ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'root';\n  }\n  static clone() {\n    return new RootNode();\n  }\n  constructor() {\n    super('root');\n    this.__cachedText = null;\n  }\n  getTopLevelElementOrThrow() {\n    {\n      throw Error(`getTopLevelElementOrThrow: root nodes are not top level elements`);\n    }\n  }\n  getTextContent() {\n    const cachedText = this.__cachedText;\n    if (isCurrentlyReadOnlyMode() || getActiveEditor()._dirtyType === NO_DIRTY_NODES) {\n      if (cachedText !== null) {\n        return cachedText;\n      }\n    }\n    return super.getTextContent();\n  }\n  remove() {\n    {\n      throw Error(`remove: cannot be called on root nodes`);\n    }\n  }\n  replace(node) {\n    {\n      throw Error(`replace: cannot be called on root nodes`);\n    }\n  }\n  insertBefore(nodeToInsert) {\n    {\n      throw Error(`insertBefore: cannot be called on root nodes`);\n    }\n  }\n  insertAfter(nodeToInsert) {\n    {\n      throw Error(`insertAfter: cannot be called on root nodes`);\n    }\n  }\n\n  // View\n\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n\n  // Mutate\n\n  append(...nodesToAppend) {\n    for (let i = 0; i < nodesToAppend.length; i++) {\n      const node = nodesToAppend[i];\n      if (!$isElementNode(node) && !$isDecoratorNode(node)) {\n        {\n          throw Error(`rootNode.append: Only element or decorator nodes can be appended to the root node`);\n        }\n      }\n    }\n    return super.append(...nodesToAppend);\n  }\n  static importJSON(serializedNode) {\n    // We don't create a root, and instead use the existing root.\n    const node = $getRoot();\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      children: [],\n      direction: this.getDirection(),\n      format: this.getFormatType(),\n      indent: this.getIndent(),\n      type: 'root',\n      version: 1\n    };\n  }\n  collapseAtStart() {\n    return true;\n  }\n}\nfunction $createRootNode() {\n  return new RootNode();\n}\nfunction $isRootNode(node) {\n  return node instanceof RootNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction editorStateHasDirtySelection(editorState, editor) {\n  const currentSelection = editor.getEditorState()._selection;\n  const pendingSelection = editorState._selection;\n\n  // Check if we need to update because of changes in selection\n  if (pendingSelection !== null) {\n    if (pendingSelection.dirty || !pendingSelection.is(currentSelection)) {\n      return true;\n    }\n  } else if (currentSelection !== null) {\n    return true;\n  }\n  return false;\n}\nfunction cloneEditorState(current) {\n  return new EditorState(new Map(current._nodeMap));\n}\nfunction createEmptyEditorState() {\n  return new EditorState(new Map([['root', $createRootNode()]]));\n}\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor;\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not match the serialized type. Check if .exportJSON() is implemented and it is returning the correct type.`);\n    }\n  }\n  if ($isElementNode(node)) {\n    const serializedChildren = serializedNode.children;\n    if (!Array.isArray(serializedChildren)) {\n      {\n        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n    const children = node.getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      const serializedChildNode = exportNodeToJSON(child);\n      serializedChildren.push(serializedChildNode);\n    }\n  }\n\n  // @ts-expect-error\n  return serializedNode;\n}\nclass EditorState {\n  constructor(nodeMap, selection) {\n    this._nodeMap = nodeMap;\n    this._selection = selection || null;\n    this._flushSync = false;\n    this._readOnly = false;\n  }\n  isEmpty() {\n    return this._nodeMap.size === 1 && this._selection === null;\n  }\n  read(callbackFn) {\n    return readEditorState(this, callbackFn);\n  }\n  clone(selection) {\n    const editorState = new EditorState(this._nodeMap, selection === undefined ? this._selection : selection);\n    editorState._readOnly = true;\n    return editorState;\n  }\n  toJSON() {\n    return readEditorState(this, () => ({\n      root: exportNodeToJSON($getRoot())\n    }));\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/** @noInheritDoc */\nclass ParagraphNode extends ElementNode {\n  static getType() {\n    return 'paragraph';\n  }\n  static clone(node) {\n    return new ParagraphNode(node.__key);\n  }\n\n  // View\n\n  createDOM(config) {\n    const dom = document.createElement('p');\n    const classNames = getCachedClassNameArray(config.theme, 'paragraph');\n    if (classNames !== undefined) {\n      const domClassList = dom.classList;\n      domClassList.add(...classNames);\n    }\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    return false;\n  }\n  static importDOM() {\n    return {\n      p: node => ({\n        conversion: convertParagraphElement,\n        priority: 0\n      })\n    };\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (element && isHTMLElement(element)) {\n      if (this.isEmpty()) {\n        element.append(document.createElement('br'));\n      }\n      const formatType = this.getFormatType();\n      element.style.textAlign = formatType;\n      const direction = this.getDirection();\n      if (direction) {\n        element.dir = direction;\n      }\n      const indent = this.getIndent();\n      if (indent > 0) {\n        // padding-inline-start is not widely supported in email HTML, but\n        // Lexical Reconciler uses padding-inline-start. Using text-indent instead.\n        element.style.textIndent = `${indent * 20}px`;\n      }\n    }\n    return {\n      element\n    };\n  }\n  static importJSON(serializedNode) {\n    const node = $createParagraphNode();\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      type: 'paragraph',\n      version: 1\n    };\n  }\n\n  // Mutation\n\n  insertNewAfter(_, restoreSelection) {\n    const newElement = $createParagraphNode();\n    const direction = this.getDirection();\n    newElement.setDirection(direction);\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n  collapseAtStart() {\n    const children = this.getChildren();\n    // If we have an empty (trimmed) first paragraph and try and remove it,\n    // delete the paragraph as long as we have another sibling to go to\n    if (children.length === 0 || $isTextNode(children[0]) && children[0].getTextContent().trim() === '') {\n      const nextSibling = this.getNextSibling();\n      if (nextSibling !== null) {\n        this.selectNext();\n        this.remove();\n        return true;\n      }\n      const prevSibling = this.getPreviousSibling();\n      if (prevSibling !== null) {\n        this.selectPrevious();\n        this.remove();\n        return true;\n      }\n    }\n    return false;\n  }\n}\nfunction convertParagraphElement(element) {\n  const node = $createParagraphNode();\n  if (element.style) {\n    node.setFormat(element.style.textAlign);\n    const indent = parseInt(element.style.textIndent, 10) / 20;\n    if (indent > 0) {\n      node.setIndent(indent);\n    }\n  }\n  return {\n    node\n  };\n}\nfunction $createParagraphNode() {\n  return $applyNodeReplacement(new ParagraphNode());\n}\nfunction $isParagraphNode(node) {\n  return node instanceof ParagraphNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// https://github.com/microsoft/TypeScript/issues/3841\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst COMMAND_PRIORITY_EDITOR = 0;\nconst COMMAND_PRIORITY_LOW = 1;\nconst COMMAND_PRIORITY_NORMAL = 2;\nconst COMMAND_PRIORITY_HIGH = 3;\nconst COMMAND_PRIORITY_CRITICAL = 4;\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n/**\n * Type helper for extracting the payload type from a command.\n *\n * @example\n * ```ts\n * const MY_COMMAND = createCommand<SomeType>();\n *\n * // ...\n *\n * editor.registerCommand(MY_COMMAND, payload => {\n *   // Type of `payload` is inferred here. But lets say we want to extract a function to delegate to\n *   handleMyCommand(editor, payload);\n *   return true;\n * });\n *\n * function handleMyCommand(editor: LexicalEditor, payload: CommandPayloadType<typeof MY_COMMAND>) {\n *   // `payload` is of type `SomeType`, extracted from the command.\n * }\n * ```\n */\n\nfunction resetEditor(editor, prevRootElement, nextRootElement, pendingEditorState) {\n  const keyNodeMap = editor._keyToDOMMap;\n  keyNodeMap.clear();\n  editor._editorState = createEmptyEditorState();\n  editor._pendingEditorState = pendingEditorState;\n  editor._compositionKey = null;\n  editor._dirtyType = NO_DIRTY_NODES;\n  editor._cloneNotNeeded.clear();\n  editor._dirtyLeaves = new Set();\n  editor._dirtyElements.clear();\n  editor._normalizedNodes = new Set();\n  editor._updateTags = new Set();\n  editor._updates = [];\n  editor._blockCursorElement = null;\n  const observer = editor._observer;\n  if (observer !== null) {\n    observer.disconnect();\n    editor._observer = null;\n  }\n\n  // Remove all the DOM nodes from the root element\n  if (prevRootElement !== null) {\n    prevRootElement.textContent = '';\n  }\n  if (nextRootElement !== null) {\n    nextRootElement.textContent = '';\n    keyNodeMap.set('root', nextRootElement);\n  }\n}\nfunction initializeConversionCache(nodes, additionalConversions) {\n  const conversionCache = new Map();\n  const handledConversions = new Set();\n  const addConversionsToCache = map => {\n    Object.keys(map).forEach(key => {\n      let currentCache = conversionCache.get(key);\n      if (currentCache === undefined) {\n        currentCache = [];\n        conversionCache.set(key, currentCache);\n      }\n      currentCache.push(map[key]);\n    });\n  };\n  nodes.forEach(node => {\n    const importDOM = node.klass.importDOM;\n    if (importDOM == null || handledConversions.has(importDOM)) {\n      return;\n    }\n    handledConversions.add(importDOM);\n    const map = importDOM.call(node.klass);\n    if (map !== null) {\n      addConversionsToCache(map);\n    }\n  });\n  if (additionalConversions) {\n    addConversionsToCache(additionalConversions);\n  }\n  return conversionCache;\n}\n\n/**\n * Creates a new LexicalEditor attached to a single contentEditable (provided in the config). This is\n * the lowest-level initialization API for a LexicalEditor. If you're using React or another framework,\n * consider using the appropriate abstractions, such as LexicalComposer\n * @param editorConfig - the editor configuration.\n * @returns a LexicalEditor instance\n */\nfunction createEditor(editorConfig) {\n  const config = editorConfig || {};\n  const activeEditor = internalGetActiveEditor();\n  const theme = config.theme || {};\n  const parentEditor = editorConfig === undefined ? activeEditor : config.parentEditor || null;\n  const disableEvents = config.disableEvents || false;\n  const editorState = createEmptyEditorState();\n  const namespace = config.namespace || (parentEditor !== null ? parentEditor._config.namespace : createUID());\n  const initialEditorState = config.editorState;\n  const nodes = [RootNode, TextNode, LineBreakNode, TabNode, ParagraphNode, ...(config.nodes || [])];\n  const {\n    onError,\n    html\n  } = config;\n  const isEditable = config.editable !== undefined ? config.editable : true;\n  let registeredNodes;\n  if (editorConfig === undefined && activeEditor !== null) {\n    registeredNodes = activeEditor._nodes;\n  } else {\n    registeredNodes = new Map();\n    for (let i = 0; i < nodes.length; i++) {\n      let klass = nodes[i];\n      let replace = null;\n      let replaceWithKlass = null;\n      if (typeof klass !== 'function') {\n        const options = klass;\n        klass = options.replace;\n        replace = options.with;\n        replaceWithKlass = options.withKlass || null;\n      }\n      // Ensure custom nodes implement required methods.\n      {\n        const name = klass.name;\n        if (name !== 'RootNode') {\n          const proto = klass.prototype;\n          ['getType', 'clone'].forEach(method => {\n            // eslint-disable-next-line no-prototype-builtins\n            if (!klass.hasOwnProperty(method)) {\n              console.warn(`${name} must implement static \"${method}\" method`);\n            }\n          });\n          if (\n          // eslint-disable-next-line no-prototype-builtins\n          !klass.hasOwnProperty('importDOM') &&\n          // eslint-disable-next-line no-prototype-builtins\n          klass.hasOwnProperty('exportDOM')) {\n            console.warn(`${name} should implement \"importDOM\" if using a custom \"exportDOM\" method to ensure HTML serialization (important for copy & paste) works as expected`);\n          }\n          if (proto instanceof DecoratorNode) {\n            // eslint-disable-next-line no-prototype-builtins\n            if (!proto.hasOwnProperty('decorate')) {\n              console.warn(`${proto.constructor.name} must implement \"decorate\" method`);\n            }\n          }\n          if (\n          // eslint-disable-next-line no-prototype-builtins\n          !klass.hasOwnProperty('importJSON')) {\n            console.warn(`${name} should implement \"importJSON\" method to ensure JSON and default HTML serialization works as expected`);\n          }\n          if (\n          // eslint-disable-next-line no-prototype-builtins\n          !proto.hasOwnProperty('exportJSON')) {\n            console.warn(`${name} should implement \"exportJSON\" method to ensure JSON and default HTML serialization works as expected`);\n          }\n        }\n      }\n      const type = klass.getType();\n      const transform = klass.transform();\n      const transforms = new Set();\n      if (transform !== null) {\n        transforms.add(transform);\n      }\n      registeredNodes.set(type, {\n        exportDOM: html && html.export ? html.export.get(klass) : undefined,\n        klass,\n        replace,\n        replaceWithKlass,\n        transforms\n      });\n    }\n  }\n  const editor = new LexicalEditor(editorState, parentEditor, registeredNodes, {\n    disableEvents,\n    namespace,\n    theme\n  }, onError ? onError : console.error, initializeConversionCache(registeredNodes, html ? html.import : undefined), isEditable);\n  if (initialEditorState !== undefined) {\n    editor._pendingEditorState = initialEditorState;\n    editor._dirtyType = FULL_RECONCILE;\n  }\n  return editor;\n}\nclass LexicalEditor {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  constructor(editorState, parentEditor, nodes, config, onError, htmlConversions, editable) {\n    this._parentEditor = parentEditor;\n    // The root element associated with this editor\n    this._rootElement = null;\n    // The current editor state\n    this._editorState = editorState;\n    // Handling of drafts and updates\n    this._pendingEditorState = null;\n    // Used to help co-ordinate selection and events\n    this._compositionKey = null;\n    this._deferred = [];\n    // Used during reconciliation\n    this._keyToDOMMap = new Map();\n    this._updates = [];\n    this._updating = false;\n    // Listeners\n    this._listeners = {\n      decorator: new Set(),\n      editable: new Set(),\n      mutation: new Map(),\n      root: new Set(),\n      textcontent: new Set(),\n      update: new Set()\n    };\n    // Commands\n    this._commands = new Map();\n    // Editor configuration for theme/context.\n    this._config = config;\n    // Mapping of types to their nodes\n    this._nodes = nodes;\n    // React node decorators for portals\n    this._decorators = {};\n    this._pendingDecorators = null;\n    // Used to optimize reconciliation\n    this._dirtyType = NO_DIRTY_NODES;\n    this._cloneNotNeeded = new Set();\n    this._dirtyLeaves = new Set();\n    this._dirtyElements = new Map();\n    this._normalizedNodes = new Set();\n    this._updateTags = new Set();\n    // Handling of DOM mutations\n    this._observer = null;\n    // Used for identifying owning editors\n    this._key = createUID();\n    this._onError = onError;\n    this._htmlConversions = htmlConversions;\n    this._editable = editable;\n    this._headless = parentEditor !== null && parentEditor._headless;\n    this._window = null;\n    this._blockCursorElement = null;\n  }\n\n  /**\n   *\n   * @returns true if the editor is currently in \"composition\" mode due to receiving input\n   * through an IME, or 3P extension, for example. Returns false otherwise.\n   */\n  isComposing() {\n    return this._compositionKey != null;\n  }\n  /**\n   * Registers a listener for Editor update event. Will trigger the provided callback\n   * each time the editor goes through an update (via {@link LexicalEditor.update}) until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerUpdateListener(listener) {\n    const listenerSetOrMap = this._listeners.update;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for for when the editor changes between editable and non-editable states.\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerEditableListener(listener) {\n    const listenerSetOrMap = this._listeners.editable;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for when the editor's decorator object changes. The decorator object contains\n   * all DecoratorNode keys -> their decorated value. This is primarily used with external UI frameworks.\n   *\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerDecoratorListener(listener) {\n    const listenerSetOrMap = this._listeners.decorator;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for when Lexical commits an update to the DOM and the text content of\n   * the editor changes from the previous state of the editor. If the text content is the\n   * same between updates, no notifications to the listeners will happen.\n   *\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerTextContentListener(listener) {\n    const listenerSetOrMap = this._listeners.textcontent;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for when the editor's root DOM element (the content editable\n   * Lexical attaches to) changes. This is primarily used to attach event listeners to the root\n   *  element. The root listener function is executed directly upon registration and then on\n   * any subsequent update.\n   *\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerRootListener(listener) {\n    const listenerSetOrMap = this._listeners.root;\n    listener(this._rootElement, null);\n    listenerSetOrMap.add(listener);\n    return () => {\n      listener(null, this._rootElement);\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener that will trigger anytime the provided command\n   * is dispatched, subject to priority. Listeners that run at a higher priority can \"intercept\"\n   * commands and prevent them from propagating to other handlers by returning true.\n   *\n   * Listeners registered at the same priority level will run deterministically in the order of registration.\n   *\n   * @param command - the command that will trigger the callback.\n   * @param listener - the function that will execute when the command is dispatched.\n   * @param priority - the relative priority of the listener. 0 | 1 | 2 | 3 | 4\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerCommand(command, listener, priority) {\n    if (priority === undefined) {\n      {\n        throw Error(`Listener for type \"command\" requires a \"priority\".`);\n      }\n    }\n    const commandsMap = this._commands;\n    if (!commandsMap.has(command)) {\n      commandsMap.set(command, [new Set(), new Set(), new Set(), new Set(), new Set()]);\n    }\n    const listenersInPriorityOrder = commandsMap.get(command);\n    if (listenersInPriorityOrder === undefined) {\n      {\n        throw Error(`registerCommand: Command ${String(command)} not found in command map`);\n      }\n    }\n    const listeners = listenersInPriorityOrder[priority];\n    listeners.add(listener);\n    return () => {\n      listeners.delete(listener);\n      if (listenersInPriorityOrder.every(listenersSet => listenersSet.size === 0)) {\n        commandsMap.delete(command);\n      }\n    };\n  }\n\n  /**\n   * Registers a listener that will run when a Lexical node of the provided class is\n   * mutated. The listener will receive a list of nodes along with the type of mutation\n   * that was performed on each: created, destroyed, or updated.\n   *\n   * One common use case for this is to attach DOM event listeners to the underlying DOM nodes as Lexical nodes are created.\n   * {@link LexicalEditor.getElementByKey} can be used for this.\n   *\n   * @param klass - The class of the node that you want to listen to mutations on.\n   * @param listener - The logic you want to run when the node is mutated.\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerMutationListener(klass, listener) {\n    const registeredNode = this._nodes.get(klass.getType());\n    if (registeredNode === undefined) {\n      {\n        throw Error(`Node ${klass.name} has not been registered. Ensure node has been passed to createEditor.`);\n      }\n    }\n    const mutations = this._listeners.mutation;\n    mutations.set(listener, klass);\n    return () => {\n      mutations.delete(listener);\n    };\n  }\n\n  /** @internal */\n  registerNodeTransformToKlass(klass, listener) {\n    const type = klass.getType();\n    const registeredNode = this._nodes.get(type);\n    if (registeredNode === undefined) {\n      {\n        throw Error(`Node ${klass.name} has not been registered. Ensure node has been passed to createEditor.`);\n      }\n    }\n    const transforms = registeredNode.transforms;\n    transforms.add(listener);\n    return registeredNode;\n  }\n\n  /**\n   * Registers a listener that will run when a Lexical node of the provided class is\n   * marked dirty during an update. The listener will continue to run as long as the node\n   * is marked dirty. There are no guarantees around the order of transform execution!\n   *\n   * Watch out for infinite loops. See [Node Transforms](https://lexical.dev/docs/concepts/transforms)\n   * @param klass - The class of the node that you want to run transforms on.\n   * @param listener - The logic you want to run when the node is updated.\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerNodeTransform(klass, listener) {\n    const registeredNode = this.registerNodeTransformToKlass(klass, listener);\n    const registeredNodes = [registeredNode];\n    const replaceWithKlass = registeredNode.replaceWithKlass;\n    if (replaceWithKlass != null) {\n      const registeredReplaceWithNode = this.registerNodeTransformToKlass(replaceWithKlass, listener);\n      registeredNodes.push(registeredReplaceWithNode);\n    }\n    markAllNodesAsDirty(this, klass.getType());\n    return () => {\n      registeredNodes.forEach(node => node.transforms.delete(listener));\n    };\n  }\n\n  /**\n   * Used to assert that a certain node is registered, usually by plugins to ensure nodes that they\n   * depend on have been registered.\n   * @returns True if the editor has registered the provided node type, false otherwise.\n   */\n  hasNode(node) {\n    return this._nodes.has(node.getType());\n  }\n\n  /**\n   * Used to assert that certain nodes are registered, usually by plugins to ensure nodes that they\n   * depend on have been registered.\n   * @returns True if the editor has registered all of the provided node types, false otherwise.\n   */\n  hasNodes(nodes) {\n    return nodes.every(this.hasNode.bind(this));\n  }\n\n  /**\n   * Dispatches a command of the specified type with the specified payload.\n   * This triggers all command listeners (set by {@link LexicalEditor.registerCommand})\n   * for this type, passing them the provided payload.\n   * @param type - the type of command listeners to trigger.\n   * @param payload - the data to pass as an argument to the command listeners.\n   */\n  dispatchCommand(type, payload) {\n    return dispatchCommand(this, type, payload);\n  }\n\n  /**\n   * Gets a map of all decorators in the editor.\n   * @returns A mapping of call decorator keys to their decorated content\n   */\n  getDecorators() {\n    return this._decorators;\n  }\n\n  /**\n   *\n   * @returns the current root element of the editor. If you want to register\n   * an event listener, do it via {@link LexicalEditor.registerRootListener}, since\n   * this reference may not be stable.\n   */\n  getRootElement() {\n    return this._rootElement;\n  }\n\n  /**\n   * Gets the key of the editor\n   * @returns The editor key\n   */\n  getKey() {\n    return this._key;\n  }\n\n  /**\n   * Imperatively set the root contenteditable element that Lexical listens\n   * for events on.\n   */\n  setRootElement(nextRootElement) {\n    const prevRootElement = this._rootElement;\n    if (nextRootElement !== prevRootElement) {\n      const classNames = getCachedClassNameArray(this._config.theme, 'root');\n      const pendingEditorState = this._pendingEditorState || this._editorState;\n      this._rootElement = nextRootElement;\n      resetEditor(this, prevRootElement, nextRootElement, pendingEditorState);\n      if (prevRootElement !== null) {\n        // TODO: remove this flag once we no longer use UEv2 internally\n        if (!this._config.disableEvents) {\n          removeRootElementEvents(prevRootElement);\n        }\n        if (classNames != null) {\n          prevRootElement.classList.remove(...classNames);\n        }\n      }\n      if (nextRootElement !== null) {\n        const windowObj = getDefaultView(nextRootElement);\n        const style = nextRootElement.style;\n        style.userSelect = 'text';\n        style.whiteSpace = 'pre-wrap';\n        style.wordBreak = 'break-word';\n        nextRootElement.setAttribute('data-lexical-editor', 'true');\n        this._window = windowObj;\n        this._dirtyType = FULL_RECONCILE;\n        initMutationObserver(this);\n        this._updateTags.add('history-merge');\n        commitPendingUpdates(this);\n\n        // TODO: remove this flag once we no longer use UEv2 internally\n        if (!this._config.disableEvents) {\n          addRootElementEvents(nextRootElement, this);\n        }\n        if (classNames != null) {\n          nextRootElement.classList.add(...classNames);\n        }\n      } else {\n        // If content editable is unmounted we'll reset editor state back to original\n        // (or pending) editor state since there will be no reconciliation\n        this._editorState = pendingEditorState;\n        this._pendingEditorState = null;\n        this._window = null;\n      }\n      triggerListeners('root', this, false, nextRootElement, prevRootElement);\n    }\n  }\n\n  /**\n   * Gets the underlying HTMLElement associated with the LexicalNode for the given key.\n   * @returns the HTMLElement rendered by the LexicalNode associated with the key.\n   * @param key - the key of the LexicalNode.\n   */\n  getElementByKey(key) {\n    return this._keyToDOMMap.get(key) || null;\n  }\n\n  /**\n   * Gets the active editor state.\n   * @returns The editor state\n   */\n  getEditorState() {\n    return this._editorState;\n  }\n\n  /**\n   * Imperatively set the EditorState. Triggers reconciliation like an update.\n   * @param editorState - the state to set the editor\n   * @param options - options for the update.\n   */\n  setEditorState(editorState, options) {\n    if (editorState.isEmpty()) {\n      {\n        throw Error(`setEditorState: the editor state is empty. Ensure the editor state's root node never becomes empty.`);\n      }\n    }\n    flushRootMutations(this);\n    const pendingEditorState = this._pendingEditorState;\n    const tags = this._updateTags;\n    const tag = options !== undefined ? options.tag : null;\n    if (pendingEditorState !== null && !pendingEditorState.isEmpty()) {\n      if (tag != null) {\n        tags.add(tag);\n      }\n      commitPendingUpdates(this);\n    }\n    this._pendingEditorState = editorState;\n    this._dirtyType = FULL_RECONCILE;\n    this._dirtyElements.set('root', false);\n    this._compositionKey = null;\n    if (tag != null) {\n      tags.add(tag);\n    }\n    commitPendingUpdates(this);\n  }\n\n  /**\n   * Parses a SerializedEditorState (usually produced by {@link EditorState.toJSON}) and returns\n   * and EditorState object that can be, for example, passed to {@link LexicalEditor.setEditorState}. Typically,\n   * deserliazation from JSON stored in a database uses this method.\n   * @param maybeStringifiedEditorState\n   * @param updateFn\n   * @returns\n   */\n  parseEditorState(maybeStringifiedEditorState, updateFn) {\n    const serializedEditorState = typeof maybeStringifiedEditorState === 'string' ? JSON.parse(maybeStringifiedEditorState) : maybeStringifiedEditorState;\n    return parseEditorState(serializedEditorState, this, updateFn);\n  }\n\n  /**\n   * Executes an update to the editor state. The updateFn callback is the ONLY place\n   * where Lexical editor state can be safely mutated.\n   * @param updateFn - A function that has access to writable editor state.\n   * @param options - A bag of options to control the behavior of the update.\n   * @param options.onUpdate - A function to run once the update is complete.\n   * Useful for synchronizing updates in some cases.\n   * @param options.skipTransforms - Setting this to true will suppress all node\n   * transforms for this update cycle.\n   * @param options.tag - A tag to identify this update, in an update listener, for instance.\n   * Some tags are reserved by the core and control update behavior in different ways.\n   * @param options.discrete - If true, prevents this update from being batched, forcing it to\n   * run synchronously.\n   */\n  update(updateFn, options) {\n    updateEditor(this, updateFn, options);\n  }\n\n  /**\n   * Focuses the editor\n   * @param callbackFn - A function to run after the editor is focused.\n   * @param options - A bag of options\n   * @param options.defaultSelection - Where to move selection when the editor is\n   * focused. Can be rootStart, rootEnd, or undefined. Defaults to rootEnd.\n   */\n  focus(callbackFn, options = {}) {\n    const rootElement = this._rootElement;\n    if (rootElement !== null) {\n      // This ensures that iOS does not trigger caps lock upon focus\n      rootElement.setAttribute('autocapitalize', 'off');\n      updateEditor(this, () => {\n        const selection = $getSelection();\n        const root = $getRoot();\n        if (selection !== null) {\n          // Marking the selection dirty will force the selection back to it\n          selection.dirty = true;\n        } else if (root.getChildrenSize() !== 0) {\n          if (options.defaultSelection === 'rootStart') {\n            root.selectStart();\n          } else {\n            root.selectEnd();\n          }\n        }\n      }, {\n        onUpdate: () => {\n          rootElement.removeAttribute('autocapitalize');\n          if (callbackFn) {\n            callbackFn();\n          }\n        },\n        tag: 'focus'\n      });\n      // In the case where onUpdate doesn't fire (due to the focus update not\n      // occuring).\n      if (this._pendingEditorState === null) {\n        rootElement.removeAttribute('autocapitalize');\n      }\n    }\n  }\n\n  /**\n   * Removes focus from the editor.\n   */\n  blur() {\n    const rootElement = this._rootElement;\n    if (rootElement !== null) {\n      rootElement.blur();\n    }\n    const domSelection = getDOMSelection(this._window);\n    if (domSelection !== null) {\n      domSelection.removeAllRanges();\n    }\n  }\n  /**\n   * Returns true if the editor is editable, false otherwise.\n   * @returns True if the editor is editable, false otherwise.\n   */\n  isEditable() {\n    return this._editable;\n  }\n  /**\n   * Sets the editable property of the editor. When false, the\n   * editor will not listen for user events on the underling contenteditable.\n   * @param editable - the value to set the editable mode to.\n   */\n  setEditable(editable) {\n    if (this._editable !== editable) {\n      this._editable = editable;\n      triggerListeners('editable', this, true, editable);\n    }\n  }\n  /**\n   * Returns a JSON-serializable javascript object NOT a JSON string.\n   * You still must call JSON.stringify (or something else) to turn the\n   * state into a string you can transfer over the wire and store in a database.\n   *\n   * See {@link LexicalNode.exportJSON}\n   *\n   * @returns A JSON-serializable javascript object\n   */\n  toJSON() {\n    return {\n      editorState: this._editorState.toJSON()\n    };\n  }\n}\n\nexport { $addUpdateTag, $applyNodeReplacement, $copyNode, $createLineBreakNode, $createNodeSelection, $createParagraphNode, $createPoint, $createRangeSelection, $createTabNode, $createTextNode, $getAdjacentNode, $getCharacterOffsets, $getEditor, $getNearestNodeFromDOMNode, $getNearestRootOrShadowRoot, $getNodeByKey, $getPreviousSelection, $getRoot, $getSelection, $getTextContent, $hasAncestor, $hasUpdateTag, $insertNodes, $isBlockElementNode, $isDecoratorNode, $isElementNode, $isInlineElementOrDecoratorNode, $isLeafNode, $isLineBreakNode, $isNodeSelection, $isParagraphNode, $isRangeSelection, $isRootNode, $isRootOrShadowRoot, $isTabNode, $isTextNode, $nodesOfType, $normalizeSelection as $normalizeSelection__EXPERIMENTAL, $parseSerializedNode, $selectAll, $setCompositionKey, $setSelection, $splitNode, BLUR_COMMAND, CAN_REDO_COMMAND, CAN_UNDO_COMMAND, CLEAR_EDITOR_COMMAND, CLEAR_HISTORY_COMMAND, CLICK_COMMAND, COMMAND_PRIORITY_CRITICAL, COMMAND_PRIORITY_EDITOR, COMMAND_PRIORITY_HIGH, COMMAND_PRIORITY_LOW, COMMAND_PRIORITY_NORMAL, CONTROLLED_TEXT_INSERTION_COMMAND, COPY_COMMAND, CUT_COMMAND, DELETE_CHARACTER_COMMAND, DELETE_LINE_COMMAND, DELETE_WORD_COMMAND, DRAGEND_COMMAND, DRAGOVER_COMMAND, DRAGSTART_COMMAND, DROP_COMMAND, DecoratorNode, ElementNode, FOCUS_COMMAND, FORMAT_ELEMENT_COMMAND, FORMAT_TEXT_COMMAND, INDENT_CONTENT_COMMAND, INSERT_LINE_BREAK_COMMAND, INSERT_PARAGRAPH_COMMAND, INSERT_TAB_COMMAND, KEY_ARROW_DOWN_COMMAND, KEY_ARROW_LEFT_COMMAND, KEY_ARROW_RIGHT_COMMAND, KEY_ARROW_UP_COMMAND, KEY_BACKSPACE_COMMAND, KEY_DELETE_COMMAND, KEY_DOWN_COMMAND, KEY_ENTER_COMMAND, KEY_ESCAPE_COMMAND, KEY_MODIFIER_COMMAND, KEY_SPACE_COMMAND, KEY_TAB_COMMAND, LineBreakNode, MOVE_TO_END, MOVE_TO_START, OUTDENT_CONTENT_COMMAND, PASTE_COMMAND, ParagraphNode, REDO_COMMAND, REMOVE_TEXT_COMMAND, RootNode, SELECTION_CHANGE_COMMAND, SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, SELECT_ALL_COMMAND, TabNode, TextNode, UNDO_COMMAND, createCommand, createEditor, getNearestEditorFromDOMNode, isCurrentlyReadOnlyMode, isHTMLAnchorElement, isHTMLElement, isSelectionCapturedInDecoratorInput, isSelectionWithinEditor };\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nfunction e(e){return{}}const t={},n={},r={},i={},s={},o={},l={},c={},u={},a={},f={},d={},h={},g={},_={},p={},y={},m={},x={},v={},T={},S={},k={},C={},b={},N={},w={},E={},P={},D={},I={},O={},A={},L={},F={},M={},W={},z={},B={},R={},K={},J={},U={},V={},$={};var H=function(e){const t=new URLSearchParams;t.append(\"code\",e);for(let e=1;e<arguments.length;e++)t.append(\"v\",arguments[e]);throw Error(`Minified Lexical error #${e}; visit https://lexical.dev/docs/error?${t} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`)};const j=\"undefined\"!=typeof window&&void 0!==window.document&&void 0!==window.document.createElement,q=j&&\"documentMode\"in document?document.documentMode:null,Q=j&&/Mac|iPod|iPhone|iPad/.test(navigator.platform),X=j&&/^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent),Y=!(!j||!(\"InputEvent\"in window)||q)&&\"getTargetRanges\"in new window.InputEvent(\"input\"),Z=j&&/Version\\/[\\d.]+.*Safari/.test(navigator.userAgent),G=j&&/iPad|iPhone|iPod/.test(navigator.userAgent)&&!window.MSStream,ee=j&&/Android/.test(navigator.userAgent),te=j&&/^(?=.*Chrome).*/i.test(navigator.userAgent),ne=j&&ee&&te,re=j&&/AppleWebKit\\/[\\d.]+/.test(navigator.userAgent)&&!te,ie=1,se=3,oe=0,le=1,ce=2,ue=4,ae=8,fe=240|(3|ue|ae),de=1,he=2,ge=3,_e=4,pe=5,ye=6,me=Z||G||re?\"\":\"\",xe=\"\\n\\n\",ve=X?\"\":me,Te=\"---\",Se=\"A-Za-z--------\",ke=new RegExp(\"^[^\"+Se+\"]*[\"+Te+\"]\"),Ce=new RegExp(\"^[^\"+Te+\"]*[\"+Se+\"]\"),be={bold:1,code:16,highlight:128,italic:2,strikethrough:ue,subscript:32,superscript:64,underline:ae},Ne={directionless:1,unmergeable:2},we={center:he,end:ye,justify:_e,left:de,right:ge,start:pe},Ee={[he]:\"center\",[ye]:\"end\",[_e]:\"justify\",[de]:\"left\",[ge]:\"right\",[pe]:\"start\"},Pe={normal:0,segmented:2,token:1},De={0:\"normal\",2:\"segmented\",1:\"token\"};function Ie(...e){const t=[];for(const n of e)if(n&&\"string\"==typeof n)for(const[e]of n.matchAll(/\\S+/g))t.push(e);return t}const Oe=100;let Ae=!1,Le=0;function Fe(e){Le=e.timeStamp}function Me(e,t,n){return t.__lexicalLineBreak===e||void 0!==e[`__lexicalKey_${n._key}`]}function We(e,t,n){const r=nn(n._window);let i=null,s=null;null!==r&&r.anchorNode===e&&(i=r.anchorOffset,s=r.focusOffset);const o=e.nodeValue;null!==o&&kt(t,o,i,s,!1)}function ze(e,t,n){if(Xr(e)){const t=e.anchor.getNode();if(t.is(n)&&e.format!==t.getFormat())return!1}return t.nodeType===se&&n.isAttached()}function Be(e,t,n){Ae=!0;const r=performance.now()-Le>Oe;try{Vi(e,(()=>{const i=fi()||function(e){return e.getEditorState().read((()=>{const e=fi();return null!==e?e.clone():null}))}(e),s=new Map,o=e.getRootElement(),l=e._editorState,c=e._blockCursorElement;let u=!1,a=\"\";for(let n=0;n<t.length;n++){const f=t[n],d=f.type,h=f.target;let g=at(h,l);if(!(null===g&&h!==o||Hi(g)))if(\"characterData\"===d)r&&Br(g)&&ze(i,h,g)&&We(h,g,e);else if(\"childList\"===d){u=!0;const t=f.addedNodes;for(let n=0;n<t.length;n++){const r=t[n],i=ut(r),s=r.parentNode;if(null!=s&&r!==c&&null===i&&(\"BR\"!==r.nodeName||!Me(r,s,e))){if(X){const e=r.innerText||r.nodeValue;e&&(a+=e)}s.removeChild(r)}}const n=f.removedNodes,r=n.length;if(r>0){let t=0;for(let i=0;i<r;i++){const r=n[i];(\"BR\"===r.nodeName&&Me(r,h,e)||c===r)&&(h.appendChild(r),t++)}r!==t&&(h===o&&(g=gt(l)),s.set(h,g))}}}if(s.size>0)for(const[t,n]of s)if(qi(n)){const r=n.getChildrenKeys();let i=t.firstChild;for(let n=0;n<r.length;n++){const s=r[n],o=e.getElementByKey(s);null!==o&&(null==i?(t.appendChild(o),i=o):i!==o&&t.replaceChild(o,i),i=i.nextSibling)}}else Br(n)&&n.markDirty();const f=n.takeRecords();if(f.length>0){for(let t=0;t<f.length;t++){const n=f[t],r=n.addedNodes,i=n.target;for(let t=0;t<r.length;t++){const n=r[t],s=n.parentNode;null==s||\"BR\"!==n.nodeName||Me(n,i,e)||s.removeChild(n)}}n.takeRecords()}null!==i&&(u&&(i.dirty=!0,_t(i)),X&&zt(e)&&i.insertRawText(a))}))}finally{Ae=!1}}function Re(e){const t=e._observer;if(null!==t){Be(e,t.takeRecords(),t)}}function Ke(e){!function(e){0===Le&&Ht(e).addEventListener(\"textInput\",Fe,!0)}(e),e._observer=new MutationObserver(((t,n)=>{Be(e,t,n)}))}function Je(e,t){const n=e.__mode,r=e.__format,i=e.__style,s=t.__mode,o=t.__format,l=t.__style;return!(null!==n&&n!==s||null!==r&&r!==o||null!==i&&i!==l)}function Ue(e,t){const n=e.mergeWithSibling(t),r=Oi()._normalizedNodes;return r.add(e.__key),r.add(t.__key),n}function Ve(e){let t,n,r=e;if(\"\"!==r.__text||!r.isSimpleText()||r.isUnmergeable()){for(;null!==(t=r.getPreviousSibling())&&Br(t)&&t.isSimpleText()&&!t.isUnmergeable();){if(\"\"!==t.__text){if(Je(t,r)){r=Ue(t,r);break}break}t.remove()}for(;null!==(n=r.getNextSibling())&&Br(n)&&n.isSimpleText()&&!n.isUnmergeable();){if(\"\"!==n.__text){if(Je(r,n)){r=Ue(r,n);break}break}n.remove()}}else r.remove()}function $e(e){return He(e.anchor),He(e.focus),e}function He(e){for(;\"element\"===e.type;){const t=e.getNode(),n=e.offset;let r,i;if(n===t.getChildrenSize()?(r=t.getChildAtIndex(n-1),i=!0):(r=t.getChildAtIndex(n),i=!1),Br(r)){e.set(r.__key,i?r.getTextContentSize():0,\"text\");break}if(!qi(r))break;e.set(r.__key,i?r.getChildrenSize():0,\"element\")}}let je=1;const qe=\"function\"==typeof queueMicrotask?queueMicrotask:e=>{Promise.resolve().then(e)};function Qe(e){const t=document.activeElement;if(null===t)return!1;const n=t.nodeName;return Hi(at(e))&&(\"INPUT\"===n||\"TEXTAREA\"===n||\"true\"===t.contentEditable&&null==t.__lexicalEditor)}function Xe(e,t,n){const r=e.getRootElement();try{return null!==r&&r.contains(t)&&r.contains(n)&&null!==t&&!Qe(t)&&Ye(t)===e}catch(e){return!1}}function Ye(e){let t=e;for(;null!=t;){const e=t.__lexicalEditor;if(null!=e)return e;t=Jt(t)}return null}function Ze(e){return e.isToken()||e.isSegmented()}function Ge(e){return e.nodeType===se}function et(e){let t=e;for(;null!=t;){if(Ge(t))return t;t=t.firstChild}return null}function tt(e,t,n){const r=be[t];if(null!==n&&(e&r)==(n&r))return e;let i=e^r;return\"subscript\"===t?i&=~be.superscript:\"superscript\"===t&&(i&=~be.subscript),i}function nt(e){return Br(e)||vr(e)||Hi(e)}function rt(e,t){if(null!=t)return void(e.__key=t);Pi(),Di();const n=Oi(),r=Ii(),i=\"\"+je++;r._nodeMap.set(i,e),qi(e)?n._dirtyElements.set(i,!0):n._dirtyLeaves.add(i),n._cloneNotNeeded.add(i),n._dirtyType=le,e.__key=i}function it(e){const t=e.getParent();if(null!==t){const n=e.getWritable(),r=t.getWritable(),i=e.getPreviousSibling(),s=e.getNextSibling();if(null===i)if(null!==s){const e=s.getWritable();r.__first=s.__key,e.__prev=null}else r.__first=null;else{const e=i.getWritable();if(null!==s){const t=s.getWritable();t.__prev=e.__key,e.__next=t.__key}else e.__next=null;n.__prev=null}if(null===s)if(null!==i){const e=i.getWritable();r.__last=i.__key,e.__next=null}else r.__last=null;else{const e=s.getWritable();if(null!==i){const t=i.getWritable();t.__next=e.__key,e.__prev=t.__key}else e.__prev=null;n.__next=null}r.__size--,n.__parent=null}}function st(e){Di();const t=e.getLatest(),n=t.__parent,r=Ii(),i=Oi(),s=r._nodeMap,o=i._dirtyElements;null!==n&&function(e,t,n){let r=e;for(;null!==r;){if(n.has(r))return;const e=t.get(r);if(void 0===e)break;n.set(r,!1),r=e.__parent}}(n,s,o);const l=t.__key;i._dirtyType=le,qi(e)?o.set(l,!0):i._dirtyLeaves.add(l)}function ot(e){Pi();const t=Oi(),n=t._compositionKey;if(e!==n){if(t._compositionKey=e,null!==n){const e=ct(n);null!==e&&e.getWritable()}if(null!==e){const t=ct(e);null!==t&&t.getWritable()}}}function lt(){if(Ei())return null;return Oi()._compositionKey}function ct(e,t){const n=(t||Ii())._nodeMap.get(e);return void 0===n?null:n}function ut(e,t){const n=e[`__lexicalKey_${Oi()._key}`];return void 0!==n?ct(n,t):null}function at(e,t){let n=e;for(;null!=n;){const e=ut(n,t);if(null!==e)return e;n=Jt(n)}return null}function ft(e){const t=e._decorators,n=Object.assign({},t);return e._pendingDecorators=n,n}function dt(e){return e.read((()=>ht().getTextContent()))}function ht(){return gt(Ii())}function gt(e){return e._nodeMap.get(\"root\")}function _t(e){Pi();const t=Ii();null!==e&&(e.dirty=!0,e.setCachedNodes(null)),t._selection=e}function pt(e){const t=Oi(),n=function(e,t){let n=e;for(;null!=n;){const e=n[`__lexicalKey_${t._key}`];if(void 0!==e)return e;n=Jt(n)}return null}(e,t);if(null===n){return e===t.getRootElement()?ct(\"root\"):null}return ct(n)}function yt(e,t){return t?e.getTextContentSize():0}function mt(e){return/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g.test(e)}function xt(e){const t=[];let n=e;for(;null!==n;)t.push(n),n=n._parentEditor;return t}function vt(){return Math.random().toString(36).replace(/[^a-z]+/g,\"\").substr(0,5)}function Tt(e){return e.nodeType===se?e.nodeValue:null}function St(e,t,n){const r=nn(t._window);if(null===r)return;const i=r.anchorNode;let{anchorOffset:s,focusOffset:o}=r;if(null!==i){let t=Tt(i);const r=at(i);if(null!==t&&Br(r)){if(t===me&&n){const e=n.length;t=n,s=e,o=e}null!==t&&kt(r,t,s,o,e)}}}function kt(e,t,n,r,i){let s=e;if(s.isAttached()&&(i||!s.isDirty())){const o=s.isComposing();let l=t;(o||i)&&t[t.length-1]===me&&(l=t.slice(0,-1));const c=s.getTextContent();if(i||l!==c){if(\"\"===l){if(ot(null),Z||G||re)s.remove();else{const e=Oi();setTimeout((()=>{e.update((()=>{s.isAttached()&&s.remove()}))}),20)}return}const t=s.getParent(),i=di(),c=s.getTextContentSize(),u=lt(),a=s.getKey();if(s.isToken()||null!==u&&a===u&&!o||Xr(i)&&(null!==t&&!t.canInsertTextBefore()&&0===i.anchor.offset||i.anchor.key===e.__key&&0===i.anchor.offset&&!s.canInsertTextBefore()&&!o||i.focus.key===e.__key&&i.focus.offset===c&&!s.canInsertTextAfter()&&!o))return void s.markDirty();const f=fi();if(!Xr(f)||null===n||null===r)return void s.setTextContent(l);if(f.setTextNodeRange(s,n,s,r),s.isSegmented()){const e=zr(s.getTextContent());s.replace(e),s=e}s.setTextContent(l)}}}function Ct(e,t){if(t.isSegmented())return!0;if(!e.isCollapsed())return!1;const n=e.anchor.offset,r=t.getParentOrThrow(),i=t.isToken();return 0===n?!t.canInsertTextBefore()||!r.canInsertTextBefore()||i||function(e){const t=e.getPreviousSibling();return(Br(t)||qi(t)&&t.isInline())&&!t.canInsertTextAfter()}(t):n===t.getTextContentSize()&&(!t.canInsertTextAfter()||!r.canInsertTextAfter()||i)}function bt(e){return 37===e}function Nt(e){return 39===e}function wt(e,t){return Q?e:t}function Et(e){return 13===e}function Pt(e){return 8===e}function Dt(e){return 46===e}function It(e,t,n){return 65===e&&wt(t,n)}function Ot(){const e=ht();_t($e(e.select(0,e.getChildrenSize())))}function At(e,t){void 0===e.__lexicalClassNameCache&&(e.__lexicalClassNameCache={});const n=e.__lexicalClassNameCache,r=n[t];if(void 0!==r)return r;const i=e[t];if(\"string\"==typeof i){const e=Ie(i);return n[t]=e,e}return i}function Lt(e,t,n,r,i){if(0===n.size)return;const s=r.__type,o=r.__key,l=t.get(s);void 0===l&&H(33,s);const c=l.klass;let u=e.get(c);void 0===u&&(u=new Map,e.set(c,u));const a=u.get(o),f=\"destroyed\"===a&&\"created\"===i;(void 0===a||f)&&u.set(o,f?\"updated\":i)}function Ft(e){const t=Ii(),n=t._readOnly,r=e.getType(),i=t._nodeMap,s=[];for(const[,t]of i)t instanceof e&&t.__type===r&&(n||t.isAttached())&&s.push(t);return s}function Mt(e,t,n){const r=e.getParent();let i=n,s=e;return null!==r&&(t&&0===n?(i=s.getIndexWithinParent(),s=r):t||n!==s.getChildrenSize()||(i=s.getIndexWithinParent()+1,s=r)),s.getChildAtIndex(t?i-1:i)}function Wt(e,t){const n=e.offset;if(\"element\"===e.type){return Mt(e.getNode(),t,n)}{const r=e.getNode();if(t&&0===n||!t&&n===r.getTextContentSize()){const e=t?r.getPreviousSibling():r.getNextSibling();return null===e?Mt(r.getParentOrThrow(),t,r.getIndexWithinParent()+(t?0:1)):e}}return null}function zt(e){const t=Ht(e).event,n=t&&t.inputType;return\"insertFromPaste\"===n||\"insertFromPasteAsQuotation\"===n}function Bt(e,t,n){return Ki(e,t,n)}function Rt(e){return!Yi(e)&&!e.isLastChild()&&!e.isInline()}function Kt(e,t){const n=e._keyToDOMMap.get(t);return void 0===n&&H(75,t),n}function Jt(e){const t=e.assignedSlot||e.parentElement;return null!==t&&11===t.nodeType?t.host:t}function Ut(e){return Oi()._updateTags.has(e)}function Vt(e){Pi();Oi()._updateTags.add(e)}function $t(e,t){let n=e.getParent();for(;null!==n;){if(n.is(t))return!0;n=n.getParent()}return!1}function Ht(e){const t=e._window;return null===t&&H(78),t}function jt(e){return qi(e)&&e.isInline()||Hi(e)&&e.isInline()}function qt(e){let t=e.getParentOrThrow();for(;null!==t;){if(Qt(t))return t;t=t.getParentOrThrow()}return t}function Qt(e){return Yi(e)||qi(e)&&e.isShadowRoot()}function Xt(e){const t=e.constructor.clone(e);return rt(t,null),t}function Yt(e){const t=Oi(),n=e.constructor.getType(),r=t._nodes.get(n);void 0===r&&H(97);const i=r.replace;if(null!==i){const t=i(e);return t instanceof e.constructor||H(98),t}return e}function Zt(e,t){!Yi(e.getParent())||qi(t)||Hi(t)||H(99)}function Gt(e){return(Hi(e)||qi(e)&&!e.canBeEmpty())&&!e.isInline()}function en(e,t,n){n.style.removeProperty(\"caret-color\"),t._blockCursorElement=null;const r=e.parentElement;null!==r&&r.removeChild(e)}function tn(e,t,n){let r=e._blockCursorElement;if(Xr(n)&&n.isCollapsed()&&\"element\"===n.anchor.type&&t.contains(document.activeElement)){const i=n.anchor,s=i.getNode(),o=i.offset;let l=!1,c=null;if(o===s.getChildrenSize()){Gt(s.getChildAtIndex(o-1))&&(l=!0)}else{const t=s.getChildAtIndex(o);if(Gt(t)){const n=t.getPreviousSibling();(null===n||Gt(n))&&(l=!0,c=e.getElementByKey(t.__key))}}if(l){const n=e.getElementByKey(s.__key);return null===r&&(e._blockCursorElement=r=function(e){const t=e.theme,n=document.createElement(\"div\");n.contentEditable=\"false\",n.setAttribute(\"data-lexical-cursor\",\"true\");let r=t.blockCursor;if(void 0!==r){if(\"string\"==typeof r){const e=Ie(r);r=t.blockCursor=e}void 0!==r&&n.classList.add(...r)}return n}(e._config)),t.style.caretColor=\"transparent\",void(null===c?n.appendChild(r):n.insertBefore(r,c))}}null!==r&&en(r,e,t)}function nn(e){return j?(e||window).getSelection():null}function rn(e,t){let n=e.getChildAtIndex(t);null==n&&(n=e),Qt(e)&&H(102);const r=e=>{const t=e.getParentOrThrow(),i=Qt(t),s=e!==n||i?Xt(e):e;if(i)return qi(e)&&qi(s)||H(133),e.insertAfter(s),[e,s,s];{const[n,i,o]=r(t),l=e.getNextSiblings();return o.append(s,...l),[n,i,s]}},[i,s]=r(n);return[i,s]}function sn(e){return on(e)&&\"A\"===e.tagName}function on(e){return 1===e.nodeType}function ln(e){if(Hi(e)&&!e.isInline())return!0;if(!qi(e)||Qt(e))return!1;const t=e.getFirstChild(),n=null===t||vr(t)||Br(t)||t.isInline();return!e.isInline()&&!1!==e.canBeEmpty()&&n}function cn(e,t){let n=e;for(;null!==n&&null!==n.getParent()&&!t(n);)n=n.getParentOrThrow();return t(n)?n:null}function un(){return Oi()}function an(e,t,n,r,i,s){let o=e.getFirstChild();for(;null!==o;){const e=o.__key;o.__parent===t&&(qi(o)&&an(o,e,n,r,i,s),n.has(e)||s.delete(e),i.push(e)),o=o.getNextSibling()}}let fn,dn,hn,gn,_n,pn,yn,mn,xn,vn,Tn=\"\",Sn=\"\",kn=\"\",Cn=!1,bn=!1,Nn=null;function wn(e,t){const n=yn.get(e);if(null!==t){const n=Vn(e);n.parentNode===t&&t.removeChild(n)}if(mn.has(e)||dn._keyToDOMMap.delete(e),qi(n)){const e=Bn(n,yn);En(e,0,e.length-1,null)}void 0!==n&&Lt(vn,hn,gn,n,\"destroyed\")}function En(e,t,n,r){let i=t;for(;i<=n;++i){const t=e[i];void 0!==t&&wn(t,r)}}function Pn(e,t){e.setProperty(\"text-align\",t)}const Dn=\"40px\";function In(e,t){const n=fn.theme.indent;if(\"string\"==typeof n){const r=e.classList.contains(n);t>0&&!r?e.classList.add(n):t<1&&r&&e.classList.remove(n)}const r=getComputedStyle(e).getPropertyValue(\"--lexical-indent-base-value\")||Dn;e.style.setProperty(\"padding-inline-start\",0===t?\"\":`calc(${t} * ${r})`)}function On(e,t){const n=e.style;0===t?Pn(n,\"\"):t===de?Pn(n,\"left\"):t===he?Pn(n,\"center\"):t===ge?Pn(n,\"right\"):t===_e?Pn(n,\"justify\"):t===pe?Pn(n,\"start\"):t===ye&&Pn(n,\"end\")}function An(e,t,n){const r=mn.get(e);void 0===r&&H(60);const i=r.createDOM(fn,dn);if(function(e,t,n){const r=n._keyToDOMMap;t[\"__lexicalKey_\"+n._key]=e,r.set(e,t)}(e,i,dn),Br(r)?i.setAttribute(\"data-lexical-text\",\"true\"):Hi(r)&&i.setAttribute(\"data-lexical-decorator\",\"true\"),qi(r)){const e=r.__indent,t=r.__size;if(0!==e&&In(i,e),0!==t){const e=t-1;!function(e,t,n,r){const i=Sn;Sn=\"\",Ln(e,n,0,t,r,null),Wn(n,r),Sn=i}(Bn(r,mn),e,r,i)}const n=r.__format;0!==n&&On(i,n),r.isInline()||Mn(null,r,i),Rt(r)&&(Tn+=xe,kn+=xe)}else{const t=r.getTextContent();if(Hi(r)){const t=r.decorate(dn,fn);null!==t&&Kn(e,t),i.contentEditable=\"false\"}else Br(r)&&(r.isDirectionless()||(Sn+=t));Tn+=t,kn+=t}if(null!==t)if(null!=n)t.insertBefore(i,n);else{const e=t.__lexicalLineBreak;null!=e?t.insertBefore(i,e):t.appendChild(i)}return Lt(vn,hn,gn,r,\"created\"),i}function Ln(e,t,n,r,i,s){const o=Tn;Tn=\"\";let l=n;for(;l<=r;++l)An(e[l],i,s);Rt(t)&&(Tn+=xe),i.__lexicalTextContent=Tn,Tn=o+Tn}function Fn(e,t){const n=t.get(e);return vr(n)||Hi(n)&&n.isInline()}function Mn(e,t,n){const r=null!==e&&(0===e.__size||Fn(e.__last,yn)),i=0===t.__size||Fn(t.__last,mn);if(r){if(!i){const e=n.__lexicalLineBreak;null!=e&&n.removeChild(e),n.__lexicalLineBreak=null}}else if(i){const e=document.createElement(\"br\");n.__lexicalLineBreak=e,n.appendChild(e)}}function Wn(e,t){const n=t.__lexicalDirTextContent,r=t.__lexicalDir;if(n!==Sn||r!==Nn){const n=\"\"===Sn,s=n?Nn:(i=Sn,ke.test(i)?\"rtl\":Ce.test(i)?\"ltr\":null);if(s!==r){const i=t.classList,o=fn.theme;let l=null!==r?o[r]:void 0,c=null!==s?o[s]:void 0;if(void 0!==l){if(\"string\"==typeof l){const e=Ie(l);l=o[r]=e}i.remove(...l)}if(null===s||n&&\"ltr\"===s)t.removeAttribute(\"dir\");else{if(void 0!==c){if(\"string\"==typeof c){const e=Ie(c);c=o[s]=e}void 0!==c&&i.add(...c)}t.dir=s}if(!bn){e.getWritable().__dir=s}}Nn=s,t.__lexicalDirTextContent=Sn,t.__lexicalDir=s}var i}function zn(e,t,n){const r=Sn;Sn=\"\",function(e,t,n){const r=Tn,i=e.__size,s=t.__size;if(Tn=\"\",1===i&&1===s){const r=e.__first,i=t.__first;if(r===i)Rn(r,n);else{const e=Vn(r),t=An(i,null,null);n.replaceChild(t,e),wn(r,null)}}else{const r=Bn(e,yn),o=Bn(t,mn);if(0===i)0!==s&&Ln(o,t,0,s-1,n,null);else if(0===s){if(0!==i){const e=null==n.__lexicalLineBreak;En(r,0,i-1,e?null:n),e&&(n.textContent=\"\")}}else!function(e,t,n,r,i,s){const o=r-1,l=i-1;let c,u,a=(h=s,h.firstChild),f=0,d=0;var h;for(;f<=o&&d<=l;){const e=t[f],r=n[d];if(e===r)a=Jn(Rn(r,s)),f++,d++;else{void 0===c&&(c=new Set(t)),void 0===u&&(u=new Set(n));const i=u.has(e),o=c.has(r);if(i)if(o){const e=Kt(dn,r);e===a?a=Jn(Rn(r,s)):(null!=a?s.insertBefore(e,a):s.appendChild(e),Rn(r,s)),f++,d++}else An(r,s,a),d++;else a=Jn(Vn(e)),wn(e,s),f++}}const g=f>o,_=d>l;if(g&&!_){const t=n[l+1];Ln(n,e,d,l,s,void 0===t?null:dn.getElementByKey(t))}else _&&!g&&En(t,f,o,s)}(t,r,o,i,s,n)}Rt(t)&&(Tn+=xe);n.__lexicalTextContent=Tn,Tn=r+Tn}(e,t,n),Wn(t,n),Sn=r}function Bn(e,t){const n=[];let r=e.__first;for(;null!==r;){const e=t.get(r);void 0===e&&H(101),n.push(r),r=e.__next}return n}function Rn(e,t){const n=yn.get(e);let r=mn.get(e);void 0!==n&&void 0!==r||H(61);const i=Cn||pn.has(e)||_n.has(e),s=Kt(dn,e);if(n===r&&!i){if(qi(n)){const e=s.__lexicalTextContent;void 0!==e&&(Tn+=e,kn+=e);const t=s.__lexicalDirTextContent;void 0!==t&&(Sn+=t)}else{const e=n.getTextContent();Br(n)&&!n.isDirectionless()&&(Sn+=e),kn+=e,Tn+=e}return s}if(n!==r&&i&&Lt(vn,hn,gn,r,\"updated\"),r.updateDOM(n,s,fn)){const n=An(e,null,null);return null===t&&H(62),t.replaceChild(n,s),wn(e,null),n}if(qi(n)&&qi(r)){const e=r.__indent;e!==n.__indent&&In(s,e);const t=r.__format;t!==n.__format&&On(s,t),i&&(zn(n,r,s),Yi(r)||r.isInline()||Mn(n,r,s)),Rt(r)&&(Tn+=xe,kn+=xe)}else{const t=r.getTextContent();if(Hi(r)){const t=r.decorate(dn,fn);null!==t&&Kn(e,t)}else Br(r)&&!r.isDirectionless()&&(Sn+=t);Tn+=t,kn+=t}if(!bn&&Yi(r)&&r.__cachedText!==kn){const e=r.getWritable();e.__cachedText=kn,r=e}return s}function Kn(e,t){let n=dn._pendingDecorators;const r=dn._decorators;if(null===n){if(r[e]===t)return;n=ft(dn)}n[e]=t}function Jn(e){let t=e.nextSibling;return null!==t&&t===dn._blockCursorElement&&(t=t.nextSibling),t}function Un(e,t,n,r,i,s){Tn=\"\",kn=\"\",Sn=\"\",Cn=r===ce,Nn=null,dn=n,fn=n._config,hn=n._nodes,gn=dn._listeners.mutation,_n=i,pn=s,yn=e._nodeMap,mn=t._nodeMap,bn=t._readOnly,xn=new Map(n._keyToDOMMap);const o=new Map;return vn=o,Rn(\"root\",null),dn=void 0,hn=void 0,_n=void 0,pn=void 0,yn=void 0,mn=void 0,fn=void 0,xn=void 0,vn=void 0,o}function Vn(e){const t=xn.get(e);return void 0===t&&H(75,e),t}const $n=Object.freeze({}),Hn=30,jn=[[\"keydown\",function(e,t){if(qn=e.timeStamp,Qn=e.keyCode,t.isComposing())return;const{keyCode:n,shiftKey:r,ctrlKey:o,metaKey:l,altKey:c}=e;if(Bt(t,_,e))return;if(function(e,t,n,r){return Nt(e)&&!t&&!r&&!n}(n,o,c,l))Bt(t,p,e);else if(function(e,t,n,r,i){return Nt(e)&&!r&&!n&&(t||i)}(n,o,r,c,l))Bt(t,y,e);else if(function(e,t,n,r){return bt(e)&&!t&&!r&&!n}(n,o,c,l))Bt(t,m,e);else if(function(e,t,n,r,i){return bt(e)&&!r&&!n&&(t||i)}(n,o,r,c,l))Bt(t,x,e);else if(function(e,t,n){return function(e){return 38===e}(e)&&!t&&!n}(n,o,l))Bt(t,v,e);else if(function(e,t,n){return function(e){return 40===e}(e)&&!t&&!n}(n,o,l))Bt(t,T,e);else if(function(e,t){return Et(e)&&t}(n,r))tr=!0,Bt(t,S,e);else if(function(e){return 32===e}(n))Bt(t,k,e);else if(function(e,t){return Q&&t&&79===e}(n,o))e.preventDefault(),tr=!0,Bt(t,s,!0);else if(function(e,t){return Et(e)&&!t}(n,r))tr=!1,Bt(t,S,e);else if(function(e,t,n,r){return Q?!t&&!n&&(Pt(e)||72===e&&r):!(r||t||n)&&Pt(e)}(n,c,l,o))Pt(n)?Bt(t,C,e):(e.preventDefault(),Bt(t,i,!0));else if(function(e){return 27===e}(n))Bt(t,b,e);else if(function(e,t,n,r,i){return Q?!(n||r||i)&&(Dt(e)||68===e&&t):!(t||r||i)&&Dt(e)}(n,o,r,c,l))Dt(n)?Bt(t,N,e):(e.preventDefault(),Bt(t,i,!1));else if(function(e,t,n){return Pt(e)&&(Q?t:n)}(n,c,o))e.preventDefault(),Bt(t,a,!0);else if(function(e,t,n){return Dt(e)&&(Q?t:n)}(n,c,o))e.preventDefault(),Bt(t,a,!1);else if(function(e,t){return Q&&t&&Pt(e)}(n,l))e.preventDefault(),Bt(t,f,!0);else if(function(e,t){return Q&&t&&Dt(e)}(n,l))e.preventDefault(),Bt(t,f,!1);else if(function(e,t,n,r){return 66===e&&!t&&wt(n,r)}(n,c,l,o))e.preventDefault(),Bt(t,d,\"bold\");else if(function(e,t,n,r){return 85===e&&!t&&wt(n,r)}(n,c,l,o))e.preventDefault(),Bt(t,d,\"underline\");else if(function(e,t,n,r){return 73===e&&!t&&wt(n,r)}(n,c,l,o))e.preventDefault(),Bt(t,d,\"italic\");else if(function(e,t,n,r){return 9===e&&!t&&!n&&!r}(n,c,o,l))Bt(t,w,e);else if(function(e,t,n,r){return 90===e&&!t&&wt(n,r)}(n,r,l,o))e.preventDefault(),Bt(t,h,void 0);else if(function(e,t,n,r){return Q?90===e&&n&&t:89===e&&r||90===e&&r&&t}(n,r,l,o))e.preventDefault(),Bt(t,g,void 0);else{Zr(t._editorState._selection)?!function(e,t,n,r){return!t&&67===e&&(Q?n:r)}(n,r,l,o)?!function(e,t,n,r){return!t&&88===e&&(Q?n:r)}(n,r,l,o)?It(n,l,o)&&(e.preventDefault(),Bt(t,z,e)):(e.preventDefault(),Bt(t,W,e)):(e.preventDefault(),Bt(t,M,e)):!X&&It(n,l,o)&&(e.preventDefault(),Bt(t,z,e))}(function(e,t,n,r){return e||t||n||r})(o,r,c,l)&&Bt(t,$,e)}],[\"pointerdown\",function(e,t){const n=e.target,r=e.pointerType;n instanceof Node&&\"touch\"!==r&&Vi(t,(()=>{Hi(at(n))||(er=!0)}))}],[\"compositionstart\",function(e,t){Vi(t,(()=>{const n=fi();if(Xr(n)&&!t.isComposing()){const r=n.anchor,i=n.anchor.getNode();ot(r.key),(e.timeStamp<qn+Hn||\"element\"===r.type||!n.isCollapsed()||i.getFormat()!==n.format||Br(i)&&i.getStyle()!==n.style)&&Bt(t,l,ve)}}))}],[\"compositionend\",function(e,t){X?nr=!0:Vi(t,(()=>{cr(t,e.data)}))}],[\"input\",function(e,t){e.stopPropagation(),Vi(t,(()=>{const n=fi(),r=e.data,i=lr(e);if(null!=r&&Xr(n)&&ir(n,i,r,e.timeStamp,!1)){nr&&(cr(t,r),nr=!1);const i=n.anchor,s=i.getNode(),o=nn(t._window);if(null===o)return;const c=i.offset;Y&&!n.isCollapsed()&&Br(s)&&null!==o.anchorNode&&s.getTextContent().slice(0,c)+r+s.getTextContent().slice(c+n.focus.offset)===Tt(o.anchorNode)||Bt(t,l,r);const u=r.length;X&&u>1&&\"insertCompositionText\"===e.inputType&&!t.isComposing()&&(n.anchor.offset-=u),Z||G||re||!t.isComposing()||(qn=0,ot(null))}else{St(!1,t,null!==r?r:void 0),nr&&(cr(t,r||void 0),nr=!1)}Pi(),Re(Oi())})),Yn=null}],[\"click\",function(e,t){Vi(t,(()=>{const n=fi(),i=nn(t._window),s=di();if(i)if(Xr(n)){const t=n.anchor,r=t.getNode();if(\"element\"===t.type&&0===t.offset&&n.isCollapsed()&&!Yi(r)&&1===ht().getChildrenSize()&&r.getTopLevelElementOrThrow().isEmpty()&&null!==s&&n.is(s))i.removeAllRanges(),n.dirty=!0;else if(3===e.detail&&!n.isCollapsed()){r!==n.focus.getNode()&&(qi(r)?r.select(0):r.getParentOrThrow().select(0))}}else if(\"touch\"===e.pointerType){const n=i.anchorNode;if(null!==n){const r=n.nodeType;if(r===ie||r===se){_t(ai(s,i,t,e))}}}Bt(t,r,e)}))}],[\"cut\",$n],[\"copy\",$n],[\"dragstart\",$n],[\"dragover\",$n],[\"dragend\",$n],[\"paste\",$n],[\"focus\",$n],[\"blur\",$n],[\"drop\",$n]];Y&&jn.push([\"beforeinput\",(e,t)=>function(e,t){const n=e.inputType,r=lr(e);if(\"deleteCompositionText\"===n||X&&zt(t))return;if(\"insertCompositionText\"===n)return;Vi(t,(()=>{const _=fi();if(\"deleteContentBackward\"===n){if(null===_){const e=di();if(!Xr(e))return;_t(e.clone())}if(Xr(_)){const n=_.anchor.key===_.focus.key;if(p=e.timeStamp,229===Qn&&p<qn+Hn&&t.isComposing()&&n){if(ot(null),qn=0,setTimeout((()=>{Vi(t,(()=>{ot(null)}))}),Hn),Xr(_)){const e=_.anchor.getNode();e.markDirty(),_.format=e.getFormat(),Br(e)||H(142),_.style=e.getStyle()}}else{ot(null),e.preventDefault();const r=_.anchor.getNode().getTextContent(),s=0===_.anchor.offset&&_.focus.offset===r.length;ne&&n&&!s||Bt(t,i,!0)}return}}var p;if(!Xr(_))return;const y=e.data;null!==Yn&&St(!1,t,Yn),_.dirty&&null===Yn||!_.isCollapsed()||Yi(_.anchor.getNode())||null===r||_.applyDOMRange(r),Yn=null;const m=_.anchor,x=_.focus,v=m.getNode(),T=x.getNode();if(\"insertText\"!==n&&\"insertTranspose\"!==n)switch(e.preventDefault(),n){case\"insertFromYank\":case\"insertFromDrop\":case\"insertReplacementText\":Bt(t,l,e);break;case\"insertFromComposition\":ot(null),Bt(t,l,e);break;case\"insertLineBreak\":ot(null),Bt(t,s,!1);break;case\"insertParagraph\":ot(null),tr&&!G?(tr=!1,Bt(t,s,!1)):Bt(t,o,void 0);break;case\"insertFromPaste\":case\"insertFromPasteAsQuotation\":Bt(t,c,e);break;case\"deleteByComposition\":(function(e,t){return e!==t||qi(e)||qi(t)||!e.isToken()||!t.isToken()})(v,T)&&Bt(t,u,e);break;case\"deleteByDrag\":case\"deleteByCut\":Bt(t,u,e);break;case\"deleteContent\":Bt(t,i,!1);break;case\"deleteWordBackward\":Bt(t,a,!0);break;case\"deleteWordForward\":Bt(t,a,!1);break;case\"deleteHardLineBackward\":case\"deleteSoftLineBackward\":Bt(t,f,!0);break;case\"deleteContentForward\":case\"deleteHardLineForward\":case\"deleteSoftLineForward\":Bt(t,f,!1);break;case\"formatStrikeThrough\":Bt(t,d,\"strikethrough\");break;case\"formatBold\":Bt(t,d,\"bold\");break;case\"formatItalic\":Bt(t,d,\"italic\");break;case\"formatUnderline\":Bt(t,d,\"underline\");break;case\"historyUndo\":Bt(t,h,void 0);break;case\"historyRedo\":Bt(t,g,void 0)}else{if(\"\\n\"===y)e.preventDefault(),Bt(t,s,!1);else if(y===xe)e.preventDefault(),Bt(t,o,void 0);else if(null==y&&e.dataTransfer){const t=e.dataTransfer.getData(\"text/plain\");e.preventDefault(),_.insertRawText(t)}else null!=y&&ir(_,r,y,e.timeStamp,!0)?(e.preventDefault(),Bt(t,l,y)):Yn=y;Xn=e.timeStamp}}))}(e,t)]);let qn=0,Qn=0,Xn=0,Yn=null;const Zn=new WeakMap;let Gn=!1,er=!1,tr=!1,nr=!1,rr=[0,\"\",0,\"root\",0];function ir(e,t,n,r,i){const s=e.anchor,o=e.focus,l=s.getNode(),c=Oi(),u=nn(c._window),a=null!==u?u.anchorNode:null,f=s.key,d=c.getElementByKey(f),h=n.length;return f!==o.key||!Br(l)||(!i&&(!Y||Xn<r+50)||l.isDirty()&&h<2||mt(n))&&s.offset!==o.offset&&!l.isComposing()||Ze(l)||l.isDirty()&&h>1||(i||!Y)&&null!==d&&!l.isComposing()&&a!==et(d)||null!==u&&null!==t&&(!t.collapsed||t.startContainer!==u.anchorNode||t.startOffset!==u.anchorOffset)||l.getFormat()!==e.format||l.getStyle()!==e.style||Ct(e,l)}function sr(e,t){return null!==e&&null!==e.nodeValue&&e.nodeType===se&&0!==t&&t!==e.nodeValue.length}function or(e,n,r){const{anchorNode:i,anchorOffset:s,focusNode:o,focusOffset:l}=e;Gn&&(Gn=!1,sr(i,s)&&sr(o,l))||Vi(n,(()=>{if(!r)return void _t(null);if(!Xe(n,i,o))return;const c=fi();if(Xr(c)){const t=c.anchor,r=t.getNode();if(c.isCollapsed()){\"Range\"===e.type&&e.anchorNode===e.focusNode&&(c.dirty=!0);const i=Ht(n).event,s=i?i.timeStamp:performance.now(),[o,l,u,a,f]=rr,d=ht(),h=!1===n.isComposing()&&\"\"===d.getTextContent();s<f+200&&t.offset===u&&t.key===a?(c.format=o,c.style=l):\"text\"===t.type?(Br(r)||H(141),c.format=r.getFormat(),c.style=r.getStyle()):\"element\"!==t.type||h||(c.format=0,c.style=\"\")}else{const e=t.key,n=c.focus.key,r=c.getNodes(),i=r.length,o=c.isBackward(),u=o?l:s,a=o?s:l,f=o?n:e,d=o?e:n;let h=fe,g=!1;for(let e=0;e<i;e++){const t=r[e],n=t.getTextContentSize();if(Br(t)&&0!==n&&!(0===e&&t.__key===f&&u===n||e===i-1&&t.__key===d&&0===a)&&(g=!0,h&=t.getFormat(),0===h))break}c.format=g?h:0}}Bt(n,t,void 0)}))}function lr(e){if(!e.getTargetRanges)return null;const t=e.getTargetRanges();return 0===t.length?null:t[0]}function cr(e,t){const n=e._compositionKey;if(ot(null),null!==n&&null!=t){if(\"\"===t){const t=ct(n),r=et(e.getElementByKey(n));return void(null!==r&&null!==r.nodeValue&&Br(t)&&kt(t,r.nodeValue,null,null,!0))}if(\"\\n\"===t[t.length-1]){const t=fi();if(Xr(t)){const n=t.focus;return t.anchor.set(n.key,n.offset,n.type),void Bt(e,S,null)}}}St(!0,e,t)}function ur(e){let t=e.__lexicalEventHandles;return void 0===t&&(t=[],e.__lexicalEventHandles=t),t}const ar=new Map;function fr(e){const t=e.target,n=nn(null==t?null:9===t.nodeType?t.defaultView:t.ownerDocument.defaultView);if(null===n)return;const r=Ye(n.anchorNode);if(null===r)return;er&&(er=!1,Vi(r,(()=>{const t=di(),i=n.anchorNode;if(null===i)return;const s=i.nodeType;if(s!==ie&&s!==se)return;_t(ai(t,n,r,e))})));const i=xt(r),s=i[i.length-1],o=s._key,l=ar.get(o),c=l||s;c!==r&&or(n,c,!1),or(n,r,!0),r!==s?ar.set(o,r):l&&ar.delete(o)}function dr(e){e._lexicalHandled=!0}function hr(e){return!0===e._lexicalHandled}function gr(e){const t=e.ownerDocument,n=Zn.get(t);if(void 0===n)throw Error(\"Root element not registered\");Zn.set(t,n-1),1===n&&t.removeEventListener(\"selectionchange\",fr);const r=e.__lexicalEditor;null!=r&&(!function(e){if(null!==e._parentEditor){const t=xt(e),n=t[t.length-1]._key;ar.get(n)===e&&ar.delete(n)}else ar.delete(e._key)}(r),e.__lexicalEditor=null);const i=ur(e);for(let e=0;e<i.length;e++)i[e]();e.__lexicalEventHandles=[]}function _r(e,t,n){Pi();const r=e.__key,i=e.getParent();if(null===i)return;const s=function(e){const t=fi();if(!Xr(t)||!qi(e))return t;const{anchor:n,focus:r}=t,i=n.getNode(),s=r.getNode();return $t(i,e)&&n.set(e.__key,0,\"element\"),$t(s,e)&&r.set(e.__key,0,\"element\"),t}(e);let o=!1;if(Xr(s)&&t){const t=s.anchor,n=s.focus;t.key===r&&(_i(t,e,i,e.getPreviousSibling(),e.getNextSibling()),o=!0),n.key===r&&(_i(n,e,i,e.getPreviousSibling(),e.getNextSibling()),o=!0)}else Zr(s)&&t&&e.isSelected()&&e.selectPrevious();if(Xr(s)&&t&&!o){const t=e.getIndexWithinParent();it(e),hi(s,i,t,-1)}else it(e);n||Qt(i)||i.canBeEmpty()||!i.isEmpty()||_r(i,t),t&&Yi(i)&&i.isEmpty()&&i.selectEnd()}class pr{static getType(){H(64,this.name)}static clone(e){H(65,this.name)}constructor(e){this.__type=this.constructor.getType(),this.__parent=null,this.__prev=null,this.__next=null,rt(this,e)}getType(){return this.__type}isInline(){H(137,this.constructor.name)}isAttached(){let e=this.__key;for(;null!==e;){if(\"root\"===e)return!0;const t=ct(e);if(null===t)break;e=t.__parent}return!1}isSelected(e){const t=e||fi();if(null==t)return!1;const n=t.getNodes().some((e=>e.__key===this.__key));return(Br(this)||!Xr(t)||\"element\"!==t.anchor.type||\"element\"!==t.focus.type||t.anchor.key!==t.focus.key||t.anchor.offset!==t.focus.offset)&&n}getKey(){return this.__key}getIndexWithinParent(){const e=this.getParent();if(null===e)return-1;let t=e.getFirstChild(),n=0;for(;null!==t;){if(this.is(t))return n;n++,t=t.getNextSibling()}return-1}getParent(){const e=this.getLatest().__parent;return null===e?null:ct(e)}getParentOrThrow(){const e=this.getParent();return null===e&&H(66,this.__key),e}getTopLevelElement(){let e=this;for(;null!==e;){const t=e.getParent();if(Qt(t))return qi(e)||H(138),e;e=t}return null}getTopLevelElementOrThrow(){const e=this.getTopLevelElement();return null===e&&H(67,this.__key),e}getParents(){const e=[];let t=this.getParent();for(;null!==t;)e.push(t),t=t.getParent();return e}getParentKeys(){const e=[];let t=this.getParent();for(;null!==t;)e.push(t.__key),t=t.getParent();return e}getPreviousSibling(){const e=this.getLatest().__prev;return null===e?null:ct(e)}getPreviousSiblings(){const e=[],t=this.getParent();if(null===t)return e;let n=t.getFirstChild();for(;null!==n&&!n.is(this);)e.push(n),n=n.getNextSibling();return e}getNextSibling(){const e=this.getLatest().__next;return null===e?null:ct(e)}getNextSiblings(){const e=[];let t=this.getNextSibling();for(;null!==t;)e.push(t),t=t.getNextSibling();return e}getCommonAncestor(e){const t=this.getParents(),n=e.getParents();qi(this)&&t.unshift(this),qi(e)&&n.unshift(e);const r=t.length,i=n.length;if(0===r||0===i||t[r-1]!==n[i-1])return null;const s=new Set(n);for(let e=0;e<r;e++){const n=t[e];if(s.has(n))return n}return null}is(e){return null!=e&&this.__key===e.__key}isBefore(e){if(this===e)return!1;if(e.isParentOf(this))return!0;if(this.isParentOf(e))return!1;const t=this.getCommonAncestor(e);let n=0,r=0,i=this;for(;;){const e=i.getParentOrThrow();if(e===t){n=i.getIndexWithinParent();break}i=e}for(i=e;;){const e=i.getParentOrThrow();if(e===t){r=i.getIndexWithinParent();break}i=e}return n<r}isParentOf(e){const t=this.__key;if(t===e.__key)return!1;let n=e;for(;null!==n;){if(n.__key===t)return!0;n=n.getParent()}return!1}getNodesBetween(e){const t=this.isBefore(e),n=[],r=new Set;let i=this;for(;null!==i;){const s=i.__key;if(r.has(s)||(r.add(s),n.push(i)),i===e)break;const o=qi(i)?t?i.getFirstChild():i.getLastChild():null;if(null!==o){i=o;continue}const l=t?i.getNextSibling():i.getPreviousSibling();if(null!==l){i=l;continue}const c=i.getParentOrThrow();if(r.has(c.__key)||n.push(c),c===e)break;let u=null,a=c;do{if(null===a&&H(68),u=t?a.getNextSibling():a.getPreviousSibling(),a=a.getParent(),null===a)break;null!==u||r.has(a.__key)||n.push(a)}while(null===u);i=u}return t||n.reverse(),n}isDirty(){const e=Oi()._dirtyLeaves;return null!==e&&e.has(this.__key)}getLatest(){const e=ct(this.__key);return null===e&&H(113),e}getWritable(){Pi();const e=Ii(),t=Oi(),n=e._nodeMap,r=this.__key,i=this.getLatest(),s=i.__parent,o=t._cloneNotNeeded,l=fi();if(null!==l&&l.setCachedNodes(null),o.has(r))return st(i),i;const c=i.constructor.clone(i);return c.__parent=s,c.__next=i.__next,c.__prev=i.__prev,qi(i)&&qi(c)?(c.__first=i.__first,c.__last=i.__last,c.__size=i.__size,c.__indent=i.__indent,c.__format=i.__format,c.__dir=i.__dir):Br(i)&&Br(c)&&(c.__format=i.__format,c.__style=i.__style,c.__mode=i.__mode,c.__detail=i.__detail),o.add(r),c.__key=r,st(c),n.set(r,c),c}getTextContent(){return\"\"}getTextContentSize(){return this.getTextContent().length}createDOM(e,t){H(70)}updateDOM(e,t,n){H(71)}exportDOM(e){return{element:this.createDOM(e._config,e)}}exportJSON(){H(72)}static importJSON(e){H(18,this.name)}static transform(){return null}remove(e){_r(this,!0,e)}replace(e,t){Pi();let n=fi();null!==n&&(n=n.clone()),Zt(this,e);const r=this.getLatest(),i=this.__key,s=e.__key,o=e.getWritable(),l=this.getParentOrThrow().getWritable(),c=l.__size;it(o);const u=r.getPreviousSibling(),a=r.getNextSibling(),f=r.__prev,d=r.__next,h=r.__parent;if(_r(r,!1,!0),null===u)l.__first=s;else{u.getWritable().__next=s}if(o.__prev=f,null===a)l.__last=s;else{a.getWritable().__prev=s}if(o.__next=d,o.__parent=h,l.__size=c,t&&(qi(this)&&qi(o)||H(139),this.getChildren().forEach((e=>{o.append(e)}))),Xr(n)){_t(n);const e=n.anchor,t=n.focus;e.key===i&&Hr(e,o),t.key===i&&Hr(t,o)}return lt()===i&&ot(s),o}insertAfter(e,t=!0){Pi(),Zt(this,e);const n=this.getWritable(),r=e.getWritable(),i=r.getParent(),s=fi();let o=!1,l=!1;if(null!==i){const t=e.getIndexWithinParent();if(it(r),Xr(s)){const e=i.__key,n=s.anchor,r=s.focus;o=\"element\"===n.type&&n.key===e&&n.offset===t+1,l=\"element\"===r.type&&r.key===e&&r.offset===t+1}}const c=this.getNextSibling(),u=this.getParentOrThrow().getWritable(),a=r.__key,f=n.__next;if(null===c)u.__last=a;else{c.getWritable().__prev=a}if(u.__size++,n.__next=a,r.__next=f,r.__prev=n.__key,r.__parent=n.__parent,t&&Xr(s)){const e=this.getIndexWithinParent();hi(s,u,e+1);const t=u.__key;o&&s.anchor.set(t,e+2,\"element\"),l&&s.focus.set(t,e+2,\"element\")}return e}insertBefore(e,t=!0){Pi(),Zt(this,e);const n=this.getWritable(),r=e.getWritable(),i=r.__key;it(r);const s=this.getPreviousSibling(),o=this.getParentOrThrow().getWritable(),l=n.__prev,c=this.getIndexWithinParent();if(null===s)o.__first=i;else{s.getWritable().__next=i}o.__size++,n.__prev=i,r.__prev=l,r.__next=n.__key,r.__parent=n.__parent;const u=fi();if(t&&Xr(u)){hi(u,this.getParentOrThrow(),c)}return e}isParentRequired(){return!1}createParentElementNode(){return rs()}selectStart(){return this.selectPrevious()}selectEnd(){return this.selectNext(0,0)}selectPrevious(e,t){Pi();const n=this.getPreviousSibling(),r=this.getParentOrThrow();if(null===n)return r.select(0,0);if(qi(n))return n.select();if(!Br(n)){const e=n.getIndexWithinParent()+1;return r.select(e,e)}return n.select(e,t)}selectNext(e,t){Pi();const n=this.getNextSibling(),r=this.getParentOrThrow();if(null===n)return r.select();if(qi(n))return n.select(0,0);if(!Br(n)){const e=n.getIndexWithinParent();return r.select(e,e)}return n.select(e,t)}markDirty(){this.getWritable()}}class yr extends pr{static getType(){return\"linebreak\"}static clone(e){return new yr(e.__key)}constructor(e){super(e)}getTextContent(){return\"\\n\"}createDOM(){return document.createElement(\"br\")}updateDOM(){return!1}static importDOM(){return{br:e=>function(e){const t=e.parentElement;if(null!==t){const n=t.firstChild;if(n===e||n.nextSibling===e&&Tr(n)){const n=t.lastChild;if(n===e||n.previousSibling===e&&Tr(n))return!0}}return!1}(e)?null:{conversion:mr,priority:0}}}static importJSON(e){return xr()}exportJSON(){return{type:\"linebreak\",version:1}}}function mr(e){return{node:xr()}}function xr(){return Yt(new yr)}function vr(e){return e instanceof yr}function Tr(e){return e.nodeType===se&&/^( |\\t|\\r?\\n)+$/.test(e.textContent||\"\")}function Sr(e,t){return 16&t?\"code\":128&t?\"mark\":32&t?\"sub\":64&t?\"sup\":null}function kr(e,t){return 1&t?\"strong\":2&t?\"em\":\"span\"}function Cr(e,t,n,r,i){const s=r.classList;let o=At(i,\"base\");void 0!==o&&s.add(...o),o=At(i,\"underlineStrikethrough\");let l=!1;const c=t&ae&&t&ue;void 0!==o&&(n&ae&&n&ue?(l=!0,c||s.add(...o)):c&&s.remove(...o));for(const e in be){const r=be[e];if(o=At(i,e),void 0!==o)if(n&r){if(l&&(\"underline\"===e||\"strikethrough\"===e)){t&r&&s.remove(...o);continue}(0==(t&r)||c&&\"underline\"===e||\"strikethrough\"===e)&&s.add(...o)}else t&r&&s.remove(...o)}}function br(e,t,n){const r=t.firstChild,i=n.isComposing(),s=e+(i?me:\"\");if(null==r)t.textContent=s;else{const e=r.nodeValue;if(e!==s)if(i||X){const[t,n,i]=function(e,t){const n=e.length,r=t.length;let i=0,s=0;for(;i<n&&i<r&&e[i]===t[i];)i++;for(;s+i<n&&s+i<r&&e[n-s-1]===t[r-s-1];)s++;return[i,n-i-s,t.slice(i,r-s)]}(e,s);0!==n&&r.deleteData(t,n),r.insertData(t,i)}else r.nodeValue=s}}function Nr(e,t,n,r,i,s){br(i,e,t);const o=s.theme.text;void 0!==o&&Cr(0,0,r,e,o)}function wr(e,t){const n=document.createElement(t);return n.appendChild(e),n}class Er extends pr{static getType(){return\"text\"}static clone(e){return new Er(e.__text,e.__key)}constructor(e,t){super(t),this.__text=e,this.__format=0,this.__style=\"\",this.__mode=0,this.__detail=0}getFormat(){return this.getLatest().__format}getDetail(){return this.getLatest().__detail}getMode(){const e=this.getLatest();return De[e.__mode]}getStyle(){return this.getLatest().__style}isToken(){return 1===this.getLatest().__mode}isComposing(){return this.__key===lt()}isSegmented(){return 2===this.getLatest().__mode}isDirectionless(){return 0!=(1&this.getLatest().__detail)}isUnmergeable(){return 0!=(2&this.getLatest().__detail)}hasFormat(e){const t=be[e];return 0!=(this.getFormat()&t)}isSimpleText(){return\"text\"===this.__type&&0===this.__mode}getTextContent(){return this.getLatest().__text}getFormatFlags(e,t){return tt(this.getLatest().__format,e,t)}canHaveFormat(){return!0}createDOM(e,t){const n=this.__format,r=Sr(0,n),i=kr(0,n),s=null===r?i:r,o=document.createElement(s);let l=o;this.hasFormat(\"code\")&&o.setAttribute(\"spellcheck\",\"false\"),null!==r&&(l=document.createElement(i),o.appendChild(l));Nr(l,this,0,n,this.__text,e);const c=this.__style;return\"\"!==c&&(o.style.cssText=c),o}updateDOM(e,t,n){const r=this.__text,i=e.__format,s=this.__format,o=Sr(0,i),l=Sr(0,s),c=kr(0,i),u=kr(0,s);if((null===o?c:o)!==(null===l?u:l))return!0;if(o===l&&c!==u){const e=t.firstChild;null==e&&H(48);const i=document.createElement(u);return Nr(i,this,0,s,r,n),t.replaceChild(i,e),!1}let a=t;null!==l&&null!==o&&(a=t.firstChild,null==a&&H(49)),br(r,a,this);const f=n.theme.text;void 0!==f&&i!==s&&Cr(0,i,s,a,f);const d=e.__style,h=this.__style;return d!==h&&(t.style.cssText=h),!1}static importDOM(){return{\"#text\":()=>({conversion:Ar,priority:0}),b:()=>({conversion:Dr,priority:0}),code:()=>({conversion:Wr,priority:0}),em:()=>({conversion:Wr,priority:0}),i:()=>({conversion:Wr,priority:0}),s:()=>({conversion:Wr,priority:0}),span:()=>({conversion:Pr,priority:0}),strong:()=>({conversion:Wr,priority:0}),sub:()=>({conversion:Wr,priority:0}),sup:()=>({conversion:Wr,priority:0}),u:()=>({conversion:Wr,priority:0})}}static importJSON(e){const t=zr(e.text);return t.setFormat(e.format),t.setDetail(e.detail),t.setMode(e.mode),t.setStyle(e.style),t}exportDOM(e){let{element:t}=super.exportDOM(e);return null!==t&&on(t)||H(132),t.style.whiteSpace=\"pre-wrap\",this.hasFormat(\"bold\")&&(t=wr(t,\"b\")),this.hasFormat(\"italic\")&&(t=wr(t,\"i\")),this.hasFormat(\"strikethrough\")&&(t=wr(t,\"s\")),this.hasFormat(\"underline\")&&(t=wr(t,\"u\")),{element:t}}exportJSON(){return{detail:this.getDetail(),format:this.getFormat(),mode:this.getMode(),style:this.getStyle(),text:this.getTextContent(),type:\"text\",version:1}}selectionTransform(e,t){}setFormat(e){const t=this.getWritable();return t.__format=\"string\"==typeof e?be[e]:e,t}setDetail(e){const t=this.getWritable();return t.__detail=\"string\"==typeof e?Ne[e]:e,t}setStyle(e){const t=this.getWritable();return t.__style=e,t}toggleFormat(e){const t=tt(this.getFormat(),e,null);return this.setFormat(t)}toggleDirectionless(){const e=this.getWritable();return e.__detail^=1,e}toggleUnmergeable(){const e=this.getWritable();return e.__detail^=2,e}setMode(e){const t=Pe[e];if(this.__mode===t)return this;const n=this.getWritable();return n.__mode=t,n}setTextContent(e){if(this.__text===e)return this;const t=this.getWritable();return t.__text=e,t}select(e,t){Pi();let n=e,r=t;const i=fi(),s=this.getTextContent(),o=this.__key;if(\"string\"==typeof s){const e=s.length;void 0===n&&(n=e),void 0===r&&(r=e)}else n=0,r=0;if(!Xr(i))return li(o,n,o,r,\"text\",\"text\");{const e=lt();e!==i.anchor.key&&e!==i.focus.key||ot(o),i.setTextNodeRange(this,n,this,r)}return i}selectStart(){return this.select(0,0)}selectEnd(){const e=this.getTextContentSize();return this.select(e,e)}spliceText(e,t,n,r){const i=this.getWritable(),s=i.__text,o=n.length;let l=e;l<0&&(l=o+l,l<0&&(l=0));const c=fi();if(r&&Xr(c)){const t=e+o;c.setTextNodeRange(i,t,i,t)}const u=s.slice(0,l)+n+s.slice(l+t);return i.__text=u,i}canInsertTextBefore(){return!0}canInsertTextAfter(){return!0}splitText(...e){Pi();const t=this.getLatest(),n=t.getTextContent(),r=t.__key,i=lt(),s=new Set(e),o=[],l=n.length;let c=\"\";for(let e=0;e<l;e++)\"\"!==c&&s.has(e)&&(o.push(c),c=\"\"),c+=n[e];\"\"!==c&&o.push(c);const u=o.length;if(0===u)return[];if(o[0]===n)return[t];const a=o[0],f=t.getParentOrThrow();let d;const h=t.getFormat(),g=t.getStyle(),_=t.__detail;let p=!1;t.isSegmented()?(d=zr(a),d.__format=h,d.__style=g,d.__detail=_,p=!0):(d=t.getWritable(),d.__text=a);const y=fi(),m=[d];let x=a.length;for(let e=1;e<u;e++){const t=o[e],n=t.length,s=zr(t).getWritable();s.__format=h,s.__style=g,s.__detail=_;const l=s.__key,c=x+n;if(Xr(y)){const e=y.anchor,t=y.focus;e.key===r&&\"text\"===e.type&&e.offset>x&&e.offset<=c&&(e.key=l,e.offset-=x,y.dirty=!0),t.key===r&&\"text\"===t.type&&t.offset>x&&t.offset<=c&&(t.key=l,t.offset-=x,y.dirty=!0)}i===r&&ot(l),x=c,m.push(s)}!function(e){const t=e.getPreviousSibling(),n=e.getNextSibling();null!==t&&st(t),null!==n&&st(n)}(this);const v=f.getWritable(),T=this.getIndexWithinParent();return p?(v.splice(T,0,m),this.remove()):v.splice(T,1,m),Xr(y)&&hi(y,f,T,u-1),m}mergeWithSibling(e){const t=e===this.getPreviousSibling();t||e===this.getNextSibling()||H(50);const n=this.__key,r=e.__key,i=this.__text,s=i.length;lt()===r&&ot(n);const o=fi();if(Xr(o)){const i=o.anchor,l=o.focus;null!==i&&i.key===r&&(pi(i,t,n,e,s),o.dirty=!0),null!==l&&l.key===r&&(pi(l,t,n,e,s),o.dirty=!0)}const l=e.__text,c=t?l+i:i+l;this.setTextContent(c);const u=this.getWritable();return e.remove(),u}isTextEntity(){return!1}}function Pr(e){const t=e,n=\"700\"===t.style.fontWeight,r=\"line-through\"===t.style.textDecoration,i=\"italic\"===t.style.fontStyle,s=\"underline\"===t.style.textDecoration,o=t.style.verticalAlign;return{forChild:e=>Br(e)?(n&&e.toggleFormat(\"bold\"),r&&e.toggleFormat(\"strikethrough\"),i&&e.toggleFormat(\"italic\"),s&&e.toggleFormat(\"underline\"),\"sub\"===o&&e.toggleFormat(\"subscript\"),\"super\"===o&&e.toggleFormat(\"superscript\"),e):e,node:null}}function Dr(e){const t=\"normal\"===e.style.fontWeight;return{forChild:e=>(Br(e)&&!t&&e.toggleFormat(\"bold\"),e),node:null}}const Ir=new WeakMap;function Or(e){return\"PRE\"===e.nodeName||e.nodeType===ie&&void 0!==e.style&&void 0!==e.style.whiteSpace&&e.style.whiteSpace.startsWith(\"pre\")}function Ar(e){const t=e;null===e.parentElement&&H(129);let n=t.textContent||\"\";if(null!==function(e){let t,n=e.parentNode;const r=[e];for(;null!==n&&void 0===(t=Ir.get(n))&&!Or(n);)r.push(n),n=n.parentNode;const i=void 0===t?n:t;for(let e=0;e<r.length;e++)Ir.set(r[e],i);return i}(t)){const e=n.split(/(\\r?\\n|\\t)/),t=[],r=e.length;for(let n=0;n<r;n++){const r=e[n];\"\\n\"===r||\"\\r\\n\"===r?t.push(xr()):\"\\t\"===r?t.push(Kr()):\"\"!==r&&t.push(zr(r))}return{node:t}}if(n=n.replace(/\\r/g,\"\").replace(/[ \\t\\n]+/g,\" \"),\"\"===n)return{node:null};if(\" \"===n[0]){let e=t,r=!0;for(;null!==e&&null!==(e=Fr(e,!1));){const t=e.textContent||\"\";if(t.length>0){/[ \\t\\n]$/.test(t)&&(n=n.slice(1)),r=!1;break}}r&&(n=n.slice(1))}if(\" \"===n[n.length-1]){let e=t,r=!0;for(;null!==e&&null!==(e=Fr(e,!0));){if((e.textContent||\"\").replace(/^( |\\t|\\r?\\n)+/,\"\").length>0){r=!1;break}}r&&(n=n.slice(0,n.length-1))}return\"\"===n?{node:null}:{node:zr(n)}}const Lr=new RegExp(/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/,\"i\");function Fr(e,t){let n=e;for(;;){let e;for(;null===(e=t?n.nextSibling:n.previousSibling);){const e=n.parentElement;if(null===e)return null;n=e}if(n=e,n.nodeType===ie){const e=n.style.display;if(\"\"===e&&null===n.nodeName.match(Lr)||\"\"!==e&&!e.startsWith(\"inline\"))return null}let r=n;for(;null!==(r=t?n.firstChild:n.lastChild);)n=r;if(n.nodeType===se)return n;if(\"BR\"===n.nodeName)return null}}const Mr={code:\"code\",em:\"italic\",i:\"italic\",s:\"strikethrough\",strong:\"bold\",sub:\"subscript\",sup:\"superscript\",u:\"underline\"};function Wr(e){const t=Mr[e.nodeName.toLowerCase()];return void 0===t?{node:null}:{forChild:e=>(Br(e)&&!e.hasFormat(t)&&e.toggleFormat(t),e),node:null}}function zr(e=\"\"){return Yt(new Er(e))}function Br(e){return e instanceof Er}class Rr extends Er{static getType(){return\"tab\"}static clone(e){const t=new Rr(e.__key);return t.__text=e.__text,t.__format=e.__format,t.__style=e.__style,t}constructor(e){super(\"\\t\",e),this.__detail=2}static importDOM(){return null}static importJSON(e){const t=Kr();return t.setFormat(e.format),t.setStyle(e.style),t}exportJSON(){return{...super.exportJSON(),type:\"tab\",version:1}}setTextContent(e){H(126)}setDetail(e){H(127)}setMode(e){H(128)}canInsertTextBefore(){return!1}canInsertTextAfter(){return!1}}function Kr(){return Yt(new Rr)}function Jr(e){return e instanceof Rr}class Ur{constructor(e,t,n){this._selection=null,this.key=e,this.offset=t,this.type=n}is(e){return this.key===e.key&&this.offset===e.offset&&this.type===e.type}isBefore(e){let t=this.getNode(),n=e.getNode();const r=this.offset,i=e.offset;if(qi(t)){const e=t.getDescendantByIndex(r);t=null!=e?e:t}if(qi(n)){const e=n.getDescendantByIndex(i);n=null!=e?e:n}return t===n?r<i:t.isBefore(n)}getNode(){const e=ct(this.key);return null===e&&H(20),e}set(e,t,n){const r=this._selection,i=this.key;this.key=e,this.offset=t,this.type=n,Ei()||(lt()===i&&ot(e),null!==r&&(r.setCachedNodes(null),r.dirty=!0))}}function Vr(e,t,n){return new Ur(e,t,n)}function $r(e,t){let n=t.__key,r=e.offset,i=\"element\";if(Br(t)){i=\"text\";const e=t.getTextContentSize();r>e&&(r=e)}else if(!qi(t)){const e=t.getNextSibling();if(Br(e))n=e.__key,r=0,i=\"text\";else{const e=t.getParent();e&&(n=e.__key,r=t.getIndexWithinParent()+1)}}e.set(n,r,i)}function Hr(e,t){if(qi(t)){const n=t.getLastDescendant();qi(n)||Br(n)?$r(e,n):$r(e,t)}else $r(e,t)}function jr(e,t,n,r){const i=e.getNode(),s=i.getChildAtIndex(e.offset),o=zr(),l=Yi(i)?rs().append(o):o;o.setFormat(n),o.setStyle(r),null===s?i.append(l):s.insertBefore(l),e.is(t)&&t.set(o.__key,0,\"text\"),e.set(o.__key,0,\"text\")}function qr(e,t,n,r){e.key=t,e.offset=n,e.type=r}class Qr{constructor(e){this._cachedNodes=null,this._nodes=e,this.dirty=!1}getCachedNodes(){return this._cachedNodes}setCachedNodes(e){this._cachedNodes=e}is(e){if(!Zr(e))return!1;const t=this._nodes,n=e._nodes;return t.size===n.size&&Array.from(t).every((e=>n.has(e)))}isCollapsed(){return!1}isBackward(){return!1}getStartEndPoints(){return null}add(e){this.dirty=!0,this._nodes.add(e),this._cachedNodes=null}delete(e){this.dirty=!0,this._nodes.delete(e),this._cachedNodes=null}clear(){this.dirty=!0,this._nodes.clear(),this._cachedNodes=null}has(e){return this._nodes.has(e)}clone(){return new Qr(new Set(this._nodes))}extract(){return this.getNodes()}insertRawText(e){}insertText(){}insertNodes(e){const t=this.getNodes(),n=t.length,r=t[n-1];let i;if(Br(r))i=r.select();else{const e=r.getIndexWithinParent()+1;i=r.getParentOrThrow().select(e,e)}i.insertNodes(e);for(let e=0;e<n;e++)t[e].remove()}getNodes(){const e=this._cachedNodes;if(null!==e)return e;const t=this._nodes,n=[];for(const e of t){const t=ct(e);null!==t&&n.push(t)}return Ei()||(this._cachedNodes=n),n}getTextContent(){const e=this.getNodes();let t=\"\";for(let n=0;n<e.length;n++)t+=e[n].getTextContent();return t}}function Xr(e){return e instanceof Yr}class Yr{constructor(e,t,n,r){this.anchor=e,this.focus=t,e._selection=this,t._selection=this,this._cachedNodes=null,this.format=n,this.style=r,this.dirty=!1}getCachedNodes(){return this._cachedNodes}setCachedNodes(e){this._cachedNodes=e}is(e){return!!Xr(e)&&(this.anchor.is(e.anchor)&&this.focus.is(e.focus)&&this.format===e.format&&this.style===e.style)}isCollapsed(){return this.anchor.is(this.focus)}getNodes(){const e=this._cachedNodes;if(null!==e)return e;const t=this.anchor,n=this.focus,r=t.isBefore(n),i=r?t:n,s=r?n:t;let o=i.getNode(),l=s.getNode();const c=i.offset,u=s.offset;if(qi(o)){const e=o.getDescendantByIndex(c);o=null!=e?e:o}if(qi(l)){let e=l.getDescendantByIndex(u);null!==e&&e!==o&&l.getChildAtIndex(u)===e&&(e=e.getPreviousSibling()),l=null!=e?e:l}let a;return a=o.is(l)?qi(o)&&o.getChildrenSize()>0?[]:[o]:o.getNodesBetween(l),Ei()||(this._cachedNodes=a),a}setTextNodeRange(e,t,n,r){qr(this.anchor,e.__key,t,\"text\"),qr(this.focus,n.__key,r,\"text\"),this._cachedNodes=null,this.dirty=!0}getTextContent(){const e=this.getNodes();if(0===e.length)return\"\";const t=e[0],n=e[e.length-1],r=this.anchor,i=this.focus,s=r.isBefore(i),[o,l]=ei(this);let c=\"\",u=!0;for(let a=0;a<e.length;a++){const f=e[a];if(qi(f)&&!f.isInline())u||(c+=\"\\n\"),u=!f.isEmpty();else if(u=!1,Br(f)){let e=f.getTextContent();f===t?f===n?\"element\"===r.type&&\"element\"===i.type&&i.offset!==r.offset||(e=o<l?e.slice(o,l):e.slice(l,o)):e=s?e.slice(o):e.slice(l):f===n&&(e=s?e.slice(0,l):e.slice(0,o)),c+=e}else!Hi(f)&&!vr(f)||f===n&&this.isCollapsed()||(c+=f.getTextContent())}return c}applyDOMRange(e){const t=Oi(),n=t.getEditorState()._selection,r=si(e.startContainer,e.startOffset,e.endContainer,e.endOffset,t,n);if(null===r)return;const[i,s]=r;qr(this.anchor,i.key,i.offset,i.type),qr(this.focus,s.key,s.offset,s.type),this._cachedNodes=null}clone(){const e=this.anchor,t=this.focus;return new Yr(Vr(e.key,e.offset,e.type),Vr(t.key,t.offset,t.type),this.format,this.style)}toggleFormat(e){this.format=tt(this.format,e,null),this.dirty=!0}setStyle(e){this.style=e,this.dirty=!0}hasFormat(e){const t=be[e];return 0!=(this.format&t)}insertRawText(e){const t=e.split(/(\\r?\\n|\\t)/),n=[],r=t.length;for(let e=0;e<r;e++){const r=t[e];\"\\n\"===r||\"\\r\\n\"===r?n.push(xr()):\"\\t\"===r?n.push(Kr()):n.push(zr(r))}this.insertNodes(n)}insertText(e){const t=this.anchor,n=this.focus,r=this.isCollapsed()||t.isBefore(n),i=this.format,s=this.style;r&&\"element\"===t.type?jr(t,n,i,s):r||\"element\"!==n.type||jr(n,t,i,s);const o=this.getNodes(),l=o.length,c=r?n:t,u=(r?t:n).offset,a=c.offset;let f=o[0];Br(f)||H(26);const d=f.getTextContent().length,h=f.getParentOrThrow();let g=o[l-1];if(this.isCollapsed()&&u===d&&(f.isSegmented()||f.isToken()||!f.canInsertTextAfter()||!h.canInsertTextAfter()&&null===f.getNextSibling())){let t=f.getNextSibling();if(Br(t)&&t.canInsertTextBefore()&&!Ze(t)||(t=zr(),t.setFormat(i),h.canInsertTextAfter()?f.insertAfter(t):h.insertAfter(t)),t.select(0,0),f=t,\"\"!==e)return void this.insertText(e)}else if(this.isCollapsed()&&0===u&&(f.isSegmented()||f.isToken()||!f.canInsertTextBefore()||!h.canInsertTextBefore()&&null===f.getPreviousSibling())){let t=f.getPreviousSibling();if(Br(t)&&!Ze(t)||(t=zr(),t.setFormat(i),h.canInsertTextBefore()?f.insertBefore(t):h.insertBefore(t)),t.select(),f=t,\"\"!==e)return void this.insertText(e)}else if(f.isSegmented()&&u!==d){const e=zr(f.getTextContent());e.setFormat(i),f.replace(e),f=e}else if(!this.isCollapsed()&&\"\"!==e){const t=g.getParent();if(!h.canInsertTextBefore()||!h.canInsertTextAfter()||qi(t)&&(!t.canInsertTextBefore()||!t.canInsertTextAfter()))return this.insertText(\"\"),ii(this.anchor,this.focus,null),void this.insertText(e)}if(1===l){if(f.isToken()){const t=zr(e);return t.select(),void f.replace(t)}const t=f.getFormat(),n=f.getStyle();if(u!==a||t===i&&n===s){if(Jr(f)){const t=zr(e);return t.setFormat(i),t.setStyle(s),t.select(),void f.replace(t)}}else{if(\"\"!==f.getTextContent()){const t=zr(e);if(t.setFormat(i),t.setStyle(s),t.select(),0===u)f.insertBefore(t,!1);else{const[e]=f.splitText(u);e.insertAfter(t,!1)}return void(t.isComposing()&&\"text\"===this.anchor.type&&(this.anchor.offset-=e.length))}f.setFormat(i),f.setStyle(s)}const r=a-u;f=f.spliceText(u,r,e,!0),\"\"===f.getTextContent()?f.remove():\"text\"===this.anchor.type&&(f.isComposing()?this.anchor.offset-=e.length:(this.format=t,this.style=n))}else{const t=new Set([...f.getParentKeys(),...g.getParentKeys()]),n=qi(f)?f:f.getParentOrThrow();let r=qi(g)?g:g.getParentOrThrow(),i=g;if(!n.is(r)&&r.isInline())do{i=r,r=r.getParentOrThrow()}while(r.isInline());if(\"text\"===c.type&&(0!==a||\"\"===g.getTextContent())||\"element\"===c.type&&g.getIndexWithinParent()<a)if(Br(g)&&!g.isToken()&&a!==g.getTextContentSize()){if(g.isSegmented()){const e=zr(g.getTextContent());g.replace(e),g=e}Yi(c.getNode())||\"text\"!==c.type||(g=g.spliceText(0,a,\"\")),t.add(g.__key)}else{const e=g.getParentOrThrow();e.canBeEmpty()||1!==e.getChildrenSize()?g.remove():e.remove()}else t.add(g.__key);const s=r.getChildren(),h=new Set(o),_=n.is(r),p=n.isInline()&&null===f.getNextSibling()?n:f;for(let e=s.length-1;e>=0;e--){const t=s[e];if(t.is(f)||qi(t)&&t.isParentOf(f))break;t.isAttached()&&(!h.has(t)||t.is(i)?_||p.insertAfter(t,!1):t.remove())}if(!_){let e=r,n=null;for(;null!==e;){const r=e.getChildren(),i=r.length;(0===i||r[i-1].is(n))&&(t.delete(e.__key),n=e),e=e.getParent()}}if(f.isToken())if(u===d)f.select();else{const t=zr(e);t.select(),f.replace(t)}else f=f.spliceText(u,d-u,e,!0),\"\"===f.getTextContent()?f.remove():f.isComposing()&&\"text\"===this.anchor.type&&(this.anchor.offset-=e.length);for(let e=1;e<l;e++){const n=o[e],r=n.__key;t.has(r)||n.remove()}}}removeText(){this.insertText(\"\")}formatText(e){if(this.isCollapsed())return this.toggleFormat(e),void ot(null);const t=this.getNodes(),n=[];for(const e of t)Br(e)&&n.push(e);const r=n.length;if(0===r)return this.toggleFormat(e),void ot(null);const i=this.anchor,s=this.focus,o=this.isBackward(),l=o?s:i,c=o?i:s;let u=0,a=n[0],f=\"element\"===l.type?0:l.offset;if(\"text\"===l.type&&f===a.getTextContentSize()&&(u=1,a=n[1],f=0),null==a)return;const d=a.getFormatFlags(e,null),h=r-1;let g=n[h];const _=\"text\"===c.type?c.offset:g.getTextContentSize();if(a.is(g)){if(f===_)return;if(0===f&&_===a.getTextContentSize())a.setFormat(d);else{const e=a.splitText(f,_),t=0===f?e[0]:e[1];t.setFormat(d),\"text\"===l.type&&l.set(t.__key,0,\"text\"),\"text\"===c.type&&c.set(t.__key,_-f,\"text\")}return void(this.format=d)}0!==f&&([,a]=a.splitText(f),f=0),a.setFormat(d);const p=g.getFormatFlags(e,d);_>0&&(_!==g.getTextContentSize()&&([g]=g.splitText(_)),g.setFormat(p));for(let t=u+1;t<h;t++){const r=n[t];if(!r.isToken()){const t=r.getFormatFlags(e,p);r.setFormat(t)}}\"text\"===l.type&&l.set(a.__key,f,\"text\"),\"text\"===c.type&&c.set(g.__key,_,\"text\"),this.format=d|p}insertNodes(e){if(0===e.length)return;if(\"root\"===this.anchor.key){this.insertParagraph();const t=fi();return Xr(t)||H(134),t.insertNodes(e)}const t=cn((this.isBackward()?this.focus:this.anchor).getNode(),ln),n=e[e.length-1];if(\"__language\"in t&&qi(t)){if(\"__language\"in e[0])this.insertText(e[0].getTextContent());else{const r=vi(this);t.splice(r,0,e),n.selectEnd()}return}if(!e.some((e=>(qi(e)||Hi(e))&&!e.isInline()))){qi(t)||H(135);const r=vi(this);return t.splice(r,0,e),void n.selectEnd()}const r=function(e){const t=rs();let n=null;for(let r=0;r<e.length;r++){const i=e[r],s=vr(i);if(s||Hi(i)&&i.isInline()||qi(i)&&i.isInline()||Br(i)||i.isParentRequired()){if(null===n&&(n=i.createParentElementNode(),t.append(n),s))continue;null!==n&&n.append(i)}else t.append(i),n=null}return t}(e),i=r.getLastDescendant(),s=r.getChildren(),o=e=>\"__value\"in e&&\"__checked\"in e,l=!qi(t)||!t.isEmpty()?this.insertParagraph():null,c=s[s.length-1];let u=s[0];var a;qi(a=u)&&ln(a)&&!a.isEmpty()&&qi(t)&&(!t.isEmpty()||o(t))&&(qi(t)||H(135),t.append(...u.getChildren()),u=s[1]),u&&function(e,t,n){const r=n||t.getParentOrThrow().getLastChild();let i=t;const s=[t];for(;i!==r;)i.getNextSibling()||H(140),i=i.getNextSibling(),s.push(i);let o=e;for(const e of s)o=o.insertAfter(e)}(t,u);const f=cn(i,ln);l&&qi(f)&&(o(l)||ln(c))&&(f.append(...l.getChildren()),l.remove()),qi(t)&&t.isEmpty()&&t.remove(),i.selectEnd();const d=qi(t)?t.getLastChild():null;vr(d)&&f!==t&&d.remove()}insertParagraph(){if(\"root\"===this.anchor.key){const e=rs();return ht().splice(this.anchor.offset,0,[e]),e.select(),e}const e=vi(this),t=cn(this.anchor.getNode(),ln);qi(t)||H(136);const n=t.getChildAtIndex(e),r=n?[n,...n.getNextSiblings()]:[],i=t.insertNewAfter(this,!1);return i?(i.append(...r),i.selectStart(),i):null}insertLineBreak(e){const t=xr();if(this.insertNodes([t]),e){const e=t.getParentOrThrow(),n=t.getIndexWithinParent();e.select(n,n)}}extract(){const e=this.getNodes(),t=e.length,n=t-1,r=this.anchor,i=this.focus;let s=e[0],o=e[n];const[l,c]=ei(this);if(0===t)return[];if(1===t){if(Br(s)&&!this.isCollapsed()){const e=l>c?c:l,t=l>c?l:c,n=s.splitText(e,t),r=0===e?n[0]:n[1];return null!=r?[r]:[]}return[s]}const u=r.isBefore(i);if(Br(s)){const t=u?l:c;t===s.getTextContentSize()?e.shift():0!==t&&([,s]=s.splitText(t),e[0]=s)}if(Br(o)){const t=o.getTextContent().length,r=u?c:l;0===r?e.pop():r!==t&&([o]=o.splitText(r),e[n]=o)}return e}modify(e,t,n){const r=this.focus,i=this.anchor,s=\"move\"===e,o=Wt(r,t);if(Hi(o)&&!o.isIsolated()){if(s&&o.isKeyboardSelectable()){const e=ui();return e.add(o.__key),void _t(e)}const e=t?o.getPreviousSibling():o.getNextSibling();if(Br(e)){const n=e.__key,o=t?e.getTextContent().length:0;return r.set(n,o,\"text\"),void(s&&i.set(n,o,\"text\"))}{const n=o.getParentOrThrow();let l,c;return qi(e)?(c=e.__key,l=t?e.getChildrenSize():0):(l=o.getIndexWithinParent(),c=n.__key,t||l++),r.set(c,l,\"element\"),void(s&&i.set(c,l,\"element\"))}}const l=Oi(),c=nn(l._window);if(!c)return;const u=l._blockCursorElement,a=l._rootElement;if(null===a||null===u||!qi(o)||o.isInline()||o.canBeEmpty()||en(u,l,a),function(e,t,n,r){e.modify(t,n,r)}(c,e,t?\"backward\":\"forward\",n),c.rangeCount>0){const e=c.getRangeAt(0),n=this.anchor.getNode(),r=Yi(n)?n:qt(n);if(this.applyDOMRange(e),this.dirty=!0,!s){const n=this.getNodes(),i=[];let s=!1;for(let e=0;e<n.length;e++){const t=n[e];$t(t,r)?i.push(t):s=!0}if(s&&i.length>0)if(t){const e=i[0];qi(e)?e.selectStart():e.getParentOrThrow().selectStart()}else{const e=i[i.length-1];qi(e)?e.selectEnd():e.getParentOrThrow().selectEnd()}c.anchorNode===e.startContainer&&c.anchorOffset===e.startOffset||function(e){const t=e.focus,n=e.anchor,r=n.key,i=n.offset,s=n.type;qr(n,t.key,t.offset,t.type),qr(t,r,i,s),e._cachedNodes=null}(this)}}}forwardDeletion(e,t,n){if(!n&&(\"element\"===e.type&&qi(t)&&e.offset===t.getChildrenSize()||\"text\"===e.type&&e.offset===t.getTextContentSize())){const e=t.getParent(),n=t.getNextSibling()||(null===e?null:e.getNextSibling());if(qi(n)&&n.isShadowRoot())return!0}return!1}deleteCharacter(e){const n=this.isCollapsed();if(this.isCollapsed()){const n=this.anchor;let r=n.getNode();if(this.forwardDeletion(n,r,e))return;const i=this.focus,s=Wt(i,e);if(Hi(s)&&!s.isIsolated()){if(s.isKeyboardSelectable()&&qi(r)&&0===r.getChildrenSize()){r.remove();const e=ui();e.add(s.__key),_t(e)}else{s.remove();Oi().dispatchCommand(t,void 0)}return}if(!e&&qi(s)&&qi(r)&&r.isEmpty())return r.remove(),void s.selectStart();if(this.modify(\"extend\",e,\"character\"),this.isCollapsed()){if(e&&0===n.offset){if((\"element\"===n.type?n.getNode():n.getNode().getParentOrThrow()).collapseAtStart(this))return}}else{const t=\"text\"===i.type?i.getNode():null;if(r=\"text\"===n.type?n.getNode():null,null!==t&&t.isSegmented()){const n=i.offset,s=t.getTextContentSize();if(t.is(r)||e&&n!==s||!e&&0!==n)return void ti(t,e,n)}else if(null!==r&&r.isSegmented()){const i=n.offset,s=r.getTextContentSize();if(r.is(t)||e&&0!==i||!e&&i!==s)return void ti(r,e,i)}!function(e,t){const n=e.anchor,r=e.focus,i=n.getNode(),s=r.getNode();if(i===s&&\"text\"===n.type&&\"text\"===r.type){const e=n.offset,s=r.offset,o=e<s,l=o?e:s,c=o?s:e,u=c-1;if(l!==u){mt(i.getTextContent().slice(l,c))||(t?r.offset=u:n.offset=u)}}}(this,e)}}if(this.removeText(),e&&!n&&this.isCollapsed()&&\"element\"===this.anchor.type&&0===this.anchor.offset){const e=this.anchor.getNode();e.isEmpty()&&Yi(e.getParent())&&0===e.getIndexWithinParent()&&e.collapseAtStart(this)}}deleteLine(e){if(this.isCollapsed()){\"text\"===this.anchor.type&&this.modify(\"extend\",e,\"lineboundary\");0===(e?this.focus:this.anchor).offset&&this.modify(\"extend\",e,\"character\")}this.removeText()}deleteWord(e){if(this.isCollapsed()){const t=this.anchor,n=t.getNode();if(this.forwardDeletion(t,n,e))return;this.modify(\"extend\",e,\"word\")}this.removeText()}isBackward(){return this.focus.isBefore(this.anchor)}getStartEndPoints(){return[this.anchor,this.focus]}}function Zr(e){return e instanceof Qr}function Gr(e){const t=e.offset;if(\"text\"===e.type)return t;const n=e.getNode();return t===n.getChildrenSize()?n.getTextContent().length:0}function ei(e){const t=e.getStartEndPoints();if(null===t)return[0,0];const[n,r]=t;return\"element\"===n.type&&\"element\"===r.type&&n.key===r.key&&n.offset===r.offset?[0,0]:[Gr(n),Gr(r)]}function ti(e,t,n){const r=e,i=r.getTextContent().split(/(?=\\s)/g),s=i.length;let o=0,l=0;for(let e=0;e<s;e++){const r=e===s-1;if(l=o,o+=i[e].length,t&&o===n||o>n||r){i.splice(e,1),r&&(l=void 0);break}}const c=i.join(\"\").trim();\"\"===c?r.remove():(r.setTextContent(c),r.select(l,l))}function ni(e,t,n,r){let i,s=t;if(e.nodeType===ie){let o=!1;const l=e.childNodes,c=l.length;s===c&&(o=!0,s=c-1);let u=l[s],a=!1;if(u===r._blockCursorElement?(u=l[s+1],a=!0):null!==r._blockCursorElement&&s--,i=pt(u),Br(i))s=yt(i,o);else{let r=pt(e);if(null===r)return null;if(qi(r)){let e=r.getChildAtIndex(s);if(qi(e)&&function(e,t,n){const r=e.getParent();return null===n||null===r||!r.canBeEmpty()||r!==n.getNode()}(e,0,n)){const t=o?e.getLastDescendant():e.getFirstDescendant();null===t?(r=e,s=0):(e=t,r=qi(e)?e:e.getParentOrThrow())}Br(e)?(i=e,r=null,s=yt(e,o)):e!==r&&o&&!a&&s++}else{const n=r.getIndexWithinParent();s=0===t&&Hi(r)&&pt(e)===r?n:n+1,r=r.getParentOrThrow()}if(qi(r))return Vr(r.__key,s,\"element\")}}else i=pt(e);return Br(i)?Vr(i.__key,s,\"text\"):null}function ri(e,t,n){const r=e.offset,i=e.getNode();if(0===r){const r=i.getPreviousSibling(),s=i.getParent();if(t){if((n||!t)&&null===r&&qi(s)&&s.isInline()){const t=s.getPreviousSibling();Br(t)&&(e.key=t.__key,e.offset=t.getTextContent().length)}}else qi(r)&&!n&&r.isInline()?(e.key=r.__key,e.offset=r.getChildrenSize(),e.type=\"element\"):Br(r)&&(e.key=r.__key,e.offset=r.getTextContent().length)}else if(r===i.getTextContent().length){const r=i.getNextSibling(),s=i.getParent();if(t&&qi(r)&&r.isInline())e.key=r.__key,e.offset=0,e.type=\"element\";else if((n||t)&&null===r&&qi(s)&&s.isInline()&&!s.canInsertTextAfter()){const t=s.getNextSibling();Br(t)&&(e.key=t.__key,e.offset=0)}}}function ii(e,t,n){if(\"text\"===e.type&&\"text\"===t.type){const r=e.isBefore(t),i=e.is(t);ri(e,r,i),ri(t,!r,i),i&&(t.key=e.key,t.offset=e.offset,t.type=e.type);const s=Oi();if(s.isComposing()&&s._compositionKey!==e.key&&Xr(n)){const r=n.anchor,i=n.focus;qr(e,r.key,r.offset,r.type),qr(t,i.key,i.offset,i.type)}}}function si(e,t,n,r,i,s){if(null===e||null===n||!Xe(i,e,n))return null;const o=ni(e,t,Xr(s)?s.anchor:null,i);if(null===o)return null;const l=ni(n,r,Xr(s)?s.focus:null,i);if(null===l)return null;if(\"element\"===o.type&&\"element\"===l.type){const t=pt(e),r=pt(n);if(Hi(t)&&Hi(r))return null}return ii(o,l,s),[o,l]}function oi(e){return qi(e)&&!e.isInline()}function li(e,t,n,r,i,s){const o=Ii(),l=new Yr(Vr(e,t,i),Vr(n,r,s),0,\"\");return l.dirty=!0,o._selection=l,l}function ci(){const e=Vr(\"root\",0,\"element\"),t=Vr(\"root\",0,\"element\");return new Yr(e,t,0,\"\")}function ui(){return new Qr(new Set)}function ai(e,t,n,r){const i=n._window;if(null===i)return null;const s=r||i.event,o=s?s.type:void 0,l=\"selectionchange\"===o,c=!Ae&&(l||\"beforeinput\"===o||\"compositionstart\"===o||\"compositionend\"===o||\"click\"===o&&s&&3===s.detail||\"drop\"===o||void 0===o);let u,a,f,d;if(Xr(e)&&!c)return e.clone();if(null===t)return null;if(u=t.anchorNode,a=t.focusNode,f=t.anchorOffset,d=t.focusOffset,l&&Xr(e)&&!Xe(n,u,a))return e.clone();const h=si(u,f,a,d,n,e);if(null===h)return null;const[g,_]=h;return new Yr(g,_,Xr(e)?e.format:0,Xr(e)?e.style:\"\")}function fi(){return Ii()._selection}function di(){return Oi()._editorState._selection}function hi(e,t,n,r=1){const i=e.anchor,s=e.focus,o=i.getNode(),l=s.getNode();if(!t.is(o)&&!t.is(l))return;const c=t.__key;if(e.isCollapsed()){const t=i.offset;if(n<=t&&r>0||n<t&&r<0){const n=Math.max(0,t+r);i.set(c,n,\"element\"),s.set(c,n,\"element\"),gi(e)}}else{const o=e.isBackward(),l=o?s:i,u=l.getNode(),a=o?i:s,f=a.getNode();if(t.is(u)){const e=l.offset;(n<=e&&r>0||n<e&&r<0)&&l.set(c,Math.max(0,e+r),\"element\")}if(t.is(f)){const e=a.offset;(n<=e&&r>0||n<e&&r<0)&&a.set(c,Math.max(0,e+r),\"element\")}}gi(e)}function gi(e){const t=e.anchor,n=t.offset,r=e.focus,i=r.offset,s=t.getNode(),o=r.getNode();if(e.isCollapsed()){if(!qi(s))return;const e=s.getChildrenSize(),i=n>=e,o=i?s.getChildAtIndex(e-1):s.getChildAtIndex(n);if(Br(o)){let e=0;i&&(e=o.getTextContentSize()),t.set(o.__key,e,\"text\"),r.set(o.__key,e,\"text\")}}else{if(qi(s)){const e=s.getChildrenSize(),r=n>=e,i=r?s.getChildAtIndex(e-1):s.getChildAtIndex(n);if(Br(i)){let e=0;r&&(e=i.getTextContentSize()),t.set(i.__key,e,\"text\")}}if(qi(o)){const e=o.getChildrenSize(),t=i>=e,n=t?o.getChildAtIndex(e-1):o.getChildAtIndex(i);if(Br(n)){let e=0;t&&(e=n.getTextContentSize()),r.set(n.__key,e,\"text\")}}}}function _i(e,t,n,r,i){let s=null,o=0,l=null;null!==r?(s=r.__key,Br(r)?(o=r.getTextContentSize(),l=\"text\"):qi(r)&&(o=r.getChildrenSize(),l=\"element\")):null!==i&&(s=i.__key,Br(i)?l=\"text\":qi(i)&&(l=\"element\")),null!==s&&null!==l?e.set(s,o,l):(o=t.getIndexWithinParent(),-1===o&&(o=n.getChildrenSize()),e.set(n.__key,o,\"element\"))}function pi(e,t,n,r,i){\"text\"===e.type?(e.key=n,t||(e.offset+=i)):e.offset>r.getIndexWithinParent()&&(e.offset-=1)}function yi(e,t,n,r,i,s,o){const l=r.anchorNode,c=r.focusNode,u=r.anchorOffset,a=r.focusOffset,f=document.activeElement;if(i.has(\"collaboration\")&&f!==s||null!==f&&Qe(f))return;if(!Xr(t))return void(null!==e&&Xe(n,l,c)&&r.removeAllRanges());const d=t.anchor,h=t.focus,g=d.key,_=h.key,p=Kt(n,g),y=Kt(n,_),m=d.offset,x=h.offset,v=t.format,T=t.style,S=t.isCollapsed();let k=p,C=y,b=!1;if(\"text\"===d.type){k=et(p);const e=d.getNode();b=e.getFormat()!==v||e.getStyle()!==T}else Xr(e)&&\"text\"===e.anchor.type&&(b=!0);var N,w,E,P,D;if((\"text\"===h.type&&(C=et(y)),null!==k&&null!==C)&&(S&&(null===e||b||Xr(e)&&(e.format!==v||e.style!==T))&&(N=v,w=T,E=m,P=g,D=performance.now(),rr=[N,w,E,P,D]),u!==m||a!==x||l!==k||c!==C||\"Range\"===r.type&&S||(null!==f&&s.contains(f)||s.focus({preventScroll:!0}),\"element\"===d.type))){try{r.setBaseAndExtent(k,m,C,x)}catch(e){}if(!i.has(\"skip-scroll-into-view\")&&t.isCollapsed()&&null!==s&&s===document.activeElement){const e=t instanceof Yr&&\"element\"===t.anchor.type?k.childNodes[m]||null:r.rangeCount>0?r.getRangeAt(0):null;if(null!==e){let t;if(e instanceof Text){const n=document.createRange();n.selectNode(e),t=n.getBoundingClientRect()}else t=e.getBoundingClientRect();!function(e,t,n){const r=n.ownerDocument,i=r.defaultView;if(null===i)return;let{top:s,bottom:o}=t,l=0,c=0,u=n;for(;null!==u;){const t=u===r.body;if(t)l=0,c=Ht(e).innerHeight;else{const e=u.getBoundingClientRect();l=e.top,c=e.bottom}let n=0;if(s<l?n=-(l-s):o>c&&(n=o-c),0!==n)if(t)i.scrollBy(0,n);else{const e=u.scrollTop;u.scrollTop+=n;const t=u.scrollTop-e;s-=t,o-=t}if(t)break;u=Jt(u)}}(n,t,s)}}Gn=!0}}function mi(e){let t=fi()||di();null===t&&(t=ht().selectEnd()),t.insertNodes(e)}function xi(){const e=fi();return null===e?\"\":e.getTextContent()}function vi(e){e.isCollapsed()||e.removeText();const t=e.anchor;let n=t.getNode(),r=t.offset;for(;!ln(n);)[n,r]=Ti(n,r);return r}function Ti(e,t){const n=e.getParent();if(!n){const e=rs();return ht().append(e),e.select(),[ht(),0]}if(Br(e)){const r=e.splitText(t);if(0===r.length)return[n,e.getIndexWithinParent()];const i=0===t?0:1;return[n,r[0].getIndexWithinParent()+i]}if(!qi(e)||0===t)return[n,e.getIndexWithinParent()];const r=e.getChildAtIndex(t);if(r){const n=new Yr(Vr(e.__key,t,\"element\"),Vr(e.__key,t,\"element\"),0,\"\"),i=e.insertNewAfter(n);i&&i.append(r,...r.getNextSiblings())}return[n,e.getIndexWithinParent()+1]}let Si=null,ki=null,Ci=!1,bi=!1,Ni=0;const wi={characterData:!0,childList:!0,subtree:!0};function Ei(){return Ci||null!==Si&&Si._readOnly}function Pi(){Ci&&H(13)}function Di(){Ni>99&&H(14)}function Ii(){return null===Si&&H(15),Si}function Oi(){return null===ki&&H(16),ki}function Ai(){return ki}function Li(e,t,n){const r=t.__type,i=function(e,t){const n=e._nodes.get(t);return void 0===n&&H(30,t),n}(e,r);let s=n.get(r);void 0===s&&(s=Array.from(i.transforms),n.set(r,s));const o=s.length;for(let e=0;e<o&&(s[e](t),t.isAttached());e++);}function Fi(e,t){return void 0!==e&&e.__key!==t&&e.isAttached()}function Mi(e){return Wi(e,Oi()._nodes)}function Wi(e,t){const n=e.type,r=t.get(n);void 0===r&&H(17,n);const i=r.klass;e.type!==i.getType()&&H(18,i.name);const s=i.importJSON(e),o=e.children;if(qi(s)&&Array.isArray(o))for(let e=0;e<o.length;e++){const n=Wi(o[e],t);s.append(n)}return s}function zi(e,t){const n=Si,r=Ci,i=ki;Si=e,Ci=!0,ki=null;try{return t()}finally{Si=n,Ci=r,ki=i}}function Bi(e,n){const r=e._pendingEditorState,i=e._rootElement,s=e._headless||null===i;if(null===r)return;const o=e._editorState,l=o._selection,c=r._selection,u=e._dirtyType!==oe,a=Si,f=Ci,d=ki,h=e._updating,g=e._observer;let _=null;if(e._pendingEditorState=null,e._editorState=r,!s&&u&&null!==g){ki=e,Si=r,Ci=!1,e._updating=!0;try{const t=e._dirtyType,n=e._dirtyElements,i=e._dirtyLeaves;g.disconnect(),_=Un(o,r,e,t,n,i)}catch(t){if(t instanceof Error&&e._onError(t),bi)throw t;return as(e,null,i,r),Ke(e),e._dirtyType=ce,bi=!0,Bi(e,o),void(bi=!1)}finally{g.observe(i,wi),e._updating=h,Si=a,Ci=f,ki=d}}r._readOnly||(r._readOnly=!0);const p=e._dirtyLeaves,y=e._dirtyElements,m=e._normalizedNodes,x=e._updateTags,v=e._deferred;u&&(e._dirtyType=oe,e._cloneNotNeeded.clear(),e._dirtyLeaves=new Set,e._dirtyElements=new Map,e._normalizedNodes=new Set,e._updateTags=new Set),function(e,t){const n=e._decorators;let r=e._pendingDecorators||n;const i=t._nodeMap;let s;for(s in r)i.has(s)||(r===n&&(r=ft(e)),delete r[s])}(e,r);const T=s?null:nn(e._window);if(e._editable&&null!==T&&(u||null===c||c.dirty)){ki=e,Si=r;try{if(null!==g&&g.disconnect(),u||null===c||c.dirty){const t=e._blockCursorElement;null!==t&&en(t,e,i),yi(l,c,e,T,x,i)}tn(e,i,c),null!==g&&g.observe(i,wi)}finally{ki=d,Si=a}}null!==_&&function(e,t,n,r,i){const s=Array.from(e._listeners.mutation),o=s.length;for(let e=0;e<o;e++){const[o,l]=s[e],c=t.get(l);void 0!==c&&o(c,{dirtyLeaves:r,prevEditorState:i,updateTags:n})}}(e,_,x,p,o),Xr(c)||null===c||null!==l&&l.is(c)||e.dispatchCommand(t,void 0);const S=e._pendingDecorators;null!==S&&(e._decorators=S,e._pendingDecorators=null,Ri(\"decorator\",e,!0,S)),function(e,t,n){const r=dt(t),i=dt(n);r!==i&&Ri(\"textcontent\",e,!0,i)}(e,n||o,r),Ri(\"update\",e,!0,{dirtyElements:y,dirtyLeaves:p,editorState:r,normalizedNodes:m,prevEditorState:n||o,tags:x}),function(e,t){if(e._deferred=[],0!==t.length){const n=e._updating;e._updating=!0;try{for(let e=0;e<t.length;e++)t[e]()}finally{e._updating=n}}}(e,v),function(e){const t=e._updates;if(0!==t.length){const n=t.shift();if(n){const[t,r]=n;Ui(e,t,r)}}}(e)}function Ri(e,t,n,...r){const i=t._updating;t._updating=n;try{const n=Array.from(t._listeners[e]);for(let e=0;e<n.length;e++)n[e].apply(null,r)}finally{t._updating=i}}function Ki(e,t,n){if(!1===e._updating||ki!==e){let r=!1;return e.update((()=>{r=Ki(e,t,n)})),r}const r=xt(e);for(let i=4;i>=0;i--)for(let s=0;s<r.length;s++){const o=r[s]._commands.get(t);if(void 0!==o){const t=o[i];if(void 0!==t){const r=Array.from(t),i=r.length;for(let t=0;t<i;t++)if(!0===r[t](n,e))return!0}}}return!1}function Ji(e,t){const n=e._updates;let r=t||!1;for(;0!==n.length;){const t=n.shift();if(t){const[n,i]=t;let s,o;void 0!==i&&(s=i.onUpdate,o=i.tag,i.skipTransforms&&(r=!0),s&&e._deferred.push(s),o&&e._updateTags.add(o)),n()}}return r}function Ui(e,t,n){const r=e._updateTags;let i,s,o=!1,l=!1;void 0!==n&&(i=n.onUpdate,s=n.tag,null!=s&&r.add(s),o=n.skipTransforms||!1,l=n.discrete||!1),i&&e._deferred.push(i);const c=e._editorState;let u=e._pendingEditorState,a=!1;(null===u||u._readOnly)&&(u=e._pendingEditorState=new es(new Map((u||c)._nodeMap)),a=!0),u._flushSync=l;const f=Si,d=Ci,h=ki,g=e._updating;Si=u,Ci=!1,e._updating=!0,ki=e;try{a&&(e._headless?null!==c._selection&&(u._selection=c._selection.clone()):u._selection=function(e){const t=e.getEditorState()._selection,n=nn(e._window);return Xr(t)||null==t?ai(t,n,e,null):t.clone()}(e));const n=e._compositionKey;t(),o=Ji(e,o),function(e,t){const n=t.getEditorState()._selection,r=e._selection;if(Xr(r)){const e=r.anchor,t=r.focus;let i;if(\"text\"===e.type&&(i=e.getNode(),i.selectionTransform(n,r)),\"text\"===t.type){const e=t.getNode();i!==e&&e.selectionTransform(n,r)}}}(u,e),e._dirtyType!==oe&&(o?function(e,t){const n=t._dirtyLeaves,r=e._nodeMap;for(const e of n){const t=r.get(e);Br(t)&&t.isAttached()&&t.isSimpleText()&&!t.isUnmergeable()&&Ve(t)}}(u,e):function(e,t){const n=t._dirtyLeaves,r=t._dirtyElements,i=e._nodeMap,s=lt(),o=new Map;let l=n,c=l.size,u=r,a=u.size;for(;c>0||a>0;){if(c>0){t._dirtyLeaves=new Set;for(const e of l){const r=i.get(e);Br(r)&&r.isAttached()&&r.isSimpleText()&&!r.isUnmergeable()&&Ve(r),void 0!==r&&Fi(r,s)&&Li(t,r,o),n.add(e)}if(l=t._dirtyLeaves,c=l.size,c>0){Ni++;continue}}t._dirtyLeaves=new Set,t._dirtyElements=new Map;for(const e of u){const n=e[0],l=e[1];if(\"root\"!==n&&!l)continue;const c=i.get(n);void 0!==c&&Fi(c,s)&&Li(t,c,o),r.set(n,l)}l=t._dirtyLeaves,c=l.size,u=t._dirtyElements,a=u.size,Ni++}t._dirtyLeaves=n,t._dirtyElements=r}(u,e),Ji(e),function(e,t,n,r){const i=e._nodeMap,s=t._nodeMap,o=[];for(const[e]of r){const t=s.get(e);void 0!==t&&(t.isAttached()||(qi(t)&&an(t,e,i,s,o,r),i.has(e)||r.delete(e),o.push(e)))}for(const e of o)s.delete(e);for(const e of n){const t=s.get(e);void 0===t||t.isAttached()||(i.has(e)||n.delete(e),s.delete(e))}}(c,u,e._dirtyLeaves,e._dirtyElements));n!==e._compositionKey&&(u._flushSync=!0);const r=u._selection;if(Xr(r)){const e=u._nodeMap,t=r.anchor.key,n=r.focus.key;void 0!==e.get(t)&&void 0!==e.get(n)||H(19)}else Zr(r)&&0===r._nodes.size&&(u._selection=null)}catch(t){return t instanceof Error&&e._onError(t),e._pendingEditorState=c,e._dirtyType=ce,e._cloneNotNeeded.clear(),e._dirtyLeaves=new Set,e._dirtyElements.clear(),void Bi(e)}finally{Si=f,Ci=d,ki=h,e._updating=g,Ni=0}const _=e._dirtyType!==oe||function(e,t){const n=t.getEditorState()._selection,r=e._selection;if(null!==r){if(r.dirty||!r.is(n))return!0}else if(null!==n)return!0;return!1}(u,e);_?u._flushSync?(u._flushSync=!1,Bi(e)):a&&qe((()=>{Bi(e)})):(u._flushSync=!1,a&&(r.clear(),e._deferred=[],e._pendingEditorState=null))}function Vi(e,t,n){e._updating?e._updates.push([t,n]):Ui(e,t,n)}class $i extends pr{constructor(e){super(e)}decorate(e,t){H(47)}isIsolated(){return!1}isInline(){return!0}isKeyboardSelectable(){return!0}}function Hi(e){return e instanceof $i}class ji extends pr{constructor(e){super(e),this.__first=null,this.__last=null,this.__size=0,this.__format=0,this.__indent=0,this.__dir=null}getFormat(){return this.getLatest().__format}getFormatType(){const e=this.getFormat();return Ee[e]||\"\"}getIndent(){return this.getLatest().__indent}getChildren(){const e=[];let t=this.getFirstChild();for(;null!==t;)e.push(t),t=t.getNextSibling();return e}getChildrenKeys(){const e=[];let t=this.getFirstChild();for(;null!==t;)e.push(t.__key),t=t.getNextSibling();return e}getChildrenSize(){return this.getLatest().__size}isEmpty(){return 0===this.getChildrenSize()}isDirty(){const e=Oi()._dirtyElements;return null!==e&&e.has(this.__key)}isLastChild(){const e=this.getLatest(),t=this.getParentOrThrow().getLastChild();return null!==t&&t.is(e)}getAllTextNodes(){const e=[];let t=this.getFirstChild();for(;null!==t;){if(Br(t)&&e.push(t),qi(t)){const n=t.getAllTextNodes();e.push(...n)}t=t.getNextSibling()}return e}getFirstDescendant(){let e=this.getFirstChild();for(;qi(e);){const t=e.getFirstChild();if(null===t)break;e=t}return e}getLastDescendant(){let e=this.getLastChild();for(;qi(e);){const t=e.getLastChild();if(null===t)break;e=t}return e}getDescendantByIndex(e){const t=this.getChildren(),n=t.length;if(e>=n){const e=t[n-1];return qi(e)&&e.getLastDescendant()||e||null}const r=t[e];return qi(r)&&r.getFirstDescendant()||r||null}getFirstChild(){const e=this.getLatest().__first;return null===e?null:ct(e)}getFirstChildOrThrow(){const e=this.getFirstChild();return null===e&&H(45,this.__key),e}getLastChild(){const e=this.getLatest().__last;return null===e?null:ct(e)}getLastChildOrThrow(){const e=this.getLastChild();return null===e&&H(96,this.__key),e}getChildAtIndex(e){const t=this.getChildrenSize();let n,r;if(e<t/2){for(n=this.getFirstChild(),r=0;null!==n&&r<=e;){if(r===e)return n;n=n.getNextSibling(),r++}return null}for(n=this.getLastChild(),r=t-1;null!==n&&r>=e;){if(r===e)return n;n=n.getPreviousSibling(),r--}return null}getTextContent(){let e=\"\";const t=this.getChildren(),n=t.length;for(let r=0;r<n;r++){const i=t[r];e+=i.getTextContent(),qi(i)&&r!==n-1&&!i.isInline()&&(e+=xe)}return e}getTextContentSize(){let e=0;const t=this.getChildren(),n=t.length;for(let r=0;r<n;r++){const i=t[r];e+=i.getTextContentSize(),qi(i)&&r!==n-1&&!i.isInline()&&(e+=xe.length)}return e}getDirection(){return this.getLatest().__dir}hasFormat(e){if(\"\"!==e){const t=we[e];return 0!=(this.getFormat()&t)}return!1}select(e,t){Pi();const n=fi();let r=e,i=t;const s=this.getChildrenSize();if(!this.canBeEmpty())if(0===e&&0===t){const e=this.getFirstChild();if(Br(e)||qi(e))return e.select(0,0)}else if(!(void 0!==e&&e!==s||void 0!==t&&t!==s)){const e=this.getLastChild();if(Br(e)||qi(e))return e.select()}void 0===r&&(r=s),void 0===i&&(i=s);const o=this.__key;return Xr(n)?(n.anchor.set(o,r,\"element\"),n.focus.set(o,i,\"element\"),n.dirty=!0,n):li(o,r,o,i,\"element\",\"element\")}selectStart(){const e=this.getFirstDescendant();return e?e.selectStart():this.select()}selectEnd(){const e=this.getLastDescendant();return e?e.selectEnd():this.select()}clear(){const e=this.getWritable();return this.getChildren().forEach((e=>e.remove())),e}append(...e){return this.splice(this.getChildrenSize(),0,e)}setDirection(e){const t=this.getWritable();return t.__dir=e,t}setFormat(e){return this.getWritable().__format=\"\"!==e?we[e]:0,this}setIndent(e){return this.getWritable().__indent=e,this}splice(e,t,n){const r=n.length,i=this.getChildrenSize(),s=this.getWritable(),o=s.__key,l=[],c=[],u=this.getChildAtIndex(e+t);let a=null,f=i-t+r;if(0!==e)if(e===i)a=this.getLastChild();else{const t=this.getChildAtIndex(e);null!==t&&(a=t.getPreviousSibling())}if(t>0){let e=null===a?this.getFirstChild():a.getNextSibling();for(let n=0;n<t;n++){null===e&&H(100);const t=e.getNextSibling(),n=e.__key;it(e.getWritable()),c.push(n),e=t}}let d=a;for(let e=0;e<r;e++){const t=n[e];null!==d&&t.is(d)&&(a=d=d.getPreviousSibling());const r=t.getWritable();r.__parent===o&&f--,it(r);const i=t.__key;if(null===d)s.__first=i,r.__prev=null;else{const e=d.getWritable();e.__next=i,r.__prev=e.__key}t.__key===o&&H(76),r.__parent=o,l.push(i),d=t}if(e+t===i){if(null!==d){d.getWritable().__next=null,s.__last=d.__key}}else if(null!==u){const e=u.getWritable();if(null!==d){const t=d.getWritable();e.__prev=d.__key,t.__next=u.__key}else e.__prev=null}if(s.__size=f,c.length){const e=fi();if(Xr(e)){const t=new Set(c),n=new Set(l),{anchor:r,focus:i}=e;Qi(r,t,n)&&_i(r,r.getNode(),this,a,u),Qi(i,t,n)&&_i(i,i.getNode(),this,a,u),0!==f||this.canBeEmpty()||Qt(this)||this.remove()}}return s}exportJSON(){return{children:[],direction:this.getDirection(),format:this.getFormatType(),indent:this.getIndent(),type:\"element\",version:1}}insertNewAfter(e,t){return null}canIndent(){return!0}collapseAtStart(e){return!1}excludeFromCopy(e){return!1}canReplaceWith(e){return!0}canInsertAfter(e){return!0}canBeEmpty(){return!0}canInsertTextBefore(){return!0}canInsertTextAfter(){return!0}isInline(){return!1}isShadowRoot(){return!1}canMergeWith(e){return!1}extractWithChild(e,t,n){return!1}}function qi(e){return e instanceof ji}function Qi(e,t,n){let r=e.getNode();for(;r;){const e=r.__key;if(t.has(e)&&!n.has(e))return!0;r=r.getParent()}return!1}class Xi extends ji{static getType(){return\"root\"}static clone(){return new Xi}constructor(){super(\"root\"),this.__cachedText=null}getTopLevelElementOrThrow(){H(51)}getTextContent(){const e=this.__cachedText;return!Ei()&&Oi()._dirtyType!==oe||null===e?super.getTextContent():e}remove(){H(52)}replace(e){H(53)}insertBefore(e){H(54)}insertAfter(e){H(55)}updateDOM(e,t){return!1}append(...e){for(let t=0;t<e.length;t++){const n=e[t];qi(n)||Hi(n)||H(56)}return super.append(...e)}static importJSON(e){const t=ht();return t.setFormat(e.format),t.setIndent(e.indent),t.setDirection(e.direction),t}exportJSON(){return{children:[],direction:this.getDirection(),format:this.getFormatType(),indent:this.getIndent(),type:\"root\",version:1}}collapseAtStart(){return!0}}function Yi(e){return e instanceof Xi}function Zi(){return new es(new Map([[\"root\",new Xi]]))}function Gi(e){const t=e.exportJSON(),n=e.constructor;if(t.type!==n.getType()&&H(130,n.name),qi(e)){const r=t.children;Array.isArray(r)||H(59,n.name);const i=e.getChildren();for(let e=0;e<i.length;e++){const t=Gi(i[e]);r.push(t)}}return t}class es{constructor(e,t){this._nodeMap=e,this._selection=t||null,this._flushSync=!1,this._readOnly=!1}isEmpty(){return 1===this._nodeMap.size&&null===this._selection}read(e){return zi(this,e)}clone(e){const t=new es(this._nodeMap,void 0===e?this._selection:e);return t._readOnly=!0,t}toJSON(){return zi(this,(()=>({root:Gi(ht())})))}}class ts extends ji{static getType(){return\"paragraph\"}static clone(e){return new ts(e.__key)}createDOM(e){const t=document.createElement(\"p\"),n=At(e.theme,\"paragraph\");if(void 0!==n){t.classList.add(...n)}return t}updateDOM(e,t,n){return!1}static importDOM(){return{p:e=>({conversion:ns,priority:0})}}exportDOM(e){const{element:t}=super.exportDOM(e);if(t&&on(t)){this.isEmpty()&&t.append(document.createElement(\"br\"));const e=this.getFormatType();t.style.textAlign=e;const n=this.getDirection();n&&(t.dir=n);const r=this.getIndent();r>0&&(t.style.textIndent=20*r+\"px\")}return{element:t}}static importJSON(e){const t=rs();return t.setFormat(e.format),t.setIndent(e.indent),t.setDirection(e.direction),t}exportJSON(){return{...super.exportJSON(),type:\"paragraph\",version:1}}insertNewAfter(e,t){const n=rs(),r=this.getDirection();return n.setDirection(r),this.insertAfter(n,t),n}collapseAtStart(){const e=this.getChildren();if(0===e.length||Br(e[0])&&\"\"===e[0].getTextContent().trim()){if(null!==this.getNextSibling())return this.selectNext(),this.remove(),!0;if(null!==this.getPreviousSibling())return this.selectPrevious(),this.remove(),!0}return!1}}function ns(e){const t=rs();if(e.style){t.setFormat(e.style.textAlign);const n=parseInt(e.style.textIndent,10)/20;n>0&&t.setIndent(n)}return{node:t}}function rs(){return Yt(new ts)}function is(e){return e instanceof ts}const ss=0,os=1,ls=2,cs=3,us=4;function as(e,t,n,r){const i=e._keyToDOMMap;i.clear(),e._editorState=Zi(),e._pendingEditorState=r,e._compositionKey=null,e._dirtyType=oe,e._cloneNotNeeded.clear(),e._dirtyLeaves=new Set,e._dirtyElements.clear(),e._normalizedNodes=new Set,e._updateTags=new Set,e._updates=[],e._blockCursorElement=null;const s=e._observer;null!==s&&(s.disconnect(),e._observer=null),null!==t&&(t.textContent=\"\"),null!==n&&(n.textContent=\"\",i.set(\"root\",n))}function fs(e){const t=e||{},n=Ai(),r=t.theme||{},i=void 0===e?n:t.parentEditor||null,s=t.disableEvents||!1,o=Zi(),l=t.namespace||(null!==i?i._config.namespace:vt()),c=t.editorState,u=[Xi,Er,yr,Rr,ts,...t.nodes||[]],{onError:a,html:f}=t,d=void 0===t.editable||t.editable;let h;if(void 0===e&&null!==n)h=n._nodes;else{h=new Map;for(let e=0;e<u.length;e++){let t=u[e],n=null,r=null;if(\"function\"!=typeof t){const e=t;t=e.replace,n=e.with,r=e.withKlass||null}const i=t.getType(),s=t.transform(),o=new Set;null!==s&&o.add(s),h.set(i,{exportDOM:f&&f.export?f.export.get(t):void 0,klass:t,replace:n,replaceWithKlass:r,transforms:o})}}const g=new ds(o,i,h,{disableEvents:s,namespace:l,theme:r},a||console.error,function(e,t){const n=new Map,r=new Set,i=e=>{Object.keys(e).forEach((t=>{let r=n.get(t);void 0===r&&(r=[],n.set(t,r)),r.push(e[t])}))};return e.forEach((e=>{const t=e.klass.importDOM;if(null==t||r.has(t))return;r.add(t);const n=t.call(e.klass);null!==n&&i(n)})),t&&i(t),n}(h,f?f.import:void 0),d);return void 0!==c&&(g._pendingEditorState=c,g._dirtyType=ce),g}class ds{constructor(e,t,n,r,i,s,o){this._parentEditor=t,this._rootElement=null,this._editorState=e,this._pendingEditorState=null,this._compositionKey=null,this._deferred=[],this._keyToDOMMap=new Map,this._updates=[],this._updating=!1,this._listeners={decorator:new Set,editable:new Set,mutation:new Map,root:new Set,textcontent:new Set,update:new Set},this._commands=new Map,this._config=r,this._nodes=n,this._decorators={},this._pendingDecorators=null,this._dirtyType=oe,this._cloneNotNeeded=new Set,this._dirtyLeaves=new Set,this._dirtyElements=new Map,this._normalizedNodes=new Set,this._updateTags=new Set,this._observer=null,this._key=vt(),this._onError=i,this._htmlConversions=s,this._editable=o,this._headless=null!==t&&t._headless,this._window=null,this._blockCursorElement=null}isComposing(){return null!=this._compositionKey}registerUpdateListener(e){const t=this._listeners.update;return t.add(e),()=>{t.delete(e)}}registerEditableListener(e){const t=this._listeners.editable;return t.add(e),()=>{t.delete(e)}}registerDecoratorListener(e){const t=this._listeners.decorator;return t.add(e),()=>{t.delete(e)}}registerTextContentListener(e){const t=this._listeners.textcontent;return t.add(e),()=>{t.delete(e)}}registerRootListener(e){const t=this._listeners.root;return e(this._rootElement,null),t.add(e),()=>{e(null,this._rootElement),t.delete(e)}}registerCommand(e,t,n){void 0===n&&H(35);const r=this._commands;r.has(e)||r.set(e,[new Set,new Set,new Set,new Set,new Set]);const i=r.get(e);void 0===i&&H(36,String(e));const s=i[n];return s.add(t),()=>{s.delete(t),i.every((e=>0===e.size))&&r.delete(e)}}registerMutationListener(e,t){void 0===this._nodes.get(e.getType())&&H(37,e.name);const n=this._listeners.mutation;return n.set(t,e),()=>{n.delete(t)}}registerNodeTransformToKlass(e,t){const n=e.getType(),r=this._nodes.get(n);void 0===r&&H(37,e.name);return r.transforms.add(t),r}registerNodeTransform(e,t){const n=this.registerNodeTransformToKlass(e,t),r=[n],i=n.replaceWithKlass;if(null!=i){const e=this.registerNodeTransformToKlass(i,t);r.push(e)}var s,o;return s=this,o=e.getType(),Vi(s,(()=>{const e=Ii();if(e.isEmpty())return;if(\"root\"===o)return void ht().markDirty();const t=e._nodeMap;for(const[,e]of t)e.markDirty()}),null===s._pendingEditorState?{tag:\"history-merge\"}:void 0),()=>{r.forEach((e=>e.transforms.delete(t)))}}hasNode(e){return this._nodes.has(e.getType())}hasNodes(e){return e.every(this.hasNode.bind(this))}dispatchCommand(e,t){return Bt(this,e,t)}getDecorators(){return this._decorators}getRootElement(){return this._rootElement}getKey(){return this._key}setRootElement(e){const t=this._rootElement;if(e!==t){const n=At(this._config.theme,\"root\"),r=this._pendingEditorState||this._editorState;if(this._rootElement=e,as(this,t,e,r),null!==t&&(this._config.disableEvents||gr(t),null!=n&&t.classList.remove(...n)),null!==e){const t=function(e){const t=e.ownerDocument;return t&&t.defaultView||null}(e),r=e.style;r.userSelect=\"text\",r.whiteSpace=\"pre-wrap\",r.wordBreak=\"break-word\",e.setAttribute(\"data-lexical-editor\",\"true\"),this._window=t,this._dirtyType=ce,Ke(this),this._updateTags.add(\"history-merge\"),Bi(this),this._config.disableEvents||function(e,t){const n=e.ownerDocument,r=Zn.get(n);void 0===r&&n.addEventListener(\"selectionchange\",fr),Zn.set(n,r||1),e.__lexicalEditor=t;const i=ur(e);for(let n=0;n<jn.length;n++){const[r,s]=jn[n],o=\"function\"==typeof s?e=>{hr(e)||(dr(e),(t.isEditable()||\"click\"===r)&&s(e,t))}:e=>{if(!hr(e)&&(dr(e),t.isEditable()))switch(r){case\"cut\":return Bt(t,W,e);case\"copy\":return Bt(t,M,e);case\"paste\":return Bt(t,c,e);case\"dragstart\":return Bt(t,A,e);case\"dragover\":return Bt(t,L,e);case\"dragend\":return Bt(t,F,e);case\"focus\":return Bt(t,U,e);case\"blur\":return Bt(t,V,e);case\"drop\":return Bt(t,I,e)}};e.addEventListener(r,o),i.push((()=>{e.removeEventListener(r,o)}))}}(e,this),null!=n&&e.classList.add(...n)}else this._editorState=r,this._pendingEditorState=null,this._window=null;Ri(\"root\",this,!1,e,t)}}getElementByKey(e){return this._keyToDOMMap.get(e)||null}getEditorState(){return this._editorState}setEditorState(e,t){e.isEmpty()&&H(38),Re(this);const n=this._pendingEditorState,r=this._updateTags,i=void 0!==t?t.tag:null;null===n||n.isEmpty()||(null!=i&&r.add(i),Bi(this)),this._pendingEditorState=e,this._dirtyType=ce,this._dirtyElements.set(\"root\",!1),this._compositionKey=null,null!=i&&r.add(i),Bi(this)}parseEditorState(e,t){return function(e,t,n){const r=Zi(),i=Si,s=Ci,o=ki,l=t._dirtyElements,c=t._dirtyLeaves,u=t._cloneNotNeeded,a=t._dirtyType;t._dirtyElements=new Map,t._dirtyLeaves=new Set,t._cloneNotNeeded=new Set,t._dirtyType=0,Si=r,Ci=!1,ki=t;try{const i=t._nodes;Wi(e.root,i),n&&n(),r._readOnly=!0}catch(e){e instanceof Error&&t._onError(e)}finally{t._dirtyElements=l,t._dirtyLeaves=c,t._cloneNotNeeded=u,t._dirtyType=a,Si=i,Ci=s,ki=o}return r}(\"string\"==typeof e?JSON.parse(e):e,this,t)}update(e,t){Vi(this,e,t)}focus(e,t={}){const n=this._rootElement;null!==n&&(n.setAttribute(\"autocapitalize\",\"off\"),Vi(this,(()=>{const e=fi(),n=ht();null!==e?e.dirty=!0:0!==n.getChildrenSize()&&(\"rootStart\"===t.defaultSelection?n.selectStart():n.selectEnd())}),{onUpdate:()=>{n.removeAttribute(\"autocapitalize\"),e&&e()},tag:\"focus\"}),null===this._pendingEditorState&&n.removeAttribute(\"autocapitalize\"))}blur(){const e=this._rootElement;null!==e&&e.blur();const t=nn(this._window);null!==t&&t.removeAllRanges()}isEditable(){return this._editable}setEditable(e){this._editable!==e&&(this._editable=e,Ri(\"editable\",this,!0,e))}toJSON(){return{editorState:this._editorState.toJSON()}}}export{Vt as $addUpdateTag,Yt as $applyNodeReplacement,Xt as $copyNode,xr as $createLineBreakNode,ui as $createNodeSelection,rs as $createParagraphNode,Vr as $createPoint,ci as $createRangeSelection,Kr as $createTabNode,zr as $createTextNode,Wt as $getAdjacentNode,ei as $getCharacterOffsets,un as $getEditor,at as $getNearestNodeFromDOMNode,qt as $getNearestRootOrShadowRoot,ct as $getNodeByKey,di as $getPreviousSelection,ht as $getRoot,fi as $getSelection,xi as $getTextContent,$t as $hasAncestor,Ut as $hasUpdateTag,mi as $insertNodes,oi as $isBlockElementNode,Hi as $isDecoratorNode,qi as $isElementNode,jt as $isInlineElementOrDecoratorNode,nt as $isLeafNode,vr as $isLineBreakNode,Zr as $isNodeSelection,is as $isParagraphNode,Xr as $isRangeSelection,Yi as $isRootNode,Qt as $isRootOrShadowRoot,Jr as $isTabNode,Br as $isTextNode,Ft as $nodesOfType,$e as $normalizeSelection__EXPERIMENTAL,Mi as $parseSerializedNode,Ot as $selectAll,ot as $setCompositionKey,_t as $setSelection,rn as $splitNode,V as BLUR_COMMAND,K as CAN_REDO_COMMAND,J as CAN_UNDO_COMMAND,B as CLEAR_EDITOR_COMMAND,R as CLEAR_HISTORY_COMMAND,r as CLICK_COMMAND,us as COMMAND_PRIORITY_CRITICAL,ss as COMMAND_PRIORITY_EDITOR,cs as COMMAND_PRIORITY_HIGH,os as COMMAND_PRIORITY_LOW,ls as COMMAND_PRIORITY_NORMAL,l as CONTROLLED_TEXT_INSERTION_COMMAND,M as COPY_COMMAND,W as CUT_COMMAND,i as DELETE_CHARACTER_COMMAND,f as DELETE_LINE_COMMAND,a as DELETE_WORD_COMMAND,F as DRAGEND_COMMAND,L as DRAGOVER_COMMAND,A as DRAGSTART_COMMAND,I as DROP_COMMAND,$i as DecoratorNode,ji as ElementNode,U as FOCUS_COMMAND,O as FORMAT_ELEMENT_COMMAND,d as FORMAT_TEXT_COMMAND,P as INDENT_CONTENT_COMMAND,s as INSERT_LINE_BREAK_COMMAND,o as INSERT_PARAGRAPH_COMMAND,E as INSERT_TAB_COMMAND,T as KEY_ARROW_DOWN_COMMAND,m as KEY_ARROW_LEFT_COMMAND,p as KEY_ARROW_RIGHT_COMMAND,v as KEY_ARROW_UP_COMMAND,C as KEY_BACKSPACE_COMMAND,N as KEY_DELETE_COMMAND,_ as KEY_DOWN_COMMAND,S as KEY_ENTER_COMMAND,b as KEY_ESCAPE_COMMAND,$ as KEY_MODIFIER_COMMAND,k as KEY_SPACE_COMMAND,w as KEY_TAB_COMMAND,yr as LineBreakNode,y as MOVE_TO_END,x as MOVE_TO_START,D as OUTDENT_CONTENT_COMMAND,c as PASTE_COMMAND,ts as ParagraphNode,g as REDO_COMMAND,u as REMOVE_TEXT_COMMAND,Xi as RootNode,t as SELECTION_CHANGE_COMMAND,n as SELECTION_INSERT_CLIPBOARD_NODES_COMMAND,z as SELECT_ALL_COMMAND,Rr as TabNode,Er as TextNode,h as UNDO_COMMAND,e as createCommand,fs as createEditor,Ye as getNearestEditorFromDOMNode,Ei as isCurrentlyReadOnlyMode,sn as isHTMLAnchorElement,on as isHTMLElement,Qe as isSelectionCapturedInDecoratorInput,Xe as isSelectionWithinEditor};\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport * as modDev from './Lexical.dev.esm.js';\nimport * as modProd from './Lexical.prod.esm.js';\nconst mod = process.env.NODE_ENV === 'development' ? modDev : modProd;\nexport const $addUpdateTag = mod.$addUpdateTag;\nexport const $applyNodeReplacement = mod.$applyNodeReplacement;\nexport const $copyNode = mod.$copyNode;\nexport const $createLineBreakNode = mod.$createLineBreakNode;\nexport const $createNodeSelection = mod.$createNodeSelection;\nexport const $createParagraphNode = mod.$createParagraphNode;\nexport const $createPoint = mod.$createPoint;\nexport const $createRangeSelection = mod.$createRangeSelection;\nexport const $createTabNode = mod.$createTabNode;\nexport const $createTextNode = mod.$createTextNode;\nexport const $getAdjacentNode = mod.$getAdjacentNode;\nexport const $getCharacterOffsets = mod.$getCharacterOffsets;\nexport const $getEditor = mod.$getEditor;\nexport const $getNearestNodeFromDOMNode = mod.$getNearestNodeFromDOMNode;\nexport const $getNearestRootOrShadowRoot = mod.$getNearestRootOrShadowRoot;\nexport const $getNodeByKey = mod.$getNodeByKey;\nexport const $getPreviousSelection = mod.$getPreviousSelection;\nexport const $getRoot = mod.$getRoot;\nexport const $getSelection = mod.$getSelection;\nexport const $getTextContent = mod.$getTextContent;\nexport const $hasAncestor = mod.$hasAncestor;\nexport const $hasUpdateTag = mod.$hasUpdateTag;\nexport const $insertNodes = mod.$insertNodes;\nexport const $isBlockElementNode = mod.$isBlockElementNode;\nexport const $isDecoratorNode = mod.$isDecoratorNode;\nexport const $isElementNode = mod.$isElementNode;\nexport const $isInlineElementOrDecoratorNode = mod.$isInlineElementOrDecoratorNode;\nexport const $isLeafNode = mod.$isLeafNode;\nexport const $isLineBreakNode = mod.$isLineBreakNode;\nexport const $isNodeSelection = mod.$isNodeSelection;\nexport const $isParagraphNode = mod.$isParagraphNode;\nexport const $isRangeSelection = mod.$isRangeSelection;\nexport const $isRootNode = mod.$isRootNode;\nexport const $isRootOrShadowRoot = mod.$isRootOrShadowRoot;\nexport const $isTabNode = mod.$isTabNode;\nexport const $isTextNode = mod.$isTextNode;\nexport const $nodesOfType = mod.$nodesOfType;\nexport const $normalizeSelection__EXPERIMENTAL = mod.$normalizeSelection__EXPERIMENTAL;\nexport const $parseSerializedNode = mod.$parseSerializedNode;\nexport const $selectAll = mod.$selectAll;\nexport const $setCompositionKey = mod.$setCompositionKey;\nexport const $setSelection = mod.$setSelection;\nexport const $splitNode = mod.$splitNode;\nexport const BLUR_COMMAND = mod.BLUR_COMMAND;\nexport const CAN_REDO_COMMAND = mod.CAN_REDO_COMMAND;\nexport const CAN_UNDO_COMMAND = mod.CAN_UNDO_COMMAND;\nexport const CLEAR_EDITOR_COMMAND = mod.CLEAR_EDITOR_COMMAND;\nexport const CLEAR_HISTORY_COMMAND = mod.CLEAR_HISTORY_COMMAND;\nexport const CLICK_COMMAND = mod.CLICK_COMMAND;\nexport const COMMAND_PRIORITY_CRITICAL = mod.COMMAND_PRIORITY_CRITICAL;\nexport const COMMAND_PRIORITY_EDITOR = mod.COMMAND_PRIORITY_EDITOR;\nexport const COMMAND_PRIORITY_HIGH = mod.COMMAND_PRIORITY_HIGH;\nexport const COMMAND_PRIORITY_LOW = mod.COMMAND_PRIORITY_LOW;\nexport const COMMAND_PRIORITY_NORMAL = mod.COMMAND_PRIORITY_NORMAL;\nexport const CONTROLLED_TEXT_INSERTION_COMMAND = mod.CONTROLLED_TEXT_INSERTION_COMMAND;\nexport const COPY_COMMAND = mod.COPY_COMMAND;\nexport const CUT_COMMAND = mod.CUT_COMMAND;\nexport const DELETE_CHARACTER_COMMAND = mod.DELETE_CHARACTER_COMMAND;\nexport const DELETE_LINE_COMMAND = mod.DELETE_LINE_COMMAND;\nexport const DELETE_WORD_COMMAND = mod.DELETE_WORD_COMMAND;\nexport const DRAGEND_COMMAND = mod.DRAGEND_COMMAND;\nexport const DRAGOVER_COMMAND = mod.DRAGOVER_COMMAND;\nexport const DRAGSTART_COMMAND = mod.DRAGSTART_COMMAND;\nexport const DROP_COMMAND = mod.DROP_COMMAND;\nexport const DecoratorNode = mod.DecoratorNode;\nexport const ElementNode = mod.ElementNode;\nexport const FOCUS_COMMAND = mod.FOCUS_COMMAND;\nexport const FORMAT_ELEMENT_COMMAND = mod.FORMAT_ELEMENT_COMMAND;\nexport const FORMAT_TEXT_COMMAND = mod.FORMAT_TEXT_COMMAND;\nexport const INDENT_CONTENT_COMMAND = mod.INDENT_CONTENT_COMMAND;\nexport const INSERT_LINE_BREAK_COMMAND = mod.INSERT_LINE_BREAK_COMMAND;\nexport const INSERT_PARAGRAPH_COMMAND = mod.INSERT_PARAGRAPH_COMMAND;\nexport const INSERT_TAB_COMMAND = mod.INSERT_TAB_COMMAND;\nexport const KEY_ARROW_DOWN_COMMAND = mod.KEY_ARROW_DOWN_COMMAND;\nexport const KEY_ARROW_LEFT_COMMAND = mod.KEY_ARROW_LEFT_COMMAND;\nexport const KEY_ARROW_RIGHT_COMMAND = mod.KEY_ARROW_RIGHT_COMMAND;\nexport const KEY_ARROW_UP_COMMAND = mod.KEY_ARROW_UP_COMMAND;\nexport const KEY_BACKSPACE_COMMAND = mod.KEY_BACKSPACE_COMMAND;\nexport const KEY_DELETE_COMMAND = mod.KEY_DELETE_COMMAND;\nexport const KEY_DOWN_COMMAND = mod.KEY_DOWN_COMMAND;\nexport const KEY_ENTER_COMMAND = mod.KEY_ENTER_COMMAND;\nexport const KEY_ESCAPE_COMMAND = mod.KEY_ESCAPE_COMMAND;\nexport const KEY_MODIFIER_COMMAND = mod.KEY_MODIFIER_COMMAND;\nexport const KEY_SPACE_COMMAND = mod.KEY_SPACE_COMMAND;\nexport const KEY_TAB_COMMAND = mod.KEY_TAB_COMMAND;\nexport const LineBreakNode = mod.LineBreakNode;\nexport const MOVE_TO_END = mod.MOVE_TO_END;\nexport const MOVE_TO_START = mod.MOVE_TO_START;\nexport const OUTDENT_CONTENT_COMMAND = mod.OUTDENT_CONTENT_COMMAND;\nexport const PASTE_COMMAND = mod.PASTE_COMMAND;\nexport const ParagraphNode = mod.ParagraphNode;\nexport const REDO_COMMAND = mod.REDO_COMMAND;\nexport const REMOVE_TEXT_COMMAND = mod.REMOVE_TEXT_COMMAND;\nexport const RootNode = mod.RootNode;\nexport const SELECTION_CHANGE_COMMAND = mod.SELECTION_CHANGE_COMMAND;\nexport const SELECTION_INSERT_CLIPBOARD_NODES_COMMAND = mod.SELECTION_INSERT_CLIPBOARD_NODES_COMMAND;\nexport const SELECT_ALL_COMMAND = mod.SELECT_ALL_COMMAND;\nexport const TabNode = mod.TabNode;\nexport const TextNode = mod.TextNode;\nexport const UNDO_COMMAND = mod.UNDO_COMMAND;\nexport const createCommand = mod.createCommand;\nexport const createEditor = mod.createEditor;\nexport const getNearestEditorFromDOMNode = mod.getNearestEditorFromDOMNode;\nexport const isCurrentlyReadOnlyMode = mod.isCurrentlyReadOnlyMode;\nexport const isHTMLAnchorElement = mod.isHTMLAnchorElement;\nexport const isHTMLElement = mod.isHTMLElement;\nexport const isSelectionCapturedInDecoratorInput = mod.isSelectionCapturedInDecoratorInput;\nexport const isSelectionWithinEditor = mod.isSelectionWithinEditor;"],
  "mappings": "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",
  "names": ["s", "i", "fn", "mutatedNodes", "leftTree", "rightTree", "x", "anchorNode", "a", "b", "dirtyElements", "dirtyLeaves", "j", "resolvedNode", "_", "activeEditor", "t", "e", "r", "i", "s", "o", "l", "c", "u", "a", "n", "f", "d", "h", "g", "t", "r", "e", "i", "t", "r", "i", "s", "e", "o", "n", "l", "t", "r", "i", "s", "o", "e", "l", "c", "u", "a", "f", "t", "r", "i", "e", "s", "o", "l", "c", "u", "a", "f", "t", "r", "i", "s", "e", "t", "t", "t", "r", "i", "s", "o", "l", "c", "n", "e", "t", "t", "r", "i", "s", "o", "e", "n", "l", "c", "u", "a", "h", "f", "d", "g", "_", "p", "y", "m", "x", "v", "T", "t", "r", "i", "s", "o", "l", "c", "u", "a", "f", "d", "h", "t", "r", "n", "t", "r", "i", "s", "e", "n", "o", "l", "c", "u", "a", "f", "d", "h", "g", "_", "p", "y", "m", "x", "v", "T", "t", "r", "i", "s", "o", "l", "t", "r", "i", "s", "o", "l", "c", "u", "a", "f", "d", "h", "g", "_", "n", "e", "p", "y", "m", "x", "v", "T", "S", "k", "C", "b", "N", "w", "t", "r", "e", "i", "n", "t", "r", "i", "e", "n", "s", "o", "t", "r", "i", "s", "o", "l", "c", "u", "a", "f", "d", "h", "g", "_", "n", "p", "y", "m", "x", "v", "e", "T", "S", "t", "r", "i", "s", "$addUpdateTag", "$applyNodeReplacement", "$copyNode", "$createLineBreakNode", "$createNodeSelection", "$createParagraphNode", "$createPoint", "$createRangeSelection", "$createTabNode", "$createTextNode", "$getAdjacentNode", "$getCharacterOffsets", "$getEditor", "$getNearestNodeFromDOMNode", "$getNearestRootOrShadowRoot", "$getNodeByKey", "$getPreviousSelection", "$getRoot", "$getSelection", "$getTextContent", "$hasAncestor", "$hasUpdateTag", "$insertNodes", "$isBlockElementNode", "$isDecoratorNode", "$isElementNode", "$isInlineElementOrDecoratorNode", "$isLeafNode", "$isLineBreakNode", "$isNodeSelection", "$isParagraphNode", "$isRangeSelection", "$isRootNode", "$isRootOrShadowRoot", "$isTabNode", "$isTextNode", "$nodesOfType", "$parseSerializedNode", "$selectAll", "$setCompositionKey", "$setSelection", "$splitNode", "BLUR_COMMAND", "CAN_REDO_COMMAND", "CAN_UNDO_COMMAND", "CLEAR_EDITOR_COMMAND", "CLEAR_HISTORY_COMMAND", "CLICK_COMMAND", "COMMAND_PRIORITY_CRITICAL", "COMMAND_PRIORITY_EDITOR", "COMMAND_PRIORITY_HIGH", "COMMAND_PRIORITY_LOW", "COMMAND_PRIORITY_NORMAL", "CONTROLLED_TEXT_INSERTION_COMMAND", "COPY_COMMAND", "CUT_COMMAND", "DELETE_CHARACTER_COMMAND", "DELETE_LINE_COMMAND", "DELETE_WORD_COMMAND", "DRAGEND_COMMAND", "DRAGOVER_COMMAND", "DRAGSTART_COMMAND", "DROP_COMMAND", "DecoratorNode", "ElementNode", "FOCUS_COMMAND", "FORMAT_ELEMENT_COMMAND", "FORMAT_TEXT_COMMAND", "INDENT_CONTENT_COMMAND", "INSERT_LINE_BREAK_COMMAND", "INSERT_PARAGRAPH_COMMAND", "INSERT_TAB_COMMAND", "KEY_ARROW_DOWN_COMMAND", "KEY_ARROW_LEFT_COMMAND", "KEY_ARROW_RIGHT_COMMAND", "KEY_ARROW_UP_COMMAND", "KEY_BACKSPACE_COMMAND", "KEY_DELETE_COMMAND", "KEY_DOWN_COMMAND", "KEY_ENTER_COMMAND", "KEY_ESCAPE_COMMAND", "KEY_MODIFIER_COMMAND", "KEY_SPACE_COMMAND", "KEY_TAB_COMMAND", "LineBreakNode", "MOVE_TO_END", "MOVE_TO_START", "OUTDENT_CONTENT_COMMAND", "PASTE_COMMAND", "ParagraphNode", "REDO_COMMAND", "REMOVE_TEXT_COMMAND", "RootNode", "SELECTION_CHANGE_COMMAND", "SELECTION_INSERT_CLIPBOARD_NODES_COMMAND", "SELECT_ALL_COMMAND", "TabNode", "TextNode", "UNDO_COMMAND", "createCommand", "createEditor", "getNearestEditorFromDOMNode", "isCurrentlyReadOnlyMode", "isHTMLAnchorElement", "isHTMLElement", "isSelectionCapturedInDecoratorInput", "isSelectionWithinEditor"]
}
