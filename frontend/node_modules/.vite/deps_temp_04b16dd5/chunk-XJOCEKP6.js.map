{
  "version": 3,
  "sources": ["../../../../node_modules/@lexical/utils/LexicalUtils.dev.esm.js", "../../../../node_modules/@lexical/selection/LexicalSelection.dev.esm.js", "../../../../node_modules/@lexical/selection/LexicalSelection.esm.js", "../../../../node_modules/@lexical/utils/LexicalUtils.esm.js"],
  "sourcesContent": ["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { createRectsFromDOMRange, $cloneWithProperties } from '@lexical/selection';\nimport { $getSelection, $isRangeSelection, TextNode, $getRoot, $isElementNode, $isTextNode, $setSelection, $getPreviousSelection, $isRootOrShadowRoot, $splitNode, $createParagraphNode } from 'lexical';\nexport { $splitNode, isHTMLAnchorElement, isHTMLElement } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns a function that will execute all functions passed when called. It is generally used\n * to register multiple lexical listeners and then tear them down with a single function call, such\n * as React's useEffect hook.\n * @example\n * ```ts\n * useEffect(() => {\n *   return mergeRegister(\n *     editor.registerCommand(...registerCommand1 logic),\n *     editor.registerCommand(...registerCommand2 logic),\n *     editor.registerCommand(...registerCommand3 logic)\n *   )\n * }, [editor])\n * ```\n * In this case, useEffect is returning the function returned by mergeRegister as a cleanup\n * function to be executed after either the useEffect runs again (due to one of its dependencies\n * updating) or the component it resides in unmounts.\n * Note the functions don't neccesarily need to be in an array as all arguements\n * are considered to be the func argument and spread from there.\n * @param func - An array of functions meant to be executed by the returned function.\n * @returns the function which executes all the passed register command functions.\n */\nfunction mergeRegister(...func) {\n  return () => {\n    func.forEach(f => f());\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction px(value) {\n  return `${value}px`;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst mutationObserverConfig = {\n  attributes: true,\n  characterData: true,\n  childList: true,\n  subtree: true\n};\nfunction positionNodeOnRange(editor, range, onReposition) {\n  let rootDOMNode = null;\n  let parentDOMNode = null;\n  let observer = null;\n  let lastNodes = [];\n  const wrapperNode = document.createElement('div');\n  function position() {\n    if (!(rootDOMNode !== null)) {\n      throw Error(`Unexpected null rootDOMNode`);\n    }\n    if (!(parentDOMNode !== null)) {\n      throw Error(`Unexpected null parentDOMNode`);\n    }\n    const {\n      left: rootLeft,\n      top: rootTop\n    } = rootDOMNode.getBoundingClientRect();\n    const parentDOMNode_ = parentDOMNode;\n    const rects = createRectsFromDOMRange(editor, range);\n    if (!wrapperNode.isConnected) {\n      parentDOMNode_.append(wrapperNode);\n    }\n    let hasRepositioned = false;\n    for (let i = 0; i < rects.length; i++) {\n      const rect = rects[i];\n      // Try to reuse the previously created Node when possible, no need to\n      // remove/create on the most common case reposition case\n      const rectNode = lastNodes[i] || document.createElement('div');\n      const rectNodeStyle = rectNode.style;\n      if (rectNodeStyle.position !== 'absolute') {\n        rectNodeStyle.position = 'absolute';\n        hasRepositioned = true;\n      }\n      const left = px(rect.left - rootLeft);\n      if (rectNodeStyle.left !== left) {\n        rectNodeStyle.left = left;\n        hasRepositioned = true;\n      }\n      const top = px(rect.top - rootTop);\n      if (rectNodeStyle.top !== top) {\n        rectNode.style.top = top;\n        hasRepositioned = true;\n      }\n      const width = px(rect.width);\n      if (rectNodeStyle.width !== width) {\n        rectNode.style.width = width;\n        hasRepositioned = true;\n      }\n      const height = px(rect.height);\n      if (rectNodeStyle.height !== height) {\n        rectNode.style.height = height;\n        hasRepositioned = true;\n      }\n      if (rectNode.parentNode !== wrapperNode) {\n        wrapperNode.append(rectNode);\n        hasRepositioned = true;\n      }\n      lastNodes[i] = rectNode;\n    }\n    while (lastNodes.length > rects.length) {\n      lastNodes.pop();\n    }\n    if (hasRepositioned) {\n      onReposition(lastNodes);\n    }\n  }\n  function stop() {\n    parentDOMNode = null;\n    rootDOMNode = null;\n    if (observer !== null) {\n      observer.disconnect();\n    }\n    observer = null;\n    wrapperNode.remove();\n    for (const node of lastNodes) {\n      node.remove();\n    }\n    lastNodes = [];\n  }\n  function restart() {\n    const currentRootDOMNode = editor.getRootElement();\n    if (currentRootDOMNode === null) {\n      return stop();\n    }\n    const currentParentDOMNode = currentRootDOMNode.parentElement;\n    if (!(currentParentDOMNode instanceof HTMLElement)) {\n      return stop();\n    }\n    stop();\n    rootDOMNode = currentRootDOMNode;\n    parentDOMNode = currentParentDOMNode;\n    observer = new MutationObserver(mutations => {\n      const nextRootDOMNode = editor.getRootElement();\n      const nextParentDOMNode = nextRootDOMNode && nextRootDOMNode.parentElement;\n      if (nextRootDOMNode !== rootDOMNode || nextParentDOMNode !== parentDOMNode) {\n        return restart();\n      }\n      for (const mutation of mutations) {\n        if (!wrapperNode.contains(mutation.target)) {\n          // TODO throttle\n          return position();\n        }\n      }\n    });\n    observer.observe(currentParentDOMNode, mutationObserverConfig);\n    position();\n  }\n  const removeRootListener = editor.registerRootListener(restart);\n  return () => {\n    removeRootListener();\n    stop();\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction markSelection(editor, onReposition) {\n  let previousAnchorNode = null;\n  let previousAnchorOffset = null;\n  let previousFocusNode = null;\n  let previousFocusOffset = null;\n  let removeRangeListener = () => {};\n  function compute(editorState) {\n    editorState.read(() => {\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection)) {\n        // TODO\n        previousAnchorNode = null;\n        previousAnchorOffset = null;\n        previousFocusNode = null;\n        previousFocusOffset = null;\n        removeRangeListener();\n        removeRangeListener = () => {};\n        return;\n      }\n      const {\n        anchor,\n        focus\n      } = selection;\n      const currentAnchorNode = anchor.getNode();\n      const currentAnchorNodeKey = currentAnchorNode.getKey();\n      const currentAnchorOffset = anchor.offset;\n      const currentFocusNode = focus.getNode();\n      const currentFocusNodeKey = currentFocusNode.getKey();\n      const currentFocusOffset = focus.offset;\n      const currentAnchorNodeDOM = editor.getElementByKey(currentAnchorNodeKey);\n      const currentFocusNodeDOM = editor.getElementByKey(currentFocusNodeKey);\n      const differentAnchorDOM = previousAnchorNode === null || currentAnchorNodeDOM === null || currentAnchorOffset !== previousAnchorOffset || currentAnchorNodeKey !== previousAnchorNode.getKey() || currentAnchorNode !== previousAnchorNode && (!(previousAnchorNode instanceof TextNode) || currentAnchorNode.updateDOM(previousAnchorNode, currentAnchorNodeDOM, editor._config));\n      const differentFocusDOM = previousFocusNode === null || currentFocusNodeDOM === null || currentFocusOffset !== previousFocusOffset || currentFocusNodeKey !== previousFocusNode.getKey() || currentFocusNode !== previousFocusNode && (!(previousFocusNode instanceof TextNode) || currentFocusNode.updateDOM(previousFocusNode, currentFocusNodeDOM, editor._config));\n      if (differentAnchorDOM || differentFocusDOM) {\n        const anchorHTMLElement = editor.getElementByKey(anchor.getNode().getKey());\n        const focusHTMLElement = editor.getElementByKey(focus.getNode().getKey());\n        // TODO handle selection beyond the common TextNode\n        if (anchorHTMLElement !== null && focusHTMLElement !== null && anchorHTMLElement.tagName === 'SPAN' && focusHTMLElement.tagName === 'SPAN') {\n          const range = document.createRange();\n          let firstHTMLElement;\n          let firstOffset;\n          let lastHTMLElement;\n          let lastOffset;\n          if (focus.isBefore(anchor)) {\n            firstHTMLElement = focusHTMLElement;\n            firstOffset = focus.offset;\n            lastHTMLElement = anchorHTMLElement;\n            lastOffset = anchor.offset;\n          } else {\n            firstHTMLElement = anchorHTMLElement;\n            firstOffset = anchor.offset;\n            lastHTMLElement = focusHTMLElement;\n            lastOffset = focus.offset;\n          }\n          const firstTextNode = firstHTMLElement.firstChild;\n          if (!(firstTextNode !== null)) {\n            throw Error(`Expected text node to be first child of span`);\n          }\n          const lastTextNode = lastHTMLElement.firstChild;\n          if (!(lastTextNode !== null)) {\n            throw Error(`Expected text node to be first child of span`);\n          }\n          range.setStart(firstTextNode, firstOffset);\n          range.setEnd(lastTextNode, lastOffset);\n          removeRangeListener();\n          removeRangeListener = positionNodeOnRange(editor, range, domNodes => {\n            for (const domNode of domNodes) {\n              const domNodeStyle = domNode.style;\n              if (domNodeStyle.background !== 'Highlight') {\n                domNodeStyle.background = 'Highlight';\n              }\n              if (domNodeStyle.color !== 'HighlightText') {\n                domNodeStyle.color = 'HighlightText';\n              }\n              if (domNodeStyle.zIndex !== '-1') {\n                domNodeStyle.zIndex = '-1';\n              }\n              if (domNodeStyle.pointerEvents !== 'none') {\n                domNodeStyle.pointerEvents = 'none';\n              }\n              if (domNodeStyle.marginTop !== px(-1.5)) {\n                domNodeStyle.marginTop = px(-1.5);\n              }\n              if (domNodeStyle.paddingTop !== px(4)) {\n                domNodeStyle.paddingTop = px(4);\n              }\n              if (domNodeStyle.paddingBottom !== px(0)) {\n                domNodeStyle.paddingBottom = px(0);\n              }\n            }\n            if (onReposition !== undefined) {\n              onReposition(domNodes);\n            }\n          });\n        }\n      }\n      previousAnchorNode = currentAnchorNode;\n      previousAnchorOffset = currentAnchorOffset;\n      previousFocusNode = currentFocusNode;\n      previousFocusOffset = currentFocusOffset;\n    });\n  }\n  compute(editor.getEditorState());\n  return mergeRegister(editor.registerUpdateListener(({\n    editorState\n  }) => compute(editorState)), removeRangeListener, () => {\n    removeRangeListener();\n  });\n}\n\n/** @module @lexical/utils */\n/**\n * Takes an HTML element and adds the classNames passed within an array,\n * ignoring any non-string types. A space can be used to add multiple classes\n * eg. addClassNamesToElement(element, ['element-inner active', true, null])\n * will add both 'element-inner' and 'active' as classes to that element.\n * @param element - The element in which the classes are added\n * @param classNames - An array defining the class names to add to the element\n */\nfunction addClassNamesToElement(element, ...classNames) {\n  const classesToAdd = normalizeClassNames(...classNames);\n  if (classesToAdd.length > 0) {\n    element.classList.add(...classesToAdd);\n  }\n}\n\n/**\n * Takes an HTML element and removes the classNames passed within an array,\n * ignoring any non-string types. A space can be used to remove multiple classes\n * eg. removeClassNamesFromElement(element, ['active small', true, null])\n * will remove both the 'active' and 'small' classes from that element.\n * @param element - The element in which the classes are removed\n * @param classNames - An array defining the class names to remove from the element\n */\nfunction removeClassNamesFromElement(element, ...classNames) {\n  const classesToRemove = normalizeClassNames(...classNames);\n  if (classesToRemove.length > 0) {\n    element.classList.remove(...classesToRemove);\n  }\n}\n\n/**\n * Returns true if the file type matches the types passed within the acceptableMimeTypes array, false otherwise.\n * The types passed must be strings and are CASE-SENSITIVE.\n * eg. if file is of type 'text' and acceptableMimeTypes = ['TEXT', 'IMAGE'] the function will return false.\n * @param file - The file you want to type check.\n * @param acceptableMimeTypes - An array of strings of types which the file is checked against.\n * @returns true if the file is an acceptable mime type, false otherwise.\n */\nfunction isMimeType(file, acceptableMimeTypes) {\n  for (const acceptableType of acceptableMimeTypes) {\n    if (file.type.startsWith(acceptableType)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Lexical File Reader with:\n *  1. MIME type support\n *  2. batched results (HistoryPlugin compatibility)\n *  3. Order aware (respects the order when multiple Files are passed)\n *\n * const filesResult = await mediaFileReader(files, ['image/']);\n * filesResult.forEach(file => editor.dispatchCommand('INSERT_IMAGE', {\n *   src: file.result,\n * }));\n */\nfunction mediaFileReader(files, acceptableMimeTypes) {\n  const filesIterator = files[Symbol.iterator]();\n  return new Promise((resolve, reject) => {\n    const processed = [];\n    const handleNextFile = () => {\n      const {\n        done,\n        value: file\n      } = filesIterator.next();\n      if (done) {\n        return resolve(processed);\n      }\n      const fileReader = new FileReader();\n      fileReader.addEventListener('error', reject);\n      fileReader.addEventListener('load', () => {\n        const result = fileReader.result;\n        if (typeof result === 'string') {\n          processed.push({\n            file,\n            result\n          });\n        }\n        handleNextFile();\n      });\n      if (isMimeType(file, acceptableMimeTypes)) {\n        fileReader.readAsDataURL(file);\n      } else {\n        handleNextFile();\n      }\n    };\n    handleNextFile();\n  });\n}\n\n/**\n * \"Depth-First Search\" starts at the root/top node of a tree and goes as far as it can down a branch end\n * before backtracking and finding a new path. Consider solving a maze by hugging either wall, moving down a\n * branch until you hit a dead-end (leaf) and backtracking to find the nearest branching path and repeat.\n * It will then return all the nodes found in the search in an array of objects.\n * @param startingNode - The node to start the search, if ommitted, it will start at the root node.\n * @param endingNode - The node to end the search, if ommitted, it will find all descendants of the startingNode.\n * @returns An array of objects of all the nodes found by the search, including their depth into the tree.\n * {depth: number, node: LexicalNode} It will always return at least 1 node (the ending node) so long as it exists\n */\nfunction $dfs(startingNode, endingNode) {\n  const nodes = [];\n  const start = (startingNode || $getRoot()).getLatest();\n  const end = endingNode || ($isElementNode(start) ? start.getLastDescendant() : start);\n  let node = start;\n  let depth = $getDepth(node);\n  while (node !== null && !node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n    if ($isElementNode(node) && node.getChildrenSize() > 0) {\n      node = node.getFirstChild();\n      depth++;\n    } else {\n      // Find immediate sibling or nearest parent sibling\n      let sibling = null;\n      while (sibling === null && node !== null) {\n        sibling = node.getNextSibling();\n        if (sibling === null) {\n          node = node.getParent();\n          depth--;\n        } else {\n          node = sibling;\n        }\n      }\n    }\n  }\n  if (node !== null && node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n  }\n  return nodes;\n}\nfunction $getDepth(node) {\n  let innerNode = node;\n  let depth = 0;\n  while ((innerNode = innerNode.getParent()) !== null) {\n    depth++;\n  }\n  return depth;\n}\n\n/**\n * Takes a node and traverses up its ancestors (toward the root node)\n * in order to find a specific type of node.\n * @param node - the node to begin searching.\n * @param klass - an instance of the type of node to look for.\n * @returns the node of type klass that was passed, or null if none exist.\n */\nfunction $getNearestNodeOfType(node, klass) {\n  let parent = node;\n  while (parent != null) {\n    if (parent instanceof klass) {\n      return parent;\n    }\n    parent = parent.getParent();\n  }\n  return null;\n}\n\n/**\n * Returns the element node of the nearest ancestor, otherwise throws an error.\n * @param startNode - The starting node of the search\n * @returns The ancestor node found\n */\nfunction $getNearestBlockElementAncestorOrThrow(startNode) {\n  const blockNode = $findMatchingParent(startNode, node => $isElementNode(node) && !node.isInline());\n  if (!$isElementNode(blockNode)) {\n    {\n      throw Error(`Expected node ${startNode.__key} to have closest block element node.`);\n    }\n  }\n  return blockNode;\n}\n/**\n * Starts with a node and moves up the tree (toward the root node) to find a matching node based on\n * the search parameters of the findFn. (Consider JavaScripts' .find() function where a testing function must be\n * passed as an argument. eg. if( (node) => node.__type === 'div') ) return true; otherwise return false\n * @param startingNode - The node where the search starts.\n * @param findFn - A testing function that returns true if the current node satisfies the testing parameters.\n * @returns A parent node that matches the findFn parameters, or null if one wasn't found.\n */\nconst $findMatchingParent = (startingNode, findFn) => {\n  let curr = startingNode;\n  while (curr !== $getRoot() && curr != null) {\n    if (findFn(curr)) {\n      return curr;\n    }\n    curr = curr.getParent();\n  }\n  return null;\n};\n\n/**\n * Attempts to resolve nested element nodes of the same type into a single node of that type.\n * It is generally used for marks/commenting\n * @param editor - The lexical editor\n * @param targetNode - The target for the nested element to be extracted from.\n * @param cloneNode - See {@link $createMarkNode}\n * @param handleOverlap - Handles any overlap between the node to extract and the targetNode\n * @returns The lexical editor\n */\nfunction registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {\n  const $isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n  const $findMatch = node => {\n    // First validate we don't have any children that are of the target,\n    // as we need to handle them first.\n    const children = node.getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if ($isTargetNode(child)) {\n        return null;\n      }\n    }\n    let parentNode = node;\n    let childNode = node;\n    while (parentNode !== null) {\n      childNode = parentNode;\n      parentNode = parentNode.getParent();\n      if ($isTargetNode(parentNode)) {\n        return {\n          child: childNode,\n          parent: parentNode\n        };\n      }\n    }\n    return null;\n  };\n  const elementNodeTransform = node => {\n    const match = $findMatch(node);\n    if (match !== null) {\n      const {\n        child,\n        parent\n      } = match;\n\n      // Simple path, we can move child out and siblings into a new parent.\n\n      if (child.is(node)) {\n        handleOverlap(parent, node);\n        const nextSiblings = child.getNextSiblings();\n        const nextSiblingsLength = nextSiblings.length;\n        parent.insertAfter(child);\n        if (nextSiblingsLength !== 0) {\n          const newParent = cloneNode(parent);\n          child.insertAfter(newParent);\n          for (let i = 0; i < nextSiblingsLength; i++) {\n            newParent.append(nextSiblings[i]);\n          }\n        }\n        if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {\n          parent.remove();\n        }\n      }\n    }\n  };\n  return editor.registerNodeTransform(targetNode, elementNodeTransform);\n}\n\n/**\n * Clones the editor and marks it as dirty to be reconciled. If there was a selection,\n * it would be set back to its previous state, or null otherwise.\n * @param editor - The lexical editor\n * @param editorState - The editor's state\n */\nfunction $restoreEditorState(editor, editorState) {\n  const FULL_RECONCILE = 2;\n  const nodeMap = new Map();\n  const activeEditorState = editor._pendingEditorState;\n  for (const [key, node] of editorState._nodeMap) {\n    const clone = $cloneWithProperties(node);\n    if ($isTextNode(clone)) {\n      if (!$isTextNode(node)) {\n        throw Error(`Expected node be a TextNode`);\n      }\n      clone.__text = node.__text;\n    }\n    nodeMap.set(key, clone);\n  }\n  if (activeEditorState) {\n    activeEditorState._nodeMap = nodeMap;\n  }\n  editor._dirtyType = FULL_RECONCILE;\n  const selection = editorState._selection;\n  $setSelection(selection === null ? null : selection.clone());\n}\n\n/**\n * If the selected insertion area is the root/shadow root node (see {@link lexical!$isRootOrShadowRoot}),\n * the node will be appended there, otherwise, it will be inserted before the insertion area.\n * If there is no selection where the node is to be inserted, it will be appended after any current nodes\n * within the tree, as a child of the root node. A paragraph node will then be added after the inserted node and selected.\n * @param node - The node to be inserted\n * @returns The node after its insertion\n */\nfunction $insertNodeToNearestRoot(node) {\n  const selection = $getSelection() || $getPreviousSelection();\n  if ($isRangeSelection(selection)) {\n    const {\n      focus\n    } = selection;\n    const focusNode = focus.getNode();\n    const focusOffset = focus.offset;\n    if ($isRootOrShadowRoot(focusNode)) {\n      const focusChild = focusNode.getChildAtIndex(focusOffset);\n      if (focusChild == null) {\n        focusNode.append(node);\n      } else {\n        focusChild.insertBefore(node);\n      }\n      node.selectNext();\n    } else {\n      let splitNode;\n      let splitOffset;\n      if ($isTextNode(focusNode)) {\n        splitNode = focusNode.getParentOrThrow();\n        splitOffset = focusNode.getIndexWithinParent();\n        if (focusOffset > 0) {\n          splitOffset += 1;\n          focusNode.splitText(focusOffset);\n        }\n      } else {\n        splitNode = focusNode;\n        splitOffset = focusOffset;\n      }\n      const [, rightTree] = $splitNode(splitNode, splitOffset);\n      rightTree.insertBefore(node);\n      rightTree.selectStart();\n    }\n  } else {\n    if (selection != null) {\n      const nodes = selection.getNodes();\n      nodes[nodes.length - 1].getTopLevelElementOrThrow().insertAfter(node);\n    } else {\n      const root = $getRoot();\n      root.append(node);\n    }\n    const paragraphNode = $createParagraphNode();\n    node.insertAfter(paragraphNode);\n    paragraphNode.select();\n  }\n  return node.getLatest();\n}\n\n/**\n * Wraps the node into another node created from a createElementNode function, eg. $createParagraphNode\n * @param node - Node to be wrapped.\n * @param createElementNode - Creates a new lexical element to wrap the to-be-wrapped node and returns it.\n * @returns A new lexical element with the previous node appended within (as a child, including its children).\n */\nfunction $wrapNodeInElement(node, createElementNode) {\n  const elementNode = createElementNode();\n  node.replace(elementNode);\n  elementNode.append(node);\n  return elementNode;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n/**\n * @param object = The instance of the type\n * @param objectClass = The class of the type\n * @returns Whether the object is has the same Klass of the objectClass, ignoring the difference across window (e.g. different iframs)\n */\nfunction objectKlassEquals(object, objectClass) {\n  return object !== null ? Object.getPrototypeOf(object).constructor.name === objectClass.name : false;\n}\n\n/**\n * Filter the nodes\n * @param nodes Array of nodes that needs to be filtered\n * @param filterFn A filter function that returns node if the current node satisfies the condition otherwise null\n * @returns Array of filtered nodes\n */\n\nfunction $filter(nodes, filterFn) {\n  const result = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = filterFn(nodes[i]);\n    if (node !== null) {\n      result.push(node);\n    }\n  }\n  return result;\n}\n/**\n * Appends the node before the first child of the parent node\n * @param parent A parent node\n * @param node Node that needs to be appended\n */\nfunction $insertFirst(parent, node) {\n  const firstChild = parent.getFirstChild();\n  if (firstChild !== null) {\n    firstChild.insertBefore(node);\n  } else {\n    parent.append(node);\n  }\n}\n\nexport { $dfs, $filter, $findMatchingParent, $getNearestBlockElementAncestorOrThrow, $getNearestNodeOfType, $insertFirst, $insertNodeToNearestRoot, $restoreEditorState, $wrapNodeInElement, addClassNamesToElement, isMimeType, markSelection, mediaFileReader, mergeRegister, objectKlassEquals, positionNodeOnRange, registerNestedElementResolver, removeClassNamesFromElement };\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { $isTextNode, $isElementNode, $getCharacterOffsets, $isRootNode, $getNodeByKey, $getPreviousSelection, $createTextNode, $isRangeSelection, $getRoot, $isRootOrShadowRoot, $hasAncestor, $isLeafNode, $setSelection, $getAdjacentNode, $isDecoratorNode, $isLineBreakNode } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CSS_TO_STYLES = new Map();\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction getDOMTextNode(element) {\n  let node = element;\n  while (node != null) {\n    if (node.nodeType === Node.TEXT_NODE) {\n      return node;\n    }\n    node = node.firstChild;\n  }\n  return null;\n}\nfunction getDOMIndexWithinParent(node) {\n  const parent = node.parentNode;\n  if (parent == null) {\n    throw new Error('Should never happen');\n  }\n  return [parent, Array.from(parent.childNodes).indexOf(node)];\n}\n\n/**\n * Creates a selection range for the DOM.\n * @param editor - The lexical editor.\n * @param anchorNode - The anchor node of a selection.\n * @param _anchorOffset - The amount of space offset from the anchor to the focus.\n * @param focusNode - The current focus.\n * @param _focusOffset - The amount of space offset from the focus to the anchor.\n * @returns The range of selection for the DOM that was created.\n */\nfunction createDOMRange(editor, anchorNode, _anchorOffset, focusNode, _focusOffset) {\n  const anchorKey = anchorNode.getKey();\n  const focusKey = focusNode.getKey();\n  const range = document.createRange();\n  let anchorDOM = editor.getElementByKey(anchorKey);\n  let focusDOM = editor.getElementByKey(focusKey);\n  let anchorOffset = _anchorOffset;\n  let focusOffset = _focusOffset;\n  if ($isTextNode(anchorNode)) {\n    anchorDOM = getDOMTextNode(anchorDOM);\n  }\n  if ($isTextNode(focusNode)) {\n    focusDOM = getDOMTextNode(focusDOM);\n  }\n  if (anchorNode === undefined || focusNode === undefined || anchorDOM === null || focusDOM === null) {\n    return null;\n  }\n  if (anchorDOM.nodeName === 'BR') {\n    [anchorDOM, anchorOffset] = getDOMIndexWithinParent(anchorDOM);\n  }\n  if (focusDOM.nodeName === 'BR') {\n    [focusDOM, focusOffset] = getDOMIndexWithinParent(focusDOM);\n  }\n  const firstChild = anchorDOM.firstChild;\n  if (anchorDOM === focusDOM && firstChild != null && firstChild.nodeName === 'BR' && anchorOffset === 0 && focusOffset === 0) {\n    focusOffset = 1;\n  }\n  try {\n    range.setStart(anchorDOM, anchorOffset);\n    range.setEnd(focusDOM, focusOffset);\n  } catch (e) {\n    return null;\n  }\n  if (range.collapsed && (anchorOffset !== focusOffset || anchorKey !== focusKey)) {\n    // Range is backwards, we need to reverse it\n    range.setStart(focusDOM, focusOffset);\n    range.setEnd(anchorDOM, anchorOffset);\n  }\n  return range;\n}\n\n/**\n * Creates DOMRects, generally used to help the editor find a specific location on the screen.\n * @param editor - The lexical editor\n * @param range - A fragment of a document that can contain nodes and parts of text nodes.\n * @returns The selectionRects as an array.\n */\nfunction createRectsFromDOMRange(editor, range) {\n  const rootElement = editor.getRootElement();\n  if (rootElement === null) {\n    return [];\n  }\n  const rootRect = rootElement.getBoundingClientRect();\n  const computedStyle = getComputedStyle(rootElement);\n  const rootPadding = parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\n  const selectionRects = Array.from(range.getClientRects());\n  let selectionRectsLength = selectionRects.length;\n  //sort rects from top left to bottom right.\n  selectionRects.sort((a, b) => {\n    const top = a.top - b.top;\n    // Some rects match position closely, but not perfectly,\n    // so we give a 3px tolerance.\n    if (Math.abs(top) <= 3) {\n      return a.left - b.left;\n    }\n    return top;\n  });\n  let prevRect;\n  for (let i = 0; i < selectionRectsLength; i++) {\n    const selectionRect = selectionRects[i];\n    // Exclude rects that overlap preceding Rects in the sorted list.\n    const isOverlappingRect = prevRect && prevRect.top <= selectionRect.top && prevRect.top + prevRect.height > selectionRect.top && prevRect.left + prevRect.width > selectionRect.left;\n    // Exclude selections that span the entire element\n    const selectionSpansElement = selectionRect.width + rootPadding === rootRect.width;\n    if (isOverlappingRect || selectionSpansElement) {\n      selectionRects.splice(i--, 1);\n      selectionRectsLength--;\n      continue;\n    }\n    prevRect = selectionRect;\n  }\n  return selectionRects;\n}\n\n/**\n * Creates an object containing all the styles and their values provided in the CSS string.\n * @param css - The CSS string of styles and their values.\n * @returns The styleObject containing all the styles and their values.\n */\nfunction getStyleObjectFromRawCSS(css) {\n  const styleObject = {};\n  const styles = css.split(';');\n  for (const style of styles) {\n    if (style !== '') {\n      const [key, value] = style.split(/:([^]+)/); // split on first colon\n      if (key && value) {\n        styleObject[key.trim()] = value.trim();\n      }\n    }\n  }\n  return styleObject;\n}\n\n/**\n * Given a CSS string, returns an object from the style cache.\n * @param css - The CSS property as a string.\n * @returns The value of the given CSS property.\n */\nfunction getStyleObjectFromCSS(css) {\n  let value = CSS_TO_STYLES.get(css);\n  if (value === undefined) {\n    value = getStyleObjectFromRawCSS(css);\n    CSS_TO_STYLES.set(css, value);\n  }\n  {\n    // Freeze the value in DEV to prevent accidental mutations\n    Object.freeze(value);\n  }\n  return value;\n}\n\n/**\n * Gets the CSS styles from the style object.\n * @param styles - The style object containing the styles to get.\n * @returns A string containing the CSS styles and their values.\n */\nfunction getCSSFromStyleObject(styles) {\n  let css = '';\n  for (const style in styles) {\n    if (style) {\n      css += `${style}: ${styles[style]};`;\n    }\n  }\n  return css;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction $updateElementNodeProperties(target, source) {\n  target.__first = source.__first;\n  target.__last = source.__last;\n  target.__size = source.__size;\n  target.__format = source.__format;\n  target.__indent = source.__indent;\n  target.__dir = source.__dir;\n  return target;\n}\nfunction $updateTextNodeProperties(target, source) {\n  target.__format = source.__format;\n  target.__style = source.__style;\n  target.__mode = source.__mode;\n  target.__detail = source.__detail;\n  return target;\n}\n\n/**\n * Returns a copy of a node, but generates a new key for the copy.\n * @param node - The node to be cloned.\n * @returns The clone of the node.\n */\nfunction $cloneWithProperties(node) {\n  const constructor = node.constructor;\n  // @ts-expect-error\n  const clone = constructor.clone(node);\n  clone.__parent = node.__parent;\n  clone.__next = node.__next;\n  clone.__prev = node.__prev;\n  if ($isElementNode(node) && $isElementNode(clone)) {\n    return $updateElementNodeProperties(clone, node);\n  }\n  if ($isTextNode(node) && $isTextNode(clone)) {\n    return $updateTextNodeProperties(clone, node);\n  }\n  return clone;\n}\n\n/**\n * Generally used to append text content to HTML and JSON. Grabs the text content and \"slices\"\n * it to be generated into the new TextNode.\n * @param selection - The selection containing the node whose TextNode is to be edited.\n * @param textNode - The TextNode to be edited.\n * @returns The updated TextNode.\n */\nfunction $sliceSelectedTextNodeContent(selection, textNode) {\n  const anchorAndFocus = selection.getStartEndPoints();\n  if (textNode.isSelected(selection) && !textNode.isSegmented() && !textNode.isToken() && anchorAndFocus !== null) {\n    const [anchor, focus] = anchorAndFocus;\n    const isBackward = selection.isBackward();\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    const isAnchor = textNode.is(anchorNode);\n    const isFocus = textNode.is(focusNode);\n    if (isAnchor || isFocus) {\n      const [anchorOffset, focusOffset] = $getCharacterOffsets(selection);\n      const isSame = anchorNode.is(focusNode);\n      const isFirst = textNode.is(isBackward ? focusNode : anchorNode);\n      const isLast = textNode.is(isBackward ? anchorNode : focusNode);\n      let startOffset = 0;\n      let endOffset = undefined;\n      if (isSame) {\n        startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n      } else if (isFirst) {\n        const offset = isBackward ? focusOffset : anchorOffset;\n        startOffset = offset;\n        endOffset = undefined;\n      } else if (isLast) {\n        const offset = isBackward ? anchorOffset : focusOffset;\n        startOffset = 0;\n        endOffset = offset;\n      }\n      textNode.__text = textNode.__text.slice(startOffset, endOffset);\n      return textNode;\n    }\n  }\n  return textNode;\n}\n\n/**\n * Determines if the current selection is at the end of the node.\n * @param point - The point of the selection to test.\n * @returns true if the provided point offset is in the last possible position, false otherwise.\n */\nfunction $isAtNodeEnd(point) {\n  if (point.type === 'text') {\n    return point.offset === point.getNode().getTextContentSize();\n  }\n  const node = point.getNode();\n  if (!$isElementNode(node)) {\n    throw Error(`isAtNodeEnd: node must be a TextNode or ElementNode`);\n  }\n  return point.offset === node.getChildrenSize();\n}\n\n/**\n * Trims text from a node in order to shorten it, eg. to enforce a text's max length. If it deletes text\n * that is an ancestor of the anchor then it will leave 2 indents, otherwise, if no text content exists, it deletes\n * the TextNode. It will move the focus to either the end of any left over text or beginning of a new TextNode.\n * @param editor - The lexical editor.\n * @param anchor - The anchor of the current selection, where the selection should be pointing.\n * @param delCount - The amount of characters to delete. Useful as a dynamic variable eg. textContentSize - maxLength;\n */\nfunction trimTextContentFromAnchor(editor, anchor, delCount) {\n  // Work from the current selection anchor point\n  let currentNode = anchor.getNode();\n  let remaining = delCount;\n  if ($isElementNode(currentNode)) {\n    const descendantNode = currentNode.getDescendantByIndex(anchor.offset);\n    if (descendantNode !== null) {\n      currentNode = descendantNode;\n    }\n  }\n  while (remaining > 0 && currentNode !== null) {\n    if ($isElementNode(currentNode)) {\n      const lastDescendant = currentNode.getLastDescendant();\n      if (lastDescendant !== null) {\n        currentNode = lastDescendant;\n      }\n    }\n    let nextNode = currentNode.getPreviousSibling();\n    let additionalElementWhitespace = 0;\n    if (nextNode === null) {\n      let parent = currentNode.getParentOrThrow();\n      let parentSibling = parent.getPreviousSibling();\n      while (parentSibling === null) {\n        parent = parent.getParent();\n        if (parent === null) {\n          nextNode = null;\n          break;\n        }\n        parentSibling = parent.getPreviousSibling();\n      }\n      if (parent !== null) {\n        additionalElementWhitespace = parent.isInline() ? 0 : 2;\n        nextNode = parentSibling;\n      }\n    }\n    let text = currentNode.getTextContent();\n    // If the text is empty, we need to consider adding in two line breaks to match\n    // the content if we were to get it from its parent.\n    if (text === '' && $isElementNode(currentNode) && !currentNode.isInline()) {\n      // TODO: should this be handled in core?\n      text = '\\n\\n';\n    }\n    const currentNodeSize = text.length;\n    if (!$isTextNode(currentNode) || remaining >= currentNodeSize) {\n      const parent = currentNode.getParent();\n      currentNode.remove();\n      if (parent != null && parent.getChildrenSize() === 0 && !$isRootNode(parent)) {\n        parent.remove();\n      }\n      remaining -= currentNodeSize + additionalElementWhitespace;\n      currentNode = nextNode;\n    } else {\n      const key = currentNode.getKey();\n      // See if we can just revert it to what was in the last editor state\n      const prevTextContent = editor.getEditorState().read(() => {\n        const prevNode = $getNodeByKey(key);\n        if ($isTextNode(prevNode) && prevNode.isSimpleText()) {\n          return prevNode.getTextContent();\n        }\n        return null;\n      });\n      const offset = currentNodeSize - remaining;\n      const slicedText = text.slice(0, offset);\n      if (prevTextContent !== null && prevTextContent !== text) {\n        const prevSelection = $getPreviousSelection();\n        let target = currentNode;\n        if (!currentNode.isSimpleText()) {\n          const textNode = $createTextNode(prevTextContent);\n          currentNode.replace(textNode);\n          target = textNode;\n        } else {\n          currentNode.setTextContent(prevTextContent);\n        }\n        if ($isRangeSelection(prevSelection) && prevSelection.isCollapsed()) {\n          const prevOffset = prevSelection.anchor.offset;\n          target.select(prevOffset, prevOffset);\n        }\n      } else if (currentNode.isSimpleText()) {\n        // Split text\n        const isSelected = anchor.key === key;\n        let anchorOffset = anchor.offset;\n        // Move offset to end if it's less than the remaining number, otherwise\n        // we'll have a negative splitStart.\n        if (anchorOffset < remaining) {\n          anchorOffset = currentNodeSize;\n        }\n        const splitStart = isSelected ? anchorOffset - remaining : 0;\n        const splitEnd = isSelected ? anchorOffset : offset;\n        if (isSelected && splitStart === 0) {\n          const [excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        } else {\n          const [, excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        }\n      } else {\n        const textNode = $createTextNode(slicedText);\n        currentNode.replace(textNode);\n      }\n      remaining = 0;\n    }\n  }\n}\n\n/**\n * Gets the TextNode's style object and adds the styles to the CSS.\n * @param node - The TextNode to add styles to.\n */\nfunction $addNodeStyle(node) {\n  const CSSText = node.getStyle();\n  const styles = getStyleObjectFromRawCSS(CSSText);\n  CSS_TO_STYLES.set(CSSText, styles);\n}\nfunction $patchStyle(target, patch) {\n  const prevStyles = getStyleObjectFromCSS('getStyle' in target ? target.getStyle() : target.style);\n  const newStyles = Object.entries(patch).reduce((styles, [key, value]) => {\n    if (value instanceof Function) {\n      styles[key] = value(prevStyles[key]);\n    } else if (value === null) {\n      delete styles[key];\n    } else {\n      styles[key] = value;\n    }\n    return styles;\n  }, {\n    ...prevStyles\n  } || {});\n  const newCSSText = getCSSFromStyleObject(newStyles);\n  target.setStyle(newCSSText);\n  CSS_TO_STYLES.set(newCSSText, newStyles);\n}\n\n/**\n * Applies the provided styles to the TextNodes in the provided Selection.\n * Will update partially selected TextNodes by splitting the TextNode and applying\n * the styles to the appropriate one.\n * @param selection - The selected node(s) to update.\n * @param patch - The patch to apply, which can include multiple styles. { CSSProperty: value }. Can also accept a function that returns the new property value.\n */\nfunction $patchStyleText(selection, patch) {\n  const selectedNodes = selection.getNodes();\n  const selectedNodesLength = selectedNodes.length;\n  const anchorAndFocus = selection.getStartEndPoints();\n  if (anchorAndFocus === null) {\n    return;\n  }\n  const [anchor, focus] = anchorAndFocus;\n  const lastIndex = selectedNodesLength - 1;\n  let firstNode = selectedNodes[0];\n  let lastNode = selectedNodes[lastIndex];\n  if (selection.isCollapsed() && $isRangeSelection(selection)) {\n    $patchStyle(selection, patch);\n    return;\n  }\n  const firstNodeText = firstNode.getTextContent();\n  const firstNodeTextLength = firstNodeText.length;\n  const focusOffset = focus.offset;\n  let anchorOffset = anchor.offset;\n  const isBefore = anchor.isBefore(focus);\n  let startOffset = isBefore ? anchorOffset : focusOffset;\n  let endOffset = isBefore ? focusOffset : anchorOffset;\n  const startType = isBefore ? anchor.type : focus.type;\n  const endType = isBefore ? focus.type : anchor.type;\n  const endKey = isBefore ? focus.key : anchor.key;\n\n  // This is the case where the user only selected the very end of the\n  // first node so we don't want to include it in the formatting change.\n  if ($isTextNode(firstNode) && startOffset === firstNodeTextLength) {\n    const nextSibling = firstNode.getNextSibling();\n    if ($isTextNode(nextSibling)) {\n      // we basically make the second node the firstNode, changing offsets accordingly\n      anchorOffset = 0;\n      startOffset = 0;\n      firstNode = nextSibling;\n    }\n  }\n\n  // This is the case where we only selected a single node\n  if (selectedNodes.length === 1) {\n    if ($isTextNode(firstNode) && firstNode.canHaveFormat()) {\n      startOffset = startType === 'element' ? 0 : anchorOffset > focusOffset ? focusOffset : anchorOffset;\n      endOffset = endType === 'element' ? firstNodeTextLength : anchorOffset > focusOffset ? anchorOffset : focusOffset;\n\n      // No actual text is selected, so do nothing.\n      if (startOffset === endOffset) {\n        return;\n      }\n\n      // The entire node is selected, so just format it\n      if (startOffset === 0 && endOffset === firstNodeTextLength) {\n        $patchStyle(firstNode, patch);\n        firstNode.select(startOffset, endOffset);\n      } else {\n        // The node is partially selected, so split it into two nodes\n        // and style the selected one.\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        $patchStyle(replacement, patch);\n        replacement.select(0, endOffset - startOffset);\n      }\n    } // multiple nodes selected.\n  } else {\n    if ($isTextNode(firstNode) && startOffset < firstNode.getTextContentSize() && firstNode.canHaveFormat()) {\n      if (startOffset !== 0) {\n        // the entire first node isn't selected, so split it\n        firstNode = firstNode.splitText(startOffset)[1];\n        startOffset = 0;\n        anchor.set(firstNode.getKey(), startOffset, 'text');\n      }\n      $patchStyle(firstNode, patch);\n    }\n    if ($isTextNode(lastNode) && lastNode.canHaveFormat()) {\n      const lastNodeText = lastNode.getTextContent();\n      const lastNodeTextLength = lastNodeText.length;\n\n      // The last node might not actually be the end node\n      //\n      // If not, assume the last node is fully-selected unless the end offset is\n      // zero.\n      if (lastNode.__key !== endKey && endOffset !== 0) {\n        endOffset = lastNodeTextLength;\n      }\n\n      // if the entire last node isn't selected, split it\n      if (endOffset !== lastNodeTextLength) {\n        [lastNode] = lastNode.splitText(endOffset);\n      }\n      if (endOffset !== 0 || endType === 'element') {\n        $patchStyle(lastNode, patch);\n      }\n    }\n\n    // style all the text nodes in between\n    for (let i = 1; i < lastIndex; i++) {\n      const selectedNode = selectedNodes[i];\n      const selectedNodeKey = selectedNode.getKey();\n      if ($isTextNode(selectedNode) && selectedNode.canHaveFormat() && selectedNodeKey !== firstNode.getKey() && selectedNodeKey !== lastNode.getKey() && !selectedNode.isToken()) {\n        $patchStyle(selectedNode, patch);\n      }\n    }\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Converts all nodes in the selection that are of one block type to another.\n * @param selection - The selected blocks to be converted.\n * @param createElement - The function that creates the node. eg. $createParagraphNode.\n */\nfunction $setBlocksType(selection, createElement) {\n  if (selection === null) {\n    return;\n  }\n  const anchorAndFocus = selection.getStartEndPoints();\n  const anchor = anchorAndFocus ? anchorAndFocus[0] : null;\n  if (anchor !== null && anchor.key === 'root') {\n    const element = createElement();\n    const root = $getRoot();\n    const firstChild = root.getFirstChild();\n    if (firstChild) {\n      firstChild.replace(element, true);\n    } else {\n      root.append(element);\n    }\n    return;\n  }\n  const nodes = selection.getNodes();\n  const firstSelectedBlock = anchor !== null ? $getAncestor(anchor.getNode(), INTERNAL_$isBlock) : false;\n  if (firstSelectedBlock && nodes.indexOf(firstSelectedBlock) === -1) {\n    nodes.push(firstSelectedBlock);\n  }\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!INTERNAL_$isBlock(node)) {\n      continue;\n    }\n    if (!$isElementNode(node)) {\n      throw Error(`Expected block node to be an ElementNode`);\n    }\n    const targetElement = createElement();\n    targetElement.setFormat(node.getFormatType());\n    targetElement.setIndent(node.getIndent());\n    node.replace(targetElement, true);\n  }\n}\nfunction isPointAttached(point) {\n  return point.getNode().isAttached();\n}\nfunction $removeParentEmptyElements(startingNode) {\n  let node = startingNode;\n  while (node !== null && !$isRootOrShadowRoot(node)) {\n    const latest = node.getLatest();\n    const parentNode = node.getParent();\n    if (latest.getChildrenSize() === 0) {\n      node.remove(true);\n    }\n    node = parentNode;\n  }\n}\n\n/**\n * @deprecated\n * Wraps all nodes in the selection into another node of the type returned by createElement.\n * @param selection - The selection of nodes to be wrapped.\n * @param createElement - A function that creates the wrapping ElementNode. eg. $createParagraphNode.\n * @param wrappingElement - An element to append the wrapped selection and its children to.\n */\nfunction $wrapNodes(selection, createElement, wrappingElement = null) {\n  const anchorAndFocus = selection.getStartEndPoints();\n  const anchor = anchorAndFocus ? anchorAndFocus[0] : null;\n  const nodes = selection.getNodes();\n  const nodesLength = nodes.length;\n  if (anchor !== null && (nodesLength === 0 || nodesLength === 1 && anchor.type === 'element' && anchor.getNode().getChildrenSize() === 0)) {\n    const target = anchor.type === 'text' ? anchor.getNode().getParentOrThrow() : anchor.getNode();\n    const children = target.getChildren();\n    let element = createElement();\n    element.setFormat(target.getFormatType());\n    element.setIndent(target.getIndent());\n    children.forEach(child => element.append(child));\n    if (wrappingElement) {\n      element = wrappingElement.append(element);\n    }\n    target.replace(element);\n    return;\n  }\n  let topLevelNode = null;\n  let descendants = [];\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    // Determine whether wrapping has to be broken down into multiple chunks. This can happen if the\n    // user selected multiple Root-like nodes that have to be treated separately as if they are\n    // their own branch. I.e. you don't want to wrap a whole table, but rather the contents of each\n    // of each of the cell nodes.\n    if ($isRootOrShadowRoot(node)) {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [];\n      topLevelNode = node;\n    } else if (topLevelNode === null || topLevelNode !== null && $hasAncestor(node, topLevelNode)) {\n      descendants.push(node);\n    } else {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [node];\n    }\n  }\n  $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n}\n\n/**\n * Wraps each node into a new ElementNode.\n * @param selection - The selection of nodes to wrap.\n * @param nodes - An array of nodes, generally the descendants of the selection.\n * @param nodesLength - The length of nodes.\n * @param createElement - A function that creates the wrapping ElementNode. eg. $createParagraphNode.\n * @param wrappingElement - An element to wrap all the nodes into.\n * @returns\n */\nfunction $wrapNodesImpl(selection, nodes, nodesLength, createElement, wrappingElement = null) {\n  if (nodes.length === 0) {\n    return;\n  }\n  const firstNode = nodes[0];\n  const elementMapping = new Map();\n  const elements = [];\n  // The below logic is to find the right target for us to\n  // either insertAfter/insertBefore/append the corresponding\n  // elements to. This is made more complicated due to nested\n  // structures.\n  let target = $isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();\n  if (target.isInline()) {\n    target = target.getParentOrThrow();\n  }\n  let targetIsPrevSibling = false;\n  while (target !== null) {\n    const prevSibling = target.getPreviousSibling();\n    if (prevSibling !== null) {\n      target = prevSibling;\n      targetIsPrevSibling = true;\n      break;\n    }\n    target = target.getParentOrThrow();\n    if ($isRootOrShadowRoot(target)) {\n      break;\n    }\n  }\n  const emptyElements = new Set();\n\n  // Find any top level empty elements\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    if ($isElementNode(node) && node.getChildrenSize() === 0) {\n      emptyElements.add(node.getKey());\n    }\n  }\n  const movedNodes = new Set();\n\n  // Move out all leaf nodes into our elements array.\n  // If we find a top level empty element, also move make\n  // an element for that.\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    let parent = node.getParent();\n    if (parent !== null && parent.isInline()) {\n      parent = parent.getParent();\n    }\n    if (parent !== null && $isLeafNode(node) && !movedNodes.has(node.getKey())) {\n      const parentKey = parent.getKey();\n      if (elementMapping.get(parentKey) === undefined) {\n        const targetElement = createElement();\n        targetElement.setFormat(parent.getFormatType());\n        targetElement.setIndent(parent.getIndent());\n        elements.push(targetElement);\n        elementMapping.set(parentKey, targetElement);\n        // Move node and its siblings to the new\n        // element.\n        parent.getChildren().forEach(child => {\n          targetElement.append(child);\n          movedNodes.add(child.getKey());\n          if ($isElementNode(child)) {\n            // Skip nested leaf nodes if the parent has already been moved\n            child.getChildrenKeys().forEach(key => movedNodes.add(key));\n          }\n        });\n        $removeParentEmptyElements(parent);\n      }\n    } else if (emptyElements.has(node.getKey())) {\n      if (!$isElementNode(node)) {\n        throw Error(`Expected node in emptyElements to be an ElementNode`);\n      }\n      const targetElement = createElement();\n      targetElement.setFormat(node.getFormatType());\n      targetElement.setIndent(node.getIndent());\n      elements.push(targetElement);\n      node.remove(true);\n    }\n  }\n  if (wrappingElement !== null) {\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      wrappingElement.append(element);\n    }\n  }\n  let lastElement = null;\n\n  // If our target is Root-like, let's see if we can re-adjust\n  // so that the target is the first child instead.\n  if ($isRootOrShadowRoot(target)) {\n    if (targetIsPrevSibling) {\n      if (wrappingElement !== null) {\n        target.insertAfter(wrappingElement);\n      } else {\n        for (let i = elements.length - 1; i >= 0; i--) {\n          const element = elements[i];\n          target.insertAfter(element);\n        }\n      }\n    } else {\n      const firstChild = target.getFirstChild();\n      if ($isElementNode(firstChild)) {\n        target = firstChild;\n      }\n      if (firstChild === null) {\n        if (wrappingElement) {\n          target.append(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            target.append(element);\n            lastElement = element;\n          }\n        }\n      } else {\n        if (wrappingElement !== null) {\n          firstChild.insertBefore(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            firstChild.insertBefore(element);\n            lastElement = element;\n          }\n        }\n      }\n    }\n  } else {\n    if (wrappingElement) {\n      target.insertAfter(wrappingElement);\n    } else {\n      for (let i = elements.length - 1; i >= 0; i--) {\n        const element = elements[i];\n        target.insertAfter(element);\n        lastElement = element;\n      }\n    }\n  }\n  const prevSelection = $getPreviousSelection();\n  if ($isRangeSelection(prevSelection) && isPointAttached(prevSelection.anchor) && isPointAttached(prevSelection.focus)) {\n    $setSelection(prevSelection.clone());\n  } else if (lastElement !== null) {\n    lastElement.selectEnd();\n  } else {\n    selection.dirty = true;\n  }\n}\n\n/**\n * Determines if the default character selection should be overridden. Used with DecoratorNodes\n * @param selection - The selection whose default character selection may need to be overridden.\n * @param isBackward - Is the selection backwards (the focus comes before the anchor)?\n * @returns true if it should be overridden, false if not.\n */\nfunction $shouldOverrideDefaultCharacterSelection(selection, isBackward) {\n  const possibleNode = $getAdjacentNode(selection.focus, isBackward);\n  return $isDecoratorNode(possibleNode) && !possibleNode.isIsolated() || $isElementNode(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty();\n}\n\n/**\n * Moves the selection according to the arguments.\n * @param selection - The selected text or nodes.\n * @param isHoldingShift - Is the shift key being held down during the operation.\n * @param isBackward - Is the selection selected backwards (the focus comes before the anchor)?\n * @param granularity - The distance to adjust the current selection.\n */\nfunction $moveCaretSelection(selection, isHoldingShift, isBackward, granularity) {\n  selection.modify(isHoldingShift ? 'extend' : 'move', isBackward, granularity);\n}\n\n/**\n * Tests a parent element for right to left direction.\n * @param selection - The selection whose parent is to be tested.\n * @returns true if the selections' parent element has a direction of 'rtl' (right to left), false otherwise.\n */\nfunction $isParentElementRTL(selection) {\n  const anchorNode = selection.anchor.getNode();\n  const parent = $isRootNode(anchorNode) ? anchorNode : anchorNode.getParentOrThrow();\n  return parent.getDirection() === 'rtl';\n}\n\n/**\n * Moves selection by character according to arguments.\n * @param selection - The selection of the characters to move.\n * @param isHoldingShift - Is the shift key being held down during the operation.\n * @param isBackward - Is the selection backward (the focus comes before the anchor)?\n */\nfunction $moveCharacter(selection, isHoldingShift, isBackward) {\n  const isRTL = $isParentElementRTL(selection);\n  $moveCaretSelection(selection, isHoldingShift, isBackward ? !isRTL : isRTL, 'character');\n}\n\n/**\n * Expands the current Selection to cover all of the content in the editor.\n * @param selection - The current selection.\n */\nfunction $selectAll(selection) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const topParent = anchorNode.getTopLevelElementOrThrow();\n  const root = topParent.getParentOrThrow();\n  let firstNode = root.getFirstDescendant();\n  let lastNode = root.getLastDescendant();\n  let firstType = 'element';\n  let lastType = 'element';\n  let lastOffset = 0;\n  if ($isTextNode(firstNode)) {\n    firstType = 'text';\n  } else if (!$isElementNode(firstNode) && firstNode !== null) {\n    firstNode = firstNode.getParentOrThrow();\n  }\n  if ($isTextNode(lastNode)) {\n    lastType = 'text';\n    lastOffset = lastNode.getTextContentSize();\n  } else if (!$isElementNode(lastNode) && lastNode !== null) {\n    lastNode = lastNode.getParentOrThrow();\n  }\n  if (firstNode && lastNode) {\n    anchor.set(firstNode.getKey(), 0, firstType);\n    focus.set(lastNode.getKey(), lastOffset, lastType);\n  }\n}\n\n/**\n * Returns the current value of a CSS property for Nodes, if set. If not set, it returns the defaultValue.\n * @param node - The node whose style value to get.\n * @param styleProperty - The CSS style property.\n * @param defaultValue - The default value for the property.\n * @returns The value of the property for node.\n */\nfunction $getNodeStyleValueForProperty(node, styleProperty, defaultValue) {\n  const css = node.getStyle();\n  const styleObject = getStyleObjectFromCSS(css);\n  if (styleObject !== null) {\n    return styleObject[styleProperty] || defaultValue;\n  }\n  return defaultValue;\n}\n\n/**\n * Returns the current value of a CSS property for TextNodes in the Selection, if set. If not set, it returns the defaultValue.\n * If all TextNodes do not have the same value, it returns an empty string.\n * @param selection - The selection of TextNodes whose value to find.\n * @param styleProperty - The CSS style property.\n * @param defaultValue - The default value for the property, defaults to an empty string.\n * @returns The value of the property for the selected TextNodes.\n */\nfunction $getSelectionStyleValueForProperty(selection, styleProperty, defaultValue = '') {\n  let styleValue = null;\n  const nodes = selection.getNodes();\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const isBackward = selection.isBackward();\n  const endOffset = isBackward ? focus.offset : anchor.offset;\n  const endNode = isBackward ? focus.getNode() : anchor.getNode();\n  if (selection.isCollapsed() && selection.style !== '') {\n    const css = selection.style;\n    const styleObject = getStyleObjectFromCSS(css);\n    if (styleObject !== null && styleProperty in styleObject) {\n      return styleObject[styleProperty];\n    }\n  }\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n\n    // if no actual characters in the end node are selected, we don't\n    // include it in the selection for purposes of determining style\n    // value\n    if (i !== 0 && endOffset === 0 && node.is(endNode)) {\n      continue;\n    }\n    if ($isTextNode(node)) {\n      const nodeStyleValue = $getNodeStyleValueForProperty(node, styleProperty, defaultValue);\n      if (styleValue === null) {\n        styleValue = nodeStyleValue;\n      } else if (styleValue !== nodeStyleValue) {\n        // multiple text nodes are in the selection and they don't all\n        // have the same style.\n        styleValue = '';\n        break;\n      }\n    }\n  }\n  return styleValue === null ? defaultValue : styleValue;\n}\n\n/**\n * This function is for internal use of the library.\n * Please do not use it as it may change in the future.\n */\nfunction INTERNAL_$isBlock(node) {\n  if ($isDecoratorNode(node)) {\n    return false;\n  }\n  if (!$isElementNode(node) || $isRootOrShadowRoot(node)) {\n    return false;\n  }\n  const firstChild = node.getFirstChild();\n  const isLeafElement = firstChild === null || $isLineBreakNode(firstChild) || $isTextNode(firstChild) || firstChild.isInline();\n  return !node.isInline() && node.canBeEmpty() !== false && isLeafElement;\n}\nfunction $getAncestor(node, predicate) {\n  let parent = node;\n  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {\n    parent = parent.getParentOrThrow();\n  }\n  return predicate(parent) ? parent : null;\n}\n\nexport { $addNodeStyle, $cloneWithProperties, $getSelectionStyleValueForProperty, $isAtNodeEnd, $isParentElementRTL, $moveCaretSelection, $moveCharacter, $patchStyleText, $selectAll, $setBlocksType, $shouldOverrideDefaultCharacterSelection, $sliceSelectedTextNodeContent, $wrapNodes, createDOMRange, createRectsFromDOMRange, getStyleObjectFromCSS, trimTextContentFromAnchor };\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport * as modDev from './LexicalSelection.dev.esm.js';\nimport * as modProd from './LexicalSelection.prod.esm.js';\nconst mod = process.env.NODE_ENV === 'development' ? modDev : modProd;\nexport const $addNodeStyle = mod.$addNodeStyle;\nexport const $cloneWithProperties = mod.$cloneWithProperties;\nexport const $getSelectionStyleValueForProperty = mod.$getSelectionStyleValueForProperty;\nexport const $isAtNodeEnd = mod.$isAtNodeEnd;\nexport const $isParentElementRTL = mod.$isParentElementRTL;\nexport const $moveCaretSelection = mod.$moveCaretSelection;\nexport const $moveCharacter = mod.$moveCharacter;\nexport const $patchStyleText = mod.$patchStyleText;\nexport const $selectAll = mod.$selectAll;\nexport const $setBlocksType = mod.$setBlocksType;\nexport const $shouldOverrideDefaultCharacterSelection = mod.$shouldOverrideDefaultCharacterSelection;\nexport const $sliceSelectedTextNodeContent = mod.$sliceSelectedTextNodeContent;\nexport const $wrapNodes = mod.$wrapNodes;\nexport const createDOMRange = mod.createDOMRange;\nexport const createRectsFromDOMRange = mod.createRectsFromDOMRange;\nexport const getStyleObjectFromCSS = mod.getStyleObjectFromCSS;\nexport const trimTextContentFromAnchor = mod.trimTextContentFromAnchor;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport * as modDev from './LexicalUtils.dev.esm.js';\nimport * as modProd from './LexicalUtils.prod.esm.js';\nconst mod = process.env.NODE_ENV === 'development' ? modDev : modProd;\nexport const $dfs = mod.$dfs;\nexport const $filter = mod.$filter;\nexport const $findMatchingParent = mod.$findMatchingParent;\nexport const $getNearestBlockElementAncestorOrThrow = mod.$getNearestBlockElementAncestorOrThrow;\nexport const $getNearestNodeOfType = mod.$getNearestNodeOfType;\nexport const $insertFirst = mod.$insertFirst;\nexport const $insertNodeToNearestRoot = mod.$insertNodeToNearestRoot;\nexport const $restoreEditorState = mod.$restoreEditorState;\nexport const $splitNode = mod.$splitNode;\nexport const $wrapNodeInElement = mod.$wrapNodeInElement;\nexport const addClassNamesToElement = mod.addClassNamesToElement;\nexport const isHTMLAnchorElement = mod.isHTMLAnchorElement;\nexport const isHTMLElement = mod.isHTMLElement;\nexport const isMimeType = mod.isMimeType;\nexport const markSelection = mod.markSelection;\nexport const mediaFileReader = mod.mediaFileReader;\nexport const mergeRegister = mod.mergeRegister;\nexport const objectKlassEquals = mod.objectKlassEquals;\nexport const positionNodeOnRange = mod.positionNodeOnRange;\nexport const registerNestedElementResolver = mod.registerNestedElementResolver;\nexport const removeClassNamesFromElement = mod.removeClassNamesFromElement;"],
  "mappings": "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",
  "names": ["$addNodeStyle", "$cloneWithProperties", "$getSelectionStyleValueForProperty", "$isAtNodeEnd", "$isParentElementRTL", "$moveCaretSelection", "$moveCharacter", "$patchStyleText", "$selectAll", "$setBlocksType", "$shouldOverrideDefaultCharacterSelection", "$sliceSelectedTextNodeContent", "$wrapNodes", "createDOMRange", "createRectsFromDOMRange", "getStyleObjectFromCSS", "trimTextContentFromAnchor", "createRectsFromDOMRange", "$cloneWithProperties", "mod", "$dfs", "$filter", "$findMatchingParent", "$getNearestBlockElementAncestorOrThrow", "$getNearestNodeOfType", "$insertFirst", "$insertNodeToNearestRoot", "$restoreEditorState", "$splitNode", "$wrapNodeInElement", "addClassNamesToElement", "isHTMLAnchorElement", "isHTMLElement", "isMimeType", "markSelection", "mediaFileReader", "mergeRegister", "objectKlassEquals", "positionNodeOnRange", "registerNestedElementResolver", "removeClassNamesFromElement"]
}
