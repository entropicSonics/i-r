import {
  __export
} from "./chunk-ZS7NZCD4.js";

// ../node_modules/lexical/Lexical.dev.esm.js
var Lexical_dev_esm_exports = {};
__export(Lexical_dev_esm_exports, {
  $addUpdateTag: () => $addUpdateTag,
  $applyNodeReplacement: () => $applyNodeReplacement,
  $copyNode: () => $copyNode,
  $createLineBreakNode: () => $createLineBreakNode,
  $createNodeSelection: () => $createNodeSelection,
  $createParagraphNode: () => $createParagraphNode,
  $createPoint: () => $createPoint,
  $createRangeSelection: () => $createRangeSelection,
  $createTabNode: () => $createTabNode,
  $createTextNode: () => $createTextNode,
  $getAdjacentNode: () => $getAdjacentNode,
  $getCharacterOffsets: () => $getCharacterOffsets,
  $getEditor: () => $getEditor,
  $getNearestNodeFromDOMNode: () => $getNearestNodeFromDOMNode,
  $getNearestRootOrShadowRoot: () => $getNearestRootOrShadowRoot,
  $getNodeByKey: () => $getNodeByKey,
  $getPreviousSelection: () => $getPreviousSelection,
  $getRoot: () => $getRoot,
  $getSelection: () => $getSelection,
  $getTextContent: () => $getTextContent,
  $hasAncestor: () => $hasAncestor,
  $hasUpdateTag: () => $hasUpdateTag,
  $insertNodes: () => $insertNodes,
  $isBlockElementNode: () => $isBlockElementNode,
  $isDecoratorNode: () => $isDecoratorNode,
  $isElementNode: () => $isElementNode,
  $isInlineElementOrDecoratorNode: () => $isInlineElementOrDecoratorNode,
  $isLeafNode: () => $isLeafNode,
  $isLineBreakNode: () => $isLineBreakNode,
  $isNodeSelection: () => $isNodeSelection,
  $isParagraphNode: () => $isParagraphNode,
  $isRangeSelection: () => $isRangeSelection,
  $isRootNode: () => $isRootNode,
  $isRootOrShadowRoot: () => $isRootOrShadowRoot,
  $isTabNode: () => $isTabNode,
  $isTextNode: () => $isTextNode,
  $nodesOfType: () => $nodesOfType,
  $normalizeSelection__EXPERIMENTAL: () => $normalizeSelection,
  $parseSerializedNode: () => $parseSerializedNode,
  $selectAll: () => $selectAll,
  $setCompositionKey: () => $setCompositionKey,
  $setSelection: () => $setSelection,
  $splitNode: () => $splitNode,
  BLUR_COMMAND: () => BLUR_COMMAND,
  CAN_REDO_COMMAND: () => CAN_REDO_COMMAND,
  CAN_UNDO_COMMAND: () => CAN_UNDO_COMMAND,
  CLEAR_EDITOR_COMMAND: () => CLEAR_EDITOR_COMMAND,
  CLEAR_HISTORY_COMMAND: () => CLEAR_HISTORY_COMMAND,
  CLICK_COMMAND: () => CLICK_COMMAND,
  COMMAND_PRIORITY_CRITICAL: () => COMMAND_PRIORITY_CRITICAL,
  COMMAND_PRIORITY_EDITOR: () => COMMAND_PRIORITY_EDITOR,
  COMMAND_PRIORITY_HIGH: () => COMMAND_PRIORITY_HIGH,
  COMMAND_PRIORITY_LOW: () => COMMAND_PRIORITY_LOW,
  COMMAND_PRIORITY_NORMAL: () => COMMAND_PRIORITY_NORMAL,
  CONTROLLED_TEXT_INSERTION_COMMAND: () => CONTROLLED_TEXT_INSERTION_COMMAND,
  COPY_COMMAND: () => COPY_COMMAND,
  CUT_COMMAND: () => CUT_COMMAND,
  DELETE_CHARACTER_COMMAND: () => DELETE_CHARACTER_COMMAND,
  DELETE_LINE_COMMAND: () => DELETE_LINE_COMMAND,
  DELETE_WORD_COMMAND: () => DELETE_WORD_COMMAND,
  DRAGEND_COMMAND: () => DRAGEND_COMMAND,
  DRAGOVER_COMMAND: () => DRAGOVER_COMMAND,
  DRAGSTART_COMMAND: () => DRAGSTART_COMMAND,
  DROP_COMMAND: () => DROP_COMMAND,
  DecoratorNode: () => DecoratorNode,
  ElementNode: () => ElementNode,
  FOCUS_COMMAND: () => FOCUS_COMMAND,
  FORMAT_ELEMENT_COMMAND: () => FORMAT_ELEMENT_COMMAND,
  FORMAT_TEXT_COMMAND: () => FORMAT_TEXT_COMMAND,
  INDENT_CONTENT_COMMAND: () => INDENT_CONTENT_COMMAND,
  INSERT_LINE_BREAK_COMMAND: () => INSERT_LINE_BREAK_COMMAND,
  INSERT_PARAGRAPH_COMMAND: () => INSERT_PARAGRAPH_COMMAND,
  INSERT_TAB_COMMAND: () => INSERT_TAB_COMMAND,
  KEY_ARROW_DOWN_COMMAND: () => KEY_ARROW_DOWN_COMMAND,
  KEY_ARROW_LEFT_COMMAND: () => KEY_ARROW_LEFT_COMMAND,
  KEY_ARROW_RIGHT_COMMAND: () => KEY_ARROW_RIGHT_COMMAND,
  KEY_ARROW_UP_COMMAND: () => KEY_ARROW_UP_COMMAND,
  KEY_BACKSPACE_COMMAND: () => KEY_BACKSPACE_COMMAND,
  KEY_DELETE_COMMAND: () => KEY_DELETE_COMMAND,
  KEY_DOWN_COMMAND: () => KEY_DOWN_COMMAND,
  KEY_ENTER_COMMAND: () => KEY_ENTER_COMMAND,
  KEY_ESCAPE_COMMAND: () => KEY_ESCAPE_COMMAND,
  KEY_MODIFIER_COMMAND: () => KEY_MODIFIER_COMMAND,
  KEY_SPACE_COMMAND: () => KEY_SPACE_COMMAND,
  KEY_TAB_COMMAND: () => KEY_TAB_COMMAND,
  LineBreakNode: () => LineBreakNode,
  MOVE_TO_END: () => MOVE_TO_END,
  MOVE_TO_START: () => MOVE_TO_START,
  OUTDENT_CONTENT_COMMAND: () => OUTDENT_CONTENT_COMMAND,
  PASTE_COMMAND: () => PASTE_COMMAND,
  ParagraphNode: () => ParagraphNode,
  REDO_COMMAND: () => REDO_COMMAND,
  REMOVE_TEXT_COMMAND: () => REMOVE_TEXT_COMMAND,
  RootNode: () => RootNode,
  SELECTION_CHANGE_COMMAND: () => SELECTION_CHANGE_COMMAND,
  SELECTION_INSERT_CLIPBOARD_NODES_COMMAND: () => SELECTION_INSERT_CLIPBOARD_NODES_COMMAND,
  SELECT_ALL_COMMAND: () => SELECT_ALL_COMMAND,
  TabNode: () => TabNode,
  TextNode: () => TextNode,
  UNDO_COMMAND: () => UNDO_COMMAND,
  createCommand: () => createCommand,
  createEditor: () => createEditor,
  getNearestEditorFromDOMNode: () => getNearestEditorFromDOMNode,
  isCurrentlyReadOnlyMode: () => isCurrentlyReadOnlyMode,
  isHTMLAnchorElement: () => isHTMLAnchorElement,
  isHTMLElement: () => isHTMLElement,
  isSelectionCapturedInDecoratorInput: () => isSelectionCapturedInDecoratorInput,
  isSelectionWithinEditor: () => isSelectionWithinEditor
});
function createCommand(type) {
  return {
    type
  };
}
var SELECTION_CHANGE_COMMAND = createCommand("SELECTION_CHANGE_COMMAND");
var SELECTION_INSERT_CLIPBOARD_NODES_COMMAND = createCommand("SELECTION_INSERT_CLIPBOARD_NODES_COMMAND");
var CLICK_COMMAND = createCommand("CLICK_COMMAND");
var DELETE_CHARACTER_COMMAND = createCommand("DELETE_CHARACTER_COMMAND");
var INSERT_LINE_BREAK_COMMAND = createCommand("INSERT_LINE_BREAK_COMMAND");
var INSERT_PARAGRAPH_COMMAND = createCommand("INSERT_PARAGRAPH_COMMAND");
var CONTROLLED_TEXT_INSERTION_COMMAND = createCommand("CONTROLLED_TEXT_INSERTION_COMMAND");
var PASTE_COMMAND = createCommand("PASTE_COMMAND");
var REMOVE_TEXT_COMMAND = createCommand("REMOVE_TEXT_COMMAND");
var DELETE_WORD_COMMAND = createCommand("DELETE_WORD_COMMAND");
var DELETE_LINE_COMMAND = createCommand("DELETE_LINE_COMMAND");
var FORMAT_TEXT_COMMAND = createCommand("FORMAT_TEXT_COMMAND");
var UNDO_COMMAND = createCommand("UNDO_COMMAND");
var REDO_COMMAND = createCommand("REDO_COMMAND");
var KEY_DOWN_COMMAND = createCommand("KEYDOWN_COMMAND");
var KEY_ARROW_RIGHT_COMMAND = createCommand("KEY_ARROW_RIGHT_COMMAND");
var MOVE_TO_END = createCommand("MOVE_TO_END");
var KEY_ARROW_LEFT_COMMAND = createCommand("KEY_ARROW_LEFT_COMMAND");
var MOVE_TO_START = createCommand("MOVE_TO_START");
var KEY_ARROW_UP_COMMAND = createCommand("KEY_ARROW_UP_COMMAND");
var KEY_ARROW_DOWN_COMMAND = createCommand("KEY_ARROW_DOWN_COMMAND");
var KEY_ENTER_COMMAND = createCommand("KEY_ENTER_COMMAND");
var KEY_SPACE_COMMAND = createCommand("KEY_SPACE_COMMAND");
var KEY_BACKSPACE_COMMAND = createCommand("KEY_BACKSPACE_COMMAND");
var KEY_ESCAPE_COMMAND = createCommand("KEY_ESCAPE_COMMAND");
var KEY_DELETE_COMMAND = createCommand("KEY_DELETE_COMMAND");
var KEY_TAB_COMMAND = createCommand("KEY_TAB_COMMAND");
var INSERT_TAB_COMMAND = createCommand("INSERT_TAB_COMMAND");
var INDENT_CONTENT_COMMAND = createCommand("INDENT_CONTENT_COMMAND");
var OUTDENT_CONTENT_COMMAND = createCommand("OUTDENT_CONTENT_COMMAND");
var DROP_COMMAND = createCommand("DROP_COMMAND");
var FORMAT_ELEMENT_COMMAND = createCommand("FORMAT_ELEMENT_COMMAND");
var DRAGSTART_COMMAND = createCommand("DRAGSTART_COMMAND");
var DRAGOVER_COMMAND = createCommand("DRAGOVER_COMMAND");
var DRAGEND_COMMAND = createCommand("DRAGEND_COMMAND");
var COPY_COMMAND = createCommand("COPY_COMMAND");
var CUT_COMMAND = createCommand("CUT_COMMAND");
var SELECT_ALL_COMMAND = createCommand("SELECT_ALL_COMMAND");
var CLEAR_EDITOR_COMMAND = createCommand("CLEAR_EDITOR_COMMAND");
var CLEAR_HISTORY_COMMAND = createCommand("CLEAR_HISTORY_COMMAND");
var CAN_REDO_COMMAND = createCommand("CAN_REDO_COMMAND");
var CAN_UNDO_COMMAND = createCommand("CAN_UNDO_COMMAND");
var FOCUS_COMMAND = createCommand("FOCUS_COMMAND");
var BLUR_COMMAND = createCommand("BLUR_COMMAND");
var KEY_MODIFIER_COMMAND = createCommand("KEY_MODIFIER_COMMAND");
var CAN_USE_DOM = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
var documentMode = CAN_USE_DOM && "documentMode" in document ? document.documentMode : null;
var IS_APPLE = CAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);
var IS_FIREFOX = CAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
var CAN_USE_BEFORE_INPUT = CAN_USE_DOM && "InputEvent" in window && !documentMode ? "getTargetRanges" in new window.InputEvent("input") : false;
var IS_SAFARI = CAN_USE_DOM && /Version\/[\d.]+.*Safari/.test(navigator.userAgent);
var IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
var IS_ANDROID = CAN_USE_DOM && /Android/.test(navigator.userAgent);
var IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);
var IS_ANDROID_CHROME = CAN_USE_DOM && IS_ANDROID && IS_CHROME;
var IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !IS_CHROME;
var DOM_ELEMENT_TYPE = 1;
var DOM_TEXT_TYPE = 3;
var NO_DIRTY_NODES = 0;
var HAS_DIRTY_NODES = 1;
var FULL_RECONCILE = 2;
var IS_NORMAL = 0;
var IS_TOKEN = 1;
var IS_SEGMENTED = 2;
var IS_BOLD = 1;
var IS_ITALIC = 1 << 1;
var IS_STRIKETHROUGH = 1 << 2;
var IS_UNDERLINE = 1 << 3;
var IS_CODE = 1 << 4;
var IS_SUBSCRIPT = 1 << 5;
var IS_SUPERSCRIPT = 1 << 6;
var IS_HIGHLIGHT = 1 << 7;
var IS_ALL_FORMATTING = IS_BOLD | IS_ITALIC | IS_STRIKETHROUGH | IS_UNDERLINE | IS_CODE | IS_SUBSCRIPT | IS_SUPERSCRIPT | IS_HIGHLIGHT;
var IS_DIRECTIONLESS = 1;
var IS_UNMERGEABLE = 1 << 1;
var IS_ALIGN_LEFT = 1;
var IS_ALIGN_CENTER = 2;
var IS_ALIGN_RIGHT = 3;
var IS_ALIGN_JUSTIFY = 4;
var IS_ALIGN_START = 5;
var IS_ALIGN_END = 6;
var NON_BREAKING_SPACE = " ";
var ZERO_WIDTH_SPACE = "​";
var COMPOSITION_SUFFIX = IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT ? NON_BREAKING_SPACE : ZERO_WIDTH_SPACE;
var DOUBLE_LINE_BREAK = "\n\n";
var COMPOSITION_START_CHAR = IS_FIREFOX ? NON_BREAKING_SPACE : COMPOSITION_SUFFIX;
var RTL = "֑-߿יִ-﷽ﹰ-ﻼ";
var LTR = "A-Za-zÀ-ÖØ-öø-ʸ̀-֐ࠀ-῿‎Ⰰ-﬜︀-﹯﻽-￿";
var RTL_REGEX = new RegExp("^[^" + LTR + "]*[" + RTL + "]");
var LTR_REGEX = new RegExp("^[^" + RTL + "]*[" + LTR + "]");
var TEXT_TYPE_TO_FORMAT = {
  bold: IS_BOLD,
  code: IS_CODE,
  highlight: IS_HIGHLIGHT,
  italic: IS_ITALIC,
  strikethrough: IS_STRIKETHROUGH,
  subscript: IS_SUBSCRIPT,
  superscript: IS_SUPERSCRIPT,
  underline: IS_UNDERLINE
};
var DETAIL_TYPE_TO_DETAIL = {
  directionless: IS_DIRECTIONLESS,
  unmergeable: IS_UNMERGEABLE
};
var ELEMENT_TYPE_TO_FORMAT = {
  center: IS_ALIGN_CENTER,
  end: IS_ALIGN_END,
  justify: IS_ALIGN_JUSTIFY,
  left: IS_ALIGN_LEFT,
  right: IS_ALIGN_RIGHT,
  start: IS_ALIGN_START
};
var ELEMENT_FORMAT_TO_TYPE = {
  [IS_ALIGN_CENTER]: "center",
  [IS_ALIGN_END]: "end",
  [IS_ALIGN_JUSTIFY]: "justify",
  [IS_ALIGN_LEFT]: "left",
  [IS_ALIGN_RIGHT]: "right",
  [IS_ALIGN_START]: "start"
};
var TEXT_MODE_TO_TYPE = {
  normal: IS_NORMAL,
  segmented: IS_SEGMENTED,
  token: IS_TOKEN
};
var TEXT_TYPE_TO_MODE = {
  [IS_NORMAL]: "normal",
  [IS_SEGMENTED]: "segmented",
  [IS_TOKEN]: "token"
};
function normalizeClassNames(...classNames) {
  const rval = [];
  for (const className of classNames) {
    if (className && typeof className === "string") {
      for (const [s2] of className.matchAll(/\S+/g)) {
        rval.push(s2);
      }
    }
  }
  return rval;
}
var TEXT_MUTATION_VARIANCE = 100;
var isProcessingMutations = false;
var lastTextEntryTimeStamp = 0;
function getIsProcessingMutations() {
  return isProcessingMutations;
}
function updateTimeStamp(event) {
  lastTextEntryTimeStamp = event.timeStamp;
}
function initTextEntryListener(editor) {
  if (lastTextEntryTimeStamp === 0) {
    getWindow(editor).addEventListener("textInput", updateTimeStamp, true);
  }
}
function isManagedLineBreak(dom, target, editor) {
  return (
    // @ts-expect-error: internal field
    target.__lexicalLineBreak === dom || // @ts-ignore We intentionally add this to the Node.
    dom[`__lexicalKey_${editor._key}`] !== void 0
  );
}
function getLastSelection(editor) {
  return editor.getEditorState().read(() => {
    const selection = $getSelection();
    return selection !== null ? selection.clone() : null;
  });
}
function handleTextMutation(target, node, editor) {
  const domSelection = getDOMSelection(editor._window);
  let anchorOffset = null;
  let focusOffset = null;
  if (domSelection !== null && domSelection.anchorNode === target) {
    anchorOffset = domSelection.anchorOffset;
    focusOffset = domSelection.focusOffset;
  }
  const text = target.nodeValue;
  if (text !== null) {
    $updateTextNodeFromDOMContent(node, text, anchorOffset, focusOffset, false);
  }
}
function shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode) {
  if ($isRangeSelection(selection)) {
    const anchorNode = selection.anchor.getNode();
    if (anchorNode.is(targetNode) && selection.format !== anchorNode.getFormat()) {
      return false;
    }
  }
  return targetDOM.nodeType === DOM_TEXT_TYPE && targetNode.isAttached();
}
function $flushMutations$1(editor, mutations, observer) {
  isProcessingMutations = true;
  const shouldFlushTextMutations = performance.now() - lastTextEntryTimeStamp > TEXT_MUTATION_VARIANCE;
  try {
    updateEditor(editor, () => {
      const selection = $getSelection() || getLastSelection(editor);
      const badDOMTargets = /* @__PURE__ */ new Map();
      const rootElement = editor.getRootElement();
      const currentEditorState = editor._editorState;
      const blockCursorElement = editor._blockCursorElement;
      let shouldRevertSelection = false;
      let possibleTextForFirefoxPaste = "";
      for (let i2 = 0; i2 < mutations.length; i2++) {
        const mutation = mutations[i2];
        const type = mutation.type;
        const targetDOM = mutation.target;
        let targetNode = $getNearestNodeFromDOMNode(targetDOM, currentEditorState);
        if (targetNode === null && targetDOM !== rootElement || $isDecoratorNode(targetNode)) {
          continue;
        }
        if (type === "characterData") {
          if (shouldFlushTextMutations && $isTextNode(targetNode) && shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode)) {
            handleTextMutation(
              // nodeType === DOM_TEXT_TYPE is a Text DOM node
              targetDOM,
              targetNode,
              editor
            );
          }
        } else if (type === "childList") {
          shouldRevertSelection = true;
          const addedDOMs = mutation.addedNodes;
          for (let s2 = 0; s2 < addedDOMs.length; s2++) {
            const addedDOM = addedDOMs[s2];
            const node = getNodeFromDOMNode(addedDOM);
            const parentDOM = addedDOM.parentNode;
            if (parentDOM != null && addedDOM !== blockCursorElement && node === null && (addedDOM.nodeName !== "BR" || !isManagedLineBreak(addedDOM, parentDOM, editor))) {
              if (IS_FIREFOX) {
                const possibleText = addedDOM.innerText || addedDOM.nodeValue;
                if (possibleText) {
                  possibleTextForFirefoxPaste += possibleText;
                }
              }
              parentDOM.removeChild(addedDOM);
            }
          }
          const removedDOMs = mutation.removedNodes;
          const removedDOMsLength = removedDOMs.length;
          if (removedDOMsLength > 0) {
            let unremovedBRs = 0;
            for (let s2 = 0; s2 < removedDOMsLength; s2++) {
              const removedDOM = removedDOMs[s2];
              if (removedDOM.nodeName === "BR" && isManagedLineBreak(removedDOM, targetDOM, editor) || blockCursorElement === removedDOM) {
                targetDOM.appendChild(removedDOM);
                unremovedBRs++;
              }
            }
            if (removedDOMsLength !== unremovedBRs) {
              if (targetDOM === rootElement) {
                targetNode = internalGetRoot(currentEditorState);
              }
              badDOMTargets.set(targetDOM, targetNode);
            }
          }
        }
      }
      if (badDOMTargets.size > 0) {
        for (const [targetDOM, targetNode] of badDOMTargets) {
          if ($isElementNode(targetNode)) {
            const childKeys = targetNode.getChildrenKeys();
            let currentDOM = targetDOM.firstChild;
            for (let s2 = 0; s2 < childKeys.length; s2++) {
              const key = childKeys[s2];
              const correctDOM = editor.getElementByKey(key);
              if (correctDOM === null) {
                continue;
              }
              if (currentDOM == null) {
                targetDOM.appendChild(correctDOM);
                currentDOM = correctDOM;
              } else if (currentDOM !== correctDOM) {
                targetDOM.replaceChild(correctDOM, currentDOM);
              }
              currentDOM = currentDOM.nextSibling;
            }
          } else if ($isTextNode(targetNode)) {
            targetNode.markDirty();
          }
        }
      }
      const records = observer.takeRecords();
      if (records.length > 0) {
        for (let i2 = 0; i2 < records.length; i2++) {
          const record = records[i2];
          const addedNodes = record.addedNodes;
          const target = record.target;
          for (let s2 = 0; s2 < addedNodes.length; s2++) {
            const addedDOM = addedNodes[s2];
            const parentDOM = addedDOM.parentNode;
            if (parentDOM != null && addedDOM.nodeName === "BR" && !isManagedLineBreak(addedDOM, target, editor)) {
              parentDOM.removeChild(addedDOM);
            }
          }
        }
        observer.takeRecords();
      }
      if (selection !== null) {
        if (shouldRevertSelection) {
          selection.dirty = true;
          $setSelection(selection);
        }
        if (IS_FIREFOX && isFirefoxClipboardEvents(editor)) {
          selection.insertRawText(possibleTextForFirefoxPaste);
        }
      }
    });
  } finally {
    isProcessingMutations = false;
  }
}
function flushRootMutations(editor) {
  const observer = editor._observer;
  if (observer !== null) {
    const mutations = observer.takeRecords();
    $flushMutations$1(editor, mutations, observer);
  }
}
function initMutationObserver(editor) {
  initTextEntryListener(editor);
  editor._observer = new MutationObserver((mutations, observer) => {
    $flushMutations$1(editor, mutations, observer);
  });
}
function $canSimpleTextNodesBeMerged(node1, node2) {
  const node1Mode = node1.__mode;
  const node1Format = node1.__format;
  const node1Style = node1.__style;
  const node2Mode = node2.__mode;
  const node2Format = node2.__format;
  const node2Style = node2.__style;
  return (node1Mode === null || node1Mode === node2Mode) && (node1Format === null || node1Format === node2Format) && (node1Style === null || node1Style === node2Style);
}
function $mergeTextNodes(node1, node2) {
  const writableNode1 = node1.mergeWithSibling(node2);
  const normalizedNodes = getActiveEditor()._normalizedNodes;
  normalizedNodes.add(node1.__key);
  normalizedNodes.add(node2.__key);
  return writableNode1;
}
function $normalizeTextNode(textNode) {
  let node = textNode;
  if (node.__text === "" && node.isSimpleText() && !node.isUnmergeable()) {
    node.remove();
    return;
  }
  let previousNode;
  while ((previousNode = node.getPreviousSibling()) !== null && $isTextNode(previousNode) && previousNode.isSimpleText() && !previousNode.isUnmergeable()) {
    if (previousNode.__text === "") {
      previousNode.remove();
    } else if ($canSimpleTextNodesBeMerged(previousNode, node)) {
      node = $mergeTextNodes(previousNode, node);
      break;
    } else {
      break;
    }
  }
  let nextNode;
  while ((nextNode = node.getNextSibling()) !== null && $isTextNode(nextNode) && nextNode.isSimpleText() && !nextNode.isUnmergeable()) {
    if (nextNode.__text === "") {
      nextNode.remove();
    } else if ($canSimpleTextNodesBeMerged(node, nextNode)) {
      node = $mergeTextNodes(node, nextNode);
      break;
    } else {
      break;
    }
  }
}
function $normalizeSelection(selection) {
  $normalizePoint(selection.anchor);
  $normalizePoint(selection.focus);
  return selection;
}
function $normalizePoint(point) {
  while (point.type === "element") {
    const node = point.getNode();
    const offset = point.offset;
    let nextNode;
    let nextOffsetAtEnd;
    if (offset === node.getChildrenSize()) {
      nextNode = node.getChildAtIndex(offset - 1);
      nextOffsetAtEnd = true;
    } else {
      nextNode = node.getChildAtIndex(offset);
      nextOffsetAtEnd = false;
    }
    if ($isTextNode(nextNode)) {
      point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getTextContentSize() : 0, "text");
      break;
    } else if (!$isElementNode(nextNode)) {
      break;
    }
    point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getChildrenSize() : 0, "element");
  }
}
var keyCounter = 1;
function generateRandomKey() {
  return "" + keyCounter++;
}
function getRegisteredNodeOrThrow(editor, nodeType) {
  const registeredNode = editor._nodes.get(nodeType);
  if (registeredNode === void 0) {
    {
      throw Error(`registeredNode: Type ${nodeType} not found`);
    }
  }
  return registeredNode;
}
var scheduleMicroTask = typeof queueMicrotask === "function" ? queueMicrotask : (fn2) => {
  Promise.resolve().then(fn2);
};
function $isSelectionCapturedInDecorator(node) {
  return $isDecoratorNode($getNearestNodeFromDOMNode(node));
}
function isSelectionCapturedInDecoratorInput(anchorDOM) {
  const activeElement = document.activeElement;
  if (activeElement === null) {
    return false;
  }
  const nodeName = activeElement.nodeName;
  return $isDecoratorNode($getNearestNodeFromDOMNode(anchorDOM)) && (nodeName === "INPUT" || nodeName === "TEXTAREA" || activeElement.contentEditable === "true" && // @ts-ignore iternal field
  activeElement.__lexicalEditor == null);
}
function isSelectionWithinEditor(editor, anchorDOM, focusDOM) {
  const rootElement = editor.getRootElement();
  try {
    return rootElement !== null && rootElement.contains(anchorDOM) && rootElement.contains(focusDOM) && // Ignore if selection is within nested editor
    anchorDOM !== null && !isSelectionCapturedInDecoratorInput(anchorDOM) && getNearestEditorFromDOMNode(anchorDOM) === editor;
  } catch (error) {
    return false;
  }
}
function getNearestEditorFromDOMNode(node) {
  let currentNode = node;
  while (currentNode != null) {
    const editor = currentNode.__lexicalEditor;
    if (editor != null) {
      return editor;
    }
    currentNode = getParentElement(currentNode);
  }
  return null;
}
function getTextDirection(text) {
  if (RTL_REGEX.test(text)) {
    return "rtl";
  }
  if (LTR_REGEX.test(text)) {
    return "ltr";
  }
  return null;
}
function $isTokenOrSegmented(node) {
  return node.isToken() || node.isSegmented();
}
function isDOMNodeLexicalTextNode(node) {
  return node.nodeType === DOM_TEXT_TYPE;
}
function getDOMTextNode(element) {
  let node = element;
  while (node != null) {
    if (isDOMNodeLexicalTextNode(node)) {
      return node;
    }
    node = node.firstChild;
  }
  return null;
}
function toggleTextFormatType(format, type, alignWithFormat) {
  const activeFormat = TEXT_TYPE_TO_FORMAT[type];
  if (alignWithFormat !== null && (format & activeFormat) === (alignWithFormat & activeFormat)) {
    return format;
  }
  let newFormat = format ^ activeFormat;
  if (type === "subscript") {
    newFormat &= ~TEXT_TYPE_TO_FORMAT.superscript;
  } else if (type === "superscript") {
    newFormat &= ~TEXT_TYPE_TO_FORMAT.subscript;
  }
  return newFormat;
}
function $isLeafNode(node) {
  return $isTextNode(node) || $isLineBreakNode(node) || $isDecoratorNode(node);
}
function $setNodeKey(node, existingKey) {
  if (existingKey != null) {
    node.__key = existingKey;
    return;
  }
  errorOnReadOnly();
  errorOnInfiniteTransforms();
  const editor = getActiveEditor();
  const editorState = getActiveEditorState();
  const key = generateRandomKey();
  editorState._nodeMap.set(key, node);
  if ($isElementNode(node)) {
    editor._dirtyElements.set(key, true);
  } else {
    editor._dirtyLeaves.add(key);
  }
  editor._cloneNotNeeded.add(key);
  editor._dirtyType = HAS_DIRTY_NODES;
  node.__key = key;
}
function internalMarkParentElementsAsDirty(parentKey, nodeMap, dirtyElements) {
  let nextParentKey = parentKey;
  while (nextParentKey !== null) {
    if (dirtyElements.has(nextParentKey)) {
      return;
    }
    const node = nodeMap.get(nextParentKey);
    if (node === void 0) {
      break;
    }
    dirtyElements.set(nextParentKey, false);
    nextParentKey = node.__parent;
  }
}
function removeFromParent(node) {
  const oldParent = node.getParent();
  if (oldParent !== null) {
    const writableNode = node.getWritable();
    const writableParent = oldParent.getWritable();
    const prevSibling = node.getPreviousSibling();
    const nextSibling = node.getNextSibling();
    if (prevSibling === null) {
      if (nextSibling !== null) {
        const writableNextSibling = nextSibling.getWritable();
        writableParent.__first = nextSibling.__key;
        writableNextSibling.__prev = null;
      } else {
        writableParent.__first = null;
      }
    } else {
      const writablePrevSibling = prevSibling.getWritable();
      if (nextSibling !== null) {
        const writableNextSibling = nextSibling.getWritable();
        writableNextSibling.__prev = writablePrevSibling.__key;
        writablePrevSibling.__next = writableNextSibling.__key;
      } else {
        writablePrevSibling.__next = null;
      }
      writableNode.__prev = null;
    }
    if (nextSibling === null) {
      if (prevSibling !== null) {
        const writablePrevSibling = prevSibling.getWritable();
        writableParent.__last = prevSibling.__key;
        writablePrevSibling.__next = null;
      } else {
        writableParent.__last = null;
      }
    } else {
      const writableNextSibling = nextSibling.getWritable();
      if (prevSibling !== null) {
        const writablePrevSibling = prevSibling.getWritable();
        writablePrevSibling.__next = writableNextSibling.__key;
        writableNextSibling.__prev = writablePrevSibling.__key;
      } else {
        writableNextSibling.__prev = null;
      }
      writableNode.__next = null;
    }
    writableParent.__size--;
    writableNode.__parent = null;
  }
}
function internalMarkNodeAsDirty(node) {
  errorOnInfiniteTransforms();
  const latest = node.getLatest();
  const parent = latest.__parent;
  const editorState = getActiveEditorState();
  const editor = getActiveEditor();
  const nodeMap = editorState._nodeMap;
  const dirtyElements = editor._dirtyElements;
  if (parent !== null) {
    internalMarkParentElementsAsDirty(parent, nodeMap, dirtyElements);
  }
  const key = latest.__key;
  editor._dirtyType = HAS_DIRTY_NODES;
  if ($isElementNode(node)) {
    dirtyElements.set(key, true);
  } else {
    editor._dirtyLeaves.add(key);
  }
}
function internalMarkSiblingsAsDirty(node) {
  const previousNode = node.getPreviousSibling();
  const nextNode = node.getNextSibling();
  if (previousNode !== null) {
    internalMarkNodeAsDirty(previousNode);
  }
  if (nextNode !== null) {
    internalMarkNodeAsDirty(nextNode);
  }
}
function $setCompositionKey(compositionKey) {
  errorOnReadOnly();
  const editor = getActiveEditor();
  const previousCompositionKey = editor._compositionKey;
  if (compositionKey !== previousCompositionKey) {
    editor._compositionKey = compositionKey;
    if (previousCompositionKey !== null) {
      const node = $getNodeByKey(previousCompositionKey);
      if (node !== null) {
        node.getWritable();
      }
    }
    if (compositionKey !== null) {
      const node = $getNodeByKey(compositionKey);
      if (node !== null) {
        node.getWritable();
      }
    }
  }
}
function $getCompositionKey() {
  if (isCurrentlyReadOnlyMode()) {
    return null;
  }
  const editor = getActiveEditor();
  return editor._compositionKey;
}
function $getNodeByKey(key, _editorState) {
  const editorState = _editorState || getActiveEditorState();
  const node = editorState._nodeMap.get(key);
  if (node === void 0) {
    return null;
  }
  return node;
}
function getNodeFromDOMNode(dom, editorState) {
  const editor = getActiveEditor();
  const key = dom[`__lexicalKey_${editor._key}`];
  if (key !== void 0) {
    return $getNodeByKey(key, editorState);
  }
  return null;
}
function $getNearestNodeFromDOMNode(startingDOM, editorState) {
  let dom = startingDOM;
  while (dom != null) {
    const node = getNodeFromDOMNode(dom, editorState);
    if (node !== null) {
      return node;
    }
    dom = getParentElement(dom);
  }
  return null;
}
function cloneDecorators(editor) {
  const currentDecorators = editor._decorators;
  const pendingDecorators = Object.assign({}, currentDecorators);
  editor._pendingDecorators = pendingDecorators;
  return pendingDecorators;
}
function getEditorStateTextContent(editorState) {
  return editorState.read(() => $getRoot().getTextContent());
}
function markAllNodesAsDirty(editor, type) {
  updateEditor(editor, () => {
    const editorState = getActiveEditorState();
    if (editorState.isEmpty()) {
      return;
    }
    if (type === "root") {
      $getRoot().markDirty();
      return;
    }
    const nodeMap = editorState._nodeMap;
    for (const [, node] of nodeMap) {
      node.markDirty();
    }
  }, editor._pendingEditorState === null ? {
    tag: "history-merge"
  } : void 0);
}
function $getRoot() {
  return internalGetRoot(getActiveEditorState());
}
function internalGetRoot(editorState) {
  return editorState._nodeMap.get("root");
}
function $setSelection(selection) {
  errorOnReadOnly();
  const editorState = getActiveEditorState();
  if (selection !== null) {
    {
      if (Object.isFrozen(selection)) {
        {
          throw Error(`$setSelection called on frozen selection object. Ensure selection is cloned before passing in.`);
        }
      }
    }
    selection.dirty = true;
    selection.setCachedNodes(null);
  }
  editorState._selection = selection;
}
function $flushMutations() {
  errorOnReadOnly();
  const editor = getActiveEditor();
  flushRootMutations(editor);
}
function getNodeFromDOM(dom) {
  const editor = getActiveEditor();
  const nodeKey = getNodeKeyFromDOM(dom, editor);
  if (nodeKey === null) {
    const rootElement = editor.getRootElement();
    if (dom === rootElement) {
      return $getNodeByKey("root");
    }
    return null;
  }
  return $getNodeByKey(nodeKey);
}
function getTextNodeOffset(node, moveSelectionToEnd) {
  return moveSelectionToEnd ? node.getTextContentSize() : 0;
}
function getNodeKeyFromDOM(dom, editor) {
  let node = dom;
  while (node != null) {
    const key = node[`__lexicalKey_${editor._key}`];
    if (key !== void 0) {
      return key;
    }
    node = getParentElement(node);
  }
  return null;
}
function doesContainGrapheme(str) {
  return /[\uD800-\uDBFF][\uDC00-\uDFFF]/g.test(str);
}
function getEditorsToPropagate(editor) {
  const editorsToPropagate = [];
  let currentEditor = editor;
  while (currentEditor !== null) {
    editorsToPropagate.push(currentEditor);
    currentEditor = currentEditor._parentEditor;
  }
  return editorsToPropagate;
}
function createUID() {
  return Math.random().toString(36).replace(/[^a-z]+/g, "").substr(0, 5);
}
function getAnchorTextFromDOM(anchorNode) {
  if (anchorNode.nodeType === DOM_TEXT_TYPE) {
    return anchorNode.nodeValue;
  }
  return null;
}
function $updateSelectedTextFromDOM(isCompositionEnd, editor, data) {
  const domSelection = getDOMSelection(editor._window);
  if (domSelection === null) {
    return;
  }
  const anchorNode = domSelection.anchorNode;
  let {
    anchorOffset,
    focusOffset
  } = domSelection;
  if (anchorNode !== null) {
    let textContent = getAnchorTextFromDOM(anchorNode);
    const node = $getNearestNodeFromDOMNode(anchorNode);
    if (textContent !== null && $isTextNode(node)) {
      if (textContent === COMPOSITION_SUFFIX && data) {
        const offset = data.length;
        textContent = data;
        anchorOffset = offset;
        focusOffset = offset;
      }
      if (textContent !== null) {
        $updateTextNodeFromDOMContent(node, textContent, anchorOffset, focusOffset, isCompositionEnd);
      }
    }
  }
}
function $updateTextNodeFromDOMContent(textNode, textContent, anchorOffset, focusOffset, compositionEnd) {
  let node = textNode;
  if (node.isAttached() && (compositionEnd || !node.isDirty())) {
    const isComposing = node.isComposing();
    let normalizedTextContent = textContent;
    if ((isComposing || compositionEnd) && textContent[textContent.length - 1] === COMPOSITION_SUFFIX) {
      normalizedTextContent = textContent.slice(0, -1);
    }
    const prevTextContent = node.getTextContent();
    if (compositionEnd || normalizedTextContent !== prevTextContent) {
      if (normalizedTextContent === "") {
        $setCompositionKey(null);
        if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT) {
          const editor = getActiveEditor();
          setTimeout(() => {
            editor.update(() => {
              if (node.isAttached()) {
                node.remove();
              }
            });
          }, 20);
        } else {
          node.remove();
        }
        return;
      }
      const parent = node.getParent();
      const prevSelection = $getPreviousSelection();
      const prevTextContentSize = node.getTextContentSize();
      const compositionKey = $getCompositionKey();
      const nodeKey = node.getKey();
      if (node.isToken() || compositionKey !== null && nodeKey === compositionKey && !isComposing || // Check if character was added at the start or boundaries when not insertable, and we need
      // to clear this input from occurring as that action wasn't permitted.
      $isRangeSelection(prevSelection) && (parent !== null && !parent.canInsertTextBefore() && prevSelection.anchor.offset === 0 || prevSelection.anchor.key === textNode.__key && prevSelection.anchor.offset === 0 && !node.canInsertTextBefore() && !isComposing || prevSelection.focus.key === textNode.__key && prevSelection.focus.offset === prevTextContentSize && !node.canInsertTextAfter() && !isComposing)) {
        node.markDirty();
        return;
      }
      const selection = $getSelection();
      if (!$isRangeSelection(selection) || anchorOffset === null || focusOffset === null) {
        node.setTextContent(normalizedTextContent);
        return;
      }
      selection.setTextNodeRange(node, anchorOffset, node, focusOffset);
      if (node.isSegmented()) {
        const originalTextContent = node.getTextContent();
        const replacement = $createTextNode(originalTextContent);
        node.replace(replacement);
        node = replacement;
      }
      node.setTextContent(normalizedTextContent);
    }
  }
}
function $previousSiblingDoesNotAcceptText(node) {
  const previousSibling = node.getPreviousSibling();
  return ($isTextNode(previousSibling) || $isElementNode(previousSibling) && previousSibling.isInline()) && !previousSibling.canInsertTextAfter();
}
function $shouldInsertTextAfterOrBeforeTextNode(selection, node) {
  if (node.isSegmented()) {
    return true;
  }
  if (!selection.isCollapsed()) {
    return false;
  }
  const offset = selection.anchor.offset;
  const parent = node.getParentOrThrow();
  const isToken = node.isToken();
  if (offset === 0) {
    return !node.canInsertTextBefore() || !parent.canInsertTextBefore() || isToken || $previousSiblingDoesNotAcceptText(node);
  } else if (offset === node.getTextContentSize()) {
    return !node.canInsertTextAfter() || !parent.canInsertTextAfter() || isToken;
  } else {
    return false;
  }
}
function isTab(keyCode, altKey, ctrlKey, metaKey) {
  return keyCode === 9 && !altKey && !ctrlKey && !metaKey;
}
function isBold(keyCode, altKey, metaKey, ctrlKey) {
  return keyCode === 66 && !altKey && controlOrMeta(metaKey, ctrlKey);
}
function isItalic(keyCode, altKey, metaKey, ctrlKey) {
  return keyCode === 73 && !altKey && controlOrMeta(metaKey, ctrlKey);
}
function isUnderline(keyCode, altKey, metaKey, ctrlKey) {
  return keyCode === 85 && !altKey && controlOrMeta(metaKey, ctrlKey);
}
function isParagraph(keyCode, shiftKey) {
  return isReturn(keyCode) && !shiftKey;
}
function isLineBreak(keyCode, shiftKey) {
  return isReturn(keyCode) && shiftKey;
}
function isOpenLineBreak(keyCode, ctrlKey) {
  return IS_APPLE && ctrlKey && keyCode === 79;
}
function isDeleteWordBackward(keyCode, altKey, ctrlKey) {
  return isBackspace(keyCode) && (IS_APPLE ? altKey : ctrlKey);
}
function isDeleteWordForward(keyCode, altKey, ctrlKey) {
  return isDelete(keyCode) && (IS_APPLE ? altKey : ctrlKey);
}
function isDeleteLineBackward(keyCode, metaKey) {
  return IS_APPLE && metaKey && isBackspace(keyCode);
}
function isDeleteLineForward(keyCode, metaKey) {
  return IS_APPLE && metaKey && isDelete(keyCode);
}
function isDeleteBackward(keyCode, altKey, metaKey, ctrlKey) {
  if (IS_APPLE) {
    if (altKey || metaKey) {
      return false;
    }
    return isBackspace(keyCode) || keyCode === 72 && ctrlKey;
  }
  if (ctrlKey || altKey || metaKey) {
    return false;
  }
  return isBackspace(keyCode);
}
function isDeleteForward(keyCode, ctrlKey, shiftKey, altKey, metaKey) {
  if (IS_APPLE) {
    if (shiftKey || altKey || metaKey) {
      return false;
    }
    return isDelete(keyCode) || keyCode === 68 && ctrlKey;
  }
  if (ctrlKey || altKey || metaKey) {
    return false;
  }
  return isDelete(keyCode);
}
function isUndo(keyCode, shiftKey, metaKey, ctrlKey) {
  return keyCode === 90 && !shiftKey && controlOrMeta(metaKey, ctrlKey);
}
function isRedo(keyCode, shiftKey, metaKey, ctrlKey) {
  if (IS_APPLE) {
    return keyCode === 90 && metaKey && shiftKey;
  }
  return keyCode === 89 && ctrlKey || keyCode === 90 && ctrlKey && shiftKey;
}
function isCopy(keyCode, shiftKey, metaKey, ctrlKey) {
  if (shiftKey) {
    return false;
  }
  if (keyCode === 67) {
    return IS_APPLE ? metaKey : ctrlKey;
  }
  return false;
}
function isCut(keyCode, shiftKey, metaKey, ctrlKey) {
  if (shiftKey) {
    return false;
  }
  if (keyCode === 88) {
    return IS_APPLE ? metaKey : ctrlKey;
  }
  return false;
}
function isArrowLeft(keyCode) {
  return keyCode === 37;
}
function isArrowRight(keyCode) {
  return keyCode === 39;
}
function isArrowUp(keyCode) {
  return keyCode === 38;
}
function isArrowDown(keyCode) {
  return keyCode === 40;
}
function isMoveBackward(keyCode, ctrlKey, altKey, metaKey) {
  return isArrowLeft(keyCode) && !ctrlKey && !metaKey && !altKey;
}
function isMoveToStart(keyCode, ctrlKey, shiftKey, altKey, metaKey) {
  return isArrowLeft(keyCode) && !altKey && !shiftKey && (ctrlKey || metaKey);
}
function isMoveForward(keyCode, ctrlKey, altKey, metaKey) {
  return isArrowRight(keyCode) && !ctrlKey && !metaKey && !altKey;
}
function isMoveToEnd(keyCode, ctrlKey, shiftKey, altKey, metaKey) {
  return isArrowRight(keyCode) && !altKey && !shiftKey && (ctrlKey || metaKey);
}
function isMoveUp(keyCode, ctrlKey, metaKey) {
  return isArrowUp(keyCode) && !ctrlKey && !metaKey;
}
function isMoveDown(keyCode, ctrlKey, metaKey) {
  return isArrowDown(keyCode) && !ctrlKey && !metaKey;
}
function isModifier(ctrlKey, shiftKey, altKey, metaKey) {
  return ctrlKey || shiftKey || altKey || metaKey;
}
function isSpace(keyCode) {
  return keyCode === 32;
}
function controlOrMeta(metaKey, ctrlKey) {
  if (IS_APPLE) {
    return metaKey;
  }
  return ctrlKey;
}
function isReturn(keyCode) {
  return keyCode === 13;
}
function isBackspace(keyCode) {
  return keyCode === 8;
}
function isEscape(keyCode) {
  return keyCode === 27;
}
function isDelete(keyCode) {
  return keyCode === 46;
}
function isSelectAll(keyCode, metaKey, ctrlKey) {
  return keyCode === 65 && controlOrMeta(metaKey, ctrlKey);
}
function $selectAll() {
  const root = $getRoot();
  const selection = root.select(0, root.getChildrenSize());
  $setSelection($normalizeSelection(selection));
}
function getCachedClassNameArray(classNamesTheme, classNameThemeType) {
  if (classNamesTheme.__lexicalClassNameCache === void 0) {
    classNamesTheme.__lexicalClassNameCache = {};
  }
  const classNamesCache = classNamesTheme.__lexicalClassNameCache;
  const cachedClassNames = classNamesCache[classNameThemeType];
  if (cachedClassNames !== void 0) {
    return cachedClassNames;
  }
  const classNames = classNamesTheme[classNameThemeType];
  if (typeof classNames === "string") {
    const classNamesArr = normalizeClassNames(classNames);
    classNamesCache[classNameThemeType] = classNamesArr;
    return classNamesArr;
  }
  return classNames;
}
function setMutatedNode(mutatedNodes2, registeredNodes, mutationListeners, node, mutation) {
  if (mutationListeners.size === 0) {
    return;
  }
  const nodeType = node.__type;
  const nodeKey = node.__key;
  const registeredNode = registeredNodes.get(nodeType);
  if (registeredNode === void 0) {
    {
      throw Error(`Type ${nodeType} not in registeredNodes`);
    }
  }
  const klass = registeredNode.klass;
  let mutatedNodesByType = mutatedNodes2.get(klass);
  if (mutatedNodesByType === void 0) {
    mutatedNodesByType = /* @__PURE__ */ new Map();
    mutatedNodes2.set(klass, mutatedNodesByType);
  }
  const prevMutation = mutatedNodesByType.get(nodeKey);
  const isMove = prevMutation === "destroyed" && mutation === "created";
  if (prevMutation === void 0 || isMove) {
    mutatedNodesByType.set(nodeKey, isMove ? "updated" : mutation);
  }
}
function $nodesOfType(klass) {
  const editorState = getActiveEditorState();
  const readOnly = editorState._readOnly;
  const klassType = klass.getType();
  const nodes = editorState._nodeMap;
  const nodesOfType = [];
  for (const [, node] of nodes) {
    if (node instanceof klass && node.__type === klassType && (readOnly || node.isAttached())) {
      nodesOfType.push(node);
    }
  }
  return nodesOfType;
}
function resolveElement(element, isBackward, focusOffset) {
  const parent = element.getParent();
  let offset = focusOffset;
  let block = element;
  if (parent !== null) {
    if (isBackward && focusOffset === 0) {
      offset = block.getIndexWithinParent();
      block = parent;
    } else if (!isBackward && focusOffset === block.getChildrenSize()) {
      offset = block.getIndexWithinParent() + 1;
      block = parent;
    }
  }
  return block.getChildAtIndex(isBackward ? offset - 1 : offset);
}
function $getAdjacentNode(focus, isBackward) {
  const focusOffset = focus.offset;
  if (focus.type === "element") {
    const block = focus.getNode();
    return resolveElement(block, isBackward, focusOffset);
  } else {
    const focusNode = focus.getNode();
    if (isBackward && focusOffset === 0 || !isBackward && focusOffset === focusNode.getTextContentSize()) {
      const possibleNode = isBackward ? focusNode.getPreviousSibling() : focusNode.getNextSibling();
      if (possibleNode === null) {
        return resolveElement(focusNode.getParentOrThrow(), isBackward, focusNode.getIndexWithinParent() + (isBackward ? 0 : 1));
      }
      return possibleNode;
    }
  }
  return null;
}
function isFirefoxClipboardEvents(editor) {
  const event = getWindow(editor).event;
  const inputType = event && event.inputType;
  return inputType === "insertFromPaste" || inputType === "insertFromPasteAsQuotation";
}
function dispatchCommand(editor, command, payload) {
  return triggerCommandListeners(editor, command, payload);
}
function $textContentRequiresDoubleLinebreakAtEnd(node) {
  return !$isRootNode(node) && !node.isLastChild() && !node.isInline();
}
function getElementByKeyOrThrow(editor, key) {
  const element = editor._keyToDOMMap.get(key);
  if (element === void 0) {
    {
      throw Error(`Reconciliation: could not find DOM element for node key ${key}`);
    }
  }
  return element;
}
function getParentElement(node) {
  const parentElement = node.assignedSlot || node.parentElement;
  return parentElement !== null && parentElement.nodeType === 11 ? parentElement.host : parentElement;
}
function scrollIntoViewIfNeeded(editor, selectionRect, rootElement) {
  const doc = rootElement.ownerDocument;
  const defaultView = doc.defaultView;
  if (defaultView === null) {
    return;
  }
  let {
    top: currentTop,
    bottom: currentBottom
  } = selectionRect;
  let targetTop = 0;
  let targetBottom = 0;
  let element = rootElement;
  while (element !== null) {
    const isBodyElement = element === doc.body;
    if (isBodyElement) {
      targetTop = 0;
      targetBottom = getWindow(editor).innerHeight;
    } else {
      const targetRect = element.getBoundingClientRect();
      targetTop = targetRect.top;
      targetBottom = targetRect.bottom;
    }
    let diff = 0;
    if (currentTop < targetTop) {
      diff = -(targetTop - currentTop);
    } else if (currentBottom > targetBottom) {
      diff = currentBottom - targetBottom;
    }
    if (diff !== 0) {
      if (isBodyElement) {
        defaultView.scrollBy(0, diff);
      } else {
        const scrollTop = element.scrollTop;
        element.scrollTop += diff;
        const yOffset = element.scrollTop - scrollTop;
        currentTop -= yOffset;
        currentBottom -= yOffset;
      }
    }
    if (isBodyElement) {
      break;
    }
    element = getParentElement(element);
  }
}
function $hasUpdateTag(tag) {
  const editor = getActiveEditor();
  return editor._updateTags.has(tag);
}
function $addUpdateTag(tag) {
  errorOnReadOnly();
  const editor = getActiveEditor();
  editor._updateTags.add(tag);
}
function $maybeMoveChildrenSelectionToParent(parentNode) {
  const selection = $getSelection();
  if (!$isRangeSelection(selection) || !$isElementNode(parentNode)) {
    return selection;
  }
  const {
    anchor,
    focus
  } = selection;
  const anchorNode = anchor.getNode();
  const focusNode = focus.getNode();
  if ($hasAncestor(anchorNode, parentNode)) {
    anchor.set(parentNode.__key, 0, "element");
  }
  if ($hasAncestor(focusNode, parentNode)) {
    focus.set(parentNode.__key, 0, "element");
  }
  return selection;
}
function $hasAncestor(child, targetNode) {
  let parent = child.getParent();
  while (parent !== null) {
    if (parent.is(targetNode)) {
      return true;
    }
    parent = parent.getParent();
  }
  return false;
}
function getDefaultView(domElem) {
  const ownerDoc = domElem.ownerDocument;
  return ownerDoc && ownerDoc.defaultView || null;
}
function getWindow(editor) {
  const windowObj = editor._window;
  if (windowObj === null) {
    {
      throw Error(`window object not found`);
    }
  }
  return windowObj;
}
function $isInlineElementOrDecoratorNode(node) {
  return $isElementNode(node) && node.isInline() || $isDecoratorNode(node) && node.isInline();
}
function $getNearestRootOrShadowRoot(node) {
  let parent = node.getParentOrThrow();
  while (parent !== null) {
    if ($isRootOrShadowRoot(parent)) {
      return parent;
    }
    parent = parent.getParentOrThrow();
  }
  return parent;
}
function $isRootOrShadowRoot(node) {
  return $isRootNode(node) || $isElementNode(node) && node.isShadowRoot();
}
function $copyNode(node) {
  const copy = node.constructor.clone(node);
  $setNodeKey(copy, null);
  return copy;
}
function $applyNodeReplacement(node) {
  const editor = getActiveEditor();
  const nodeType = node.constructor.getType();
  const registeredNode = editor._nodes.get(nodeType);
  if (registeredNode === void 0) {
    {
      throw Error(`$initializeNode failed. Ensure node has been registered to the editor. You can do this by passing the node class via the "nodes" array in the editor config.`);
    }
  }
  const replaceFunc = registeredNode.replace;
  if (replaceFunc !== null) {
    const replacementNode = replaceFunc(node);
    if (!(replacementNode instanceof node.constructor)) {
      {
        throw Error(`$initializeNode failed. Ensure replacement node is a subclass of the original node.`);
      }
    }
    return replacementNode;
  }
  return node;
}
function errorOnInsertTextNodeOnRoot(node, insertNode) {
  const parentNode = node.getParent();
  if ($isRootNode(parentNode) && !$isElementNode(insertNode) && !$isDecoratorNode(insertNode)) {
    {
      throw Error(`Only element or decorator nodes can be inserted in to the root node`);
    }
  }
}
function createBlockCursorElement(editorConfig) {
  const theme = editorConfig.theme;
  const element = document.createElement("div");
  element.contentEditable = "false";
  element.setAttribute("data-lexical-cursor", "true");
  let blockCursorTheme = theme.blockCursor;
  if (blockCursorTheme !== void 0) {
    if (typeof blockCursorTheme === "string") {
      const classNamesArr = normalizeClassNames(blockCursorTheme);
      blockCursorTheme = theme.blockCursor = classNamesArr;
    }
    if (blockCursorTheme !== void 0) {
      element.classList.add(...blockCursorTheme);
    }
  }
  return element;
}
function needsBlockCursor(node) {
  return ($isDecoratorNode(node) || $isElementNode(node) && !node.canBeEmpty()) && !node.isInline();
}
function removeDOMBlockCursorElement(blockCursorElement, editor, rootElement) {
  rootElement.style.removeProperty("caret-color");
  editor._blockCursorElement = null;
  const parentElement = blockCursorElement.parentElement;
  if (parentElement !== null) {
    parentElement.removeChild(blockCursorElement);
  }
}
function updateDOMBlockCursorElement(editor, rootElement, nextSelection) {
  let blockCursorElement = editor._blockCursorElement;
  if ($isRangeSelection(nextSelection) && nextSelection.isCollapsed() && nextSelection.anchor.type === "element" && rootElement.contains(document.activeElement)) {
    const anchor = nextSelection.anchor;
    const elementNode = anchor.getNode();
    const offset = anchor.offset;
    const elementNodeSize = elementNode.getChildrenSize();
    let isBlockCursor = false;
    let insertBeforeElement = null;
    if (offset === elementNodeSize) {
      const child = elementNode.getChildAtIndex(offset - 1);
      if (needsBlockCursor(child)) {
        isBlockCursor = true;
      }
    } else {
      const child = elementNode.getChildAtIndex(offset);
      if (needsBlockCursor(child)) {
        const sibling = child.getPreviousSibling();
        if (sibling === null || needsBlockCursor(sibling)) {
          isBlockCursor = true;
          insertBeforeElement = editor.getElementByKey(child.__key);
        }
      }
    }
    if (isBlockCursor) {
      const elementDOM = editor.getElementByKey(elementNode.__key);
      if (blockCursorElement === null) {
        editor._blockCursorElement = blockCursorElement = createBlockCursorElement(editor._config);
      }
      rootElement.style.caretColor = "transparent";
      if (insertBeforeElement === null) {
        elementDOM.appendChild(blockCursorElement);
      } else {
        elementDOM.insertBefore(blockCursorElement, insertBeforeElement);
      }
      return;
    }
  }
  if (blockCursorElement !== null) {
    removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);
  }
}
function getDOMSelection(targetWindow) {
  return !CAN_USE_DOM ? null : (targetWindow || window).getSelection();
}
function $splitNode(node, offset) {
  let startNode = node.getChildAtIndex(offset);
  if (startNode == null) {
    startNode = node;
  }
  if (!!$isRootOrShadowRoot(node)) {
    throw Error(`Can not call $splitNode() on root element`);
  }
  const recurse = (currentNode) => {
    const parent = currentNode.getParentOrThrow();
    const isParentRoot = $isRootOrShadowRoot(parent);
    const nodeToMove = currentNode === startNode && !isParentRoot ? currentNode : $copyNode(currentNode);
    if (isParentRoot) {
      if (!($isElementNode(currentNode) && $isElementNode(nodeToMove))) {
        throw Error(`Children of a root must be ElementNode`);
      }
      currentNode.insertAfter(nodeToMove);
      return [currentNode, nodeToMove, nodeToMove];
    } else {
      const [leftTree2, rightTree2, newParent] = recurse(parent);
      const nextSiblings = currentNode.getNextSiblings();
      newParent.append(nodeToMove, ...nextSiblings);
      return [leftTree2, rightTree2, nodeToMove];
    }
  };
  const [leftTree, rightTree] = recurse(startNode);
  return [leftTree, rightTree];
}
function isHTMLAnchorElement(x2) {
  return isHTMLElement(x2) && x2.tagName === "A";
}
function isHTMLElement(x2) {
  return x2.nodeType === 1;
}
function INTERNAL_$isBlock(node) {
  if ($isDecoratorNode(node) && !node.isInline()) {
    return true;
  }
  if (!$isElementNode(node) || $isRootOrShadowRoot(node)) {
    return false;
  }
  const firstChild = node.getFirstChild();
  const isLeafElement = firstChild === null || $isLineBreakNode(firstChild) || $isTextNode(firstChild) || firstChild.isInline();
  return !node.isInline() && node.canBeEmpty() !== false && isLeafElement;
}
function $getAncestor(node, predicate) {
  let parent = node;
  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {
    parent = parent.getParentOrThrow();
  }
  return predicate(parent) ? parent : null;
}
function $getEditor() {
  return getActiveEditor();
}
function $garbageCollectDetachedDecorators(editor, pendingEditorState) {
  const currentDecorators = editor._decorators;
  const pendingDecorators = editor._pendingDecorators;
  let decorators = pendingDecorators || currentDecorators;
  const nodeMap = pendingEditorState._nodeMap;
  let key;
  for (key in decorators) {
    if (!nodeMap.has(key)) {
      if (decorators === currentDecorators) {
        decorators = cloneDecorators(editor);
      }
      delete decorators[key];
    }
  }
}
function $garbageCollectDetachedDeepChildNodes(node, parentKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyNodes) {
  let child = node.getFirstChild();
  while (child !== null) {
    const childKey = child.__key;
    if (child.__parent === parentKey) {
      if ($isElementNode(child)) {
        $garbageCollectDetachedDeepChildNodes(child, childKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyNodes);
      }
      if (!prevNodeMap.has(childKey)) {
        dirtyNodes.delete(childKey);
      }
      nodeMapDelete.push(childKey);
    }
    child = child.getNextSibling();
  }
}
function $garbageCollectDetachedNodes(prevEditorState, editorState, dirtyLeaves, dirtyElements) {
  const prevNodeMap = prevEditorState._nodeMap;
  const nodeMap = editorState._nodeMap;
  const nodeMapDelete = [];
  for (const [nodeKey] of dirtyElements) {
    const node = nodeMap.get(nodeKey);
    if (node !== void 0) {
      if (!node.isAttached()) {
        if ($isElementNode(node)) {
          $garbageCollectDetachedDeepChildNodes(node, nodeKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyElements);
        }
        if (!prevNodeMap.has(nodeKey)) {
          dirtyElements.delete(nodeKey);
        }
        nodeMapDelete.push(nodeKey);
      }
    }
  }
  for (const nodeKey of nodeMapDelete) {
    nodeMap.delete(nodeKey);
  }
  for (const nodeKey of dirtyLeaves) {
    const node = nodeMap.get(nodeKey);
    if (node !== void 0 && !node.isAttached()) {
      if (!prevNodeMap.has(nodeKey)) {
        dirtyLeaves.delete(nodeKey);
      }
      nodeMap.delete(nodeKey);
    }
  }
}
var subTreeTextContent = "";
var subTreeDirectionedTextContent = "";
var editorTextContent = "";
var activeEditorConfig;
var activeEditor$1;
var activeEditorNodes;
var treatAllNodesAsDirty = false;
var activeEditorStateReadOnly = false;
var activeMutationListeners;
var activeTextDirection = null;
var activeDirtyElements;
var activeDirtyLeaves;
var activePrevNodeMap;
var activeNextNodeMap;
var activePrevKeyToDOMMap;
var mutatedNodes;
function destroyNode(key, parentDOM) {
  const node = activePrevNodeMap.get(key);
  if (parentDOM !== null) {
    const dom = getPrevElementByKeyOrThrow(key);
    if (dom.parentNode === parentDOM) {
      parentDOM.removeChild(dom);
    }
  }
  if (!activeNextNodeMap.has(key)) {
    activeEditor$1._keyToDOMMap.delete(key);
  }
  if ($isElementNode(node)) {
    const children = createChildrenArray(node, activePrevNodeMap);
    destroyChildren(children, 0, children.length - 1, null);
  }
  if (node !== void 0) {
    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, "destroyed");
  }
}
function destroyChildren(children, _startIndex, endIndex, dom) {
  let startIndex = _startIndex;
  for (; startIndex <= endIndex; ++startIndex) {
    const child = children[startIndex];
    if (child !== void 0) {
      destroyNode(child, dom);
    }
  }
}
function setTextAlign(domStyle, value) {
  domStyle.setProperty("text-align", value);
}
var DEFAULT_INDENT_VALUE = "40px";
function setElementIndent(dom, indent) {
  const indentClassName = activeEditorConfig.theme.indent;
  if (typeof indentClassName === "string") {
    const elementHasClassName = dom.classList.contains(indentClassName);
    if (indent > 0 && !elementHasClassName) {
      dom.classList.add(indentClassName);
    } else if (indent < 1 && elementHasClassName) {
      dom.classList.remove(indentClassName);
    }
  }
  const indentationBaseValue = getComputedStyle(dom).getPropertyValue("--lexical-indent-base-value") || DEFAULT_INDENT_VALUE;
  dom.style.setProperty("padding-inline-start", indent === 0 ? "" : `calc(${indent} * ${indentationBaseValue})`);
}
function setElementFormat(dom, format) {
  const domStyle = dom.style;
  if (format === 0) {
    setTextAlign(domStyle, "");
  } else if (format === IS_ALIGN_LEFT) {
    setTextAlign(domStyle, "left");
  } else if (format === IS_ALIGN_CENTER) {
    setTextAlign(domStyle, "center");
  } else if (format === IS_ALIGN_RIGHT) {
    setTextAlign(domStyle, "right");
  } else if (format === IS_ALIGN_JUSTIFY) {
    setTextAlign(domStyle, "justify");
  } else if (format === IS_ALIGN_START) {
    setTextAlign(domStyle, "start");
  } else if (format === IS_ALIGN_END) {
    setTextAlign(domStyle, "end");
  }
}
function createNode(key, parentDOM, insertDOM) {
  const node = activeNextNodeMap.get(key);
  if (node === void 0) {
    {
      throw Error(`createNode: node does not exist in nodeMap`);
    }
  }
  const dom = node.createDOM(activeEditorConfig, activeEditor$1);
  storeDOMWithKey(key, dom, activeEditor$1);
  if ($isTextNode(node)) {
    dom.setAttribute("data-lexical-text", "true");
  } else if ($isDecoratorNode(node)) {
    dom.setAttribute("data-lexical-decorator", "true");
  }
  if ($isElementNode(node)) {
    const indent = node.__indent;
    const childrenSize = node.__size;
    if (indent !== 0) {
      setElementIndent(dom, indent);
    }
    if (childrenSize !== 0) {
      const endIndex = childrenSize - 1;
      const children = createChildrenArray(node, activeNextNodeMap);
      createChildrenWithDirection(children, endIndex, node, dom);
    }
    const format = node.__format;
    if (format !== 0) {
      setElementFormat(dom, format);
    }
    if (!node.isInline()) {
      reconcileElementTerminatingLineBreak(null, node, dom);
    }
    if ($textContentRequiresDoubleLinebreakAtEnd(node)) {
      subTreeTextContent += DOUBLE_LINE_BREAK;
      editorTextContent += DOUBLE_LINE_BREAK;
    }
  } else {
    const text = node.getTextContent();
    if ($isDecoratorNode(node)) {
      const decorator = node.decorate(activeEditor$1, activeEditorConfig);
      if (decorator !== null) {
        reconcileDecorator(key, decorator);
      }
      dom.contentEditable = "false";
    } else if ($isTextNode(node)) {
      if (!node.isDirectionless()) {
        subTreeDirectionedTextContent += text;
      }
    }
    subTreeTextContent += text;
    editorTextContent += text;
  }
  if (parentDOM !== null) {
    if (insertDOM != null) {
      parentDOM.insertBefore(dom, insertDOM);
    } else {
      const possibleLineBreak = parentDOM.__lexicalLineBreak;
      if (possibleLineBreak != null) {
        parentDOM.insertBefore(dom, possibleLineBreak);
      } else {
        parentDOM.appendChild(dom);
      }
    }
  }
  {
    Object.freeze(node);
  }
  setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, "created");
  return dom;
}
function createChildrenWithDirection(children, endIndex, element, dom) {
  const previousSubTreeDirectionedTextContent = subTreeDirectionedTextContent;
  subTreeDirectionedTextContent = "";
  createChildren(children, element, 0, endIndex, dom, null);
  reconcileBlockDirection(element, dom);
  subTreeDirectionedTextContent = previousSubTreeDirectionedTextContent;
}
function createChildren(children, element, _startIndex, endIndex, dom, insertDOM) {
  const previousSubTreeTextContent = subTreeTextContent;
  subTreeTextContent = "";
  let startIndex = _startIndex;
  for (; startIndex <= endIndex; ++startIndex) {
    createNode(children[startIndex], dom, insertDOM);
  }
  if ($textContentRequiresDoubleLinebreakAtEnd(element)) {
    subTreeTextContent += DOUBLE_LINE_BREAK;
  }
  dom.__lexicalTextContent = subTreeTextContent;
  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;
}
function isLastChildLineBreakOrDecorator(childKey, nodeMap) {
  const node = nodeMap.get(childKey);
  return $isLineBreakNode(node) || $isDecoratorNode(node) && node.isInline();
}
function reconcileElementTerminatingLineBreak(prevElement, nextElement, dom) {
  const prevLineBreak = prevElement !== null && (prevElement.__size === 0 || isLastChildLineBreakOrDecorator(prevElement.__last, activePrevNodeMap));
  const nextLineBreak = nextElement.__size === 0 || isLastChildLineBreakOrDecorator(nextElement.__last, activeNextNodeMap);
  if (prevLineBreak) {
    if (!nextLineBreak) {
      const element = dom.__lexicalLineBreak;
      if (element != null) {
        dom.removeChild(element);
      }
      dom.__lexicalLineBreak = null;
    }
  } else if (nextLineBreak) {
    const element = document.createElement("br");
    dom.__lexicalLineBreak = element;
    dom.appendChild(element);
  }
}
function reconcileBlockDirection(element, dom) {
  const previousSubTreeDirectionTextContent = (
    // @ts-expect-error: internal field
    dom.__lexicalDirTextContent
  );
  const previousDirection = dom.__lexicalDir;
  if (previousSubTreeDirectionTextContent !== subTreeDirectionedTextContent || previousDirection !== activeTextDirection) {
    const hasEmptyDirectionedTextContent = subTreeDirectionedTextContent === "";
    const direction = hasEmptyDirectionedTextContent ? activeTextDirection : getTextDirection(subTreeDirectionedTextContent);
    if (direction !== previousDirection) {
      const classList = dom.classList;
      const theme = activeEditorConfig.theme;
      let previousDirectionTheme = previousDirection !== null ? theme[previousDirection] : void 0;
      let nextDirectionTheme = direction !== null ? theme[direction] : void 0;
      if (previousDirectionTheme !== void 0) {
        if (typeof previousDirectionTheme === "string") {
          const classNamesArr = normalizeClassNames(previousDirectionTheme);
          previousDirectionTheme = theme[previousDirection] = classNamesArr;
        }
        classList.remove(...previousDirectionTheme);
      }
      if (direction === null || hasEmptyDirectionedTextContent && direction === "ltr") {
        dom.removeAttribute("dir");
      } else {
        if (nextDirectionTheme !== void 0) {
          if (typeof nextDirectionTheme === "string") {
            const classNamesArr = normalizeClassNames(nextDirectionTheme);
            nextDirectionTheme = theme[direction] = classNamesArr;
          }
          if (nextDirectionTheme !== void 0) {
            classList.add(...nextDirectionTheme);
          }
        }
        dom.dir = direction;
      }
      if (!activeEditorStateReadOnly) {
        const writableNode = element.getWritable();
        writableNode.__dir = direction;
      }
    }
    activeTextDirection = direction;
    dom.__lexicalDirTextContent = subTreeDirectionedTextContent;
    dom.__lexicalDir = direction;
  }
}
function reconcileChildrenWithDirection(prevElement, nextElement, dom) {
  const previousSubTreeDirectionTextContent = subTreeDirectionedTextContent;
  subTreeDirectionedTextContent = "";
  reconcileChildren(prevElement, nextElement, dom);
  reconcileBlockDirection(nextElement, dom);
  subTreeDirectionedTextContent = previousSubTreeDirectionTextContent;
}
function createChildrenArray(element, nodeMap) {
  const children = [];
  let nodeKey = element.__first;
  while (nodeKey !== null) {
    const node = nodeMap.get(nodeKey);
    if (node === void 0) {
      {
        throw Error(`createChildrenArray: node does not exist in nodeMap`);
      }
    }
    children.push(nodeKey);
    nodeKey = node.__next;
  }
  return children;
}
function reconcileChildren(prevElement, nextElement, dom) {
  const previousSubTreeTextContent = subTreeTextContent;
  const prevChildrenSize = prevElement.__size;
  const nextChildrenSize = nextElement.__size;
  subTreeTextContent = "";
  if (prevChildrenSize === 1 && nextChildrenSize === 1) {
    const prevFirstChildKey = prevElement.__first;
    const nextFrstChildKey = nextElement.__first;
    if (prevFirstChildKey === nextFrstChildKey) {
      reconcileNode(prevFirstChildKey, dom);
    } else {
      const lastDOM = getPrevElementByKeyOrThrow(prevFirstChildKey);
      const replacementDOM = createNode(nextFrstChildKey, null, null);
      dom.replaceChild(replacementDOM, lastDOM);
      destroyNode(prevFirstChildKey, null);
    }
  } else {
    const prevChildren = createChildrenArray(prevElement, activePrevNodeMap);
    const nextChildren = createChildrenArray(nextElement, activeNextNodeMap);
    if (prevChildrenSize === 0) {
      if (nextChildrenSize !== 0) {
        createChildren(nextChildren, nextElement, 0, nextChildrenSize - 1, dom, null);
      }
    } else if (nextChildrenSize === 0) {
      if (prevChildrenSize !== 0) {
        const lexicalLineBreak = dom.__lexicalLineBreak;
        const canUseFastPath = lexicalLineBreak == null;
        destroyChildren(prevChildren, 0, prevChildrenSize - 1, canUseFastPath ? null : dom);
        if (canUseFastPath) {
          dom.textContent = "";
        }
      }
    } else {
      reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenSize, nextChildrenSize, dom);
    }
  }
  if ($textContentRequiresDoubleLinebreakAtEnd(nextElement)) {
    subTreeTextContent += DOUBLE_LINE_BREAK;
  }
  dom.__lexicalTextContent = subTreeTextContent;
  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;
}
function reconcileNode(key, parentDOM) {
  const prevNode = activePrevNodeMap.get(key);
  let nextNode = activeNextNodeMap.get(key);
  if (prevNode === void 0 || nextNode === void 0) {
    {
      throw Error(`reconcileNode: prevNode or nextNode does not exist in nodeMap`);
    }
  }
  const isDirty = treatAllNodesAsDirty || activeDirtyLeaves.has(key) || activeDirtyElements.has(key);
  const dom = getElementByKeyOrThrow(activeEditor$1, key);
  if (prevNode === nextNode && !isDirty) {
    if ($isElementNode(prevNode)) {
      const previousSubTreeTextContent = dom.__lexicalTextContent;
      if (previousSubTreeTextContent !== void 0) {
        subTreeTextContent += previousSubTreeTextContent;
        editorTextContent += previousSubTreeTextContent;
      }
      const previousSubTreeDirectionTextContent = dom.__lexicalDirTextContent;
      if (previousSubTreeDirectionTextContent !== void 0) {
        subTreeDirectionedTextContent += previousSubTreeDirectionTextContent;
      }
    } else {
      const text = prevNode.getTextContent();
      if ($isTextNode(prevNode) && !prevNode.isDirectionless()) {
        subTreeDirectionedTextContent += text;
      }
      editorTextContent += text;
      subTreeTextContent += text;
    }
    return dom;
  }
  if (prevNode !== nextNode && isDirty) {
    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, nextNode, "updated");
  }
  if (nextNode.updateDOM(prevNode, dom, activeEditorConfig)) {
    const replacementDOM = createNode(key, null, null);
    if (parentDOM === null) {
      {
        throw Error(`reconcileNode: parentDOM is null`);
      }
    }
    parentDOM.replaceChild(replacementDOM, dom);
    destroyNode(key, null);
    return replacementDOM;
  }
  if ($isElementNode(prevNode) && $isElementNode(nextNode)) {
    const nextIndent = nextNode.__indent;
    if (nextIndent !== prevNode.__indent) {
      setElementIndent(dom, nextIndent);
    }
    const nextFormat = nextNode.__format;
    if (nextFormat !== prevNode.__format) {
      setElementFormat(dom, nextFormat);
    }
    if (isDirty) {
      reconcileChildrenWithDirection(prevNode, nextNode, dom);
      if (!$isRootNode(nextNode) && !nextNode.isInline()) {
        reconcileElementTerminatingLineBreak(prevNode, nextNode, dom);
      }
    }
    if ($textContentRequiresDoubleLinebreakAtEnd(nextNode)) {
      subTreeTextContent += DOUBLE_LINE_BREAK;
      editorTextContent += DOUBLE_LINE_BREAK;
    }
  } else {
    const text = nextNode.getTextContent();
    if ($isDecoratorNode(nextNode)) {
      const decorator = nextNode.decorate(activeEditor$1, activeEditorConfig);
      if (decorator !== null) {
        reconcileDecorator(key, decorator);
      }
    } else if ($isTextNode(nextNode) && !nextNode.isDirectionless()) {
      subTreeDirectionedTextContent += text;
    }
    subTreeTextContent += text;
    editorTextContent += text;
  }
  if (!activeEditorStateReadOnly && $isRootNode(nextNode) && nextNode.__cachedText !== editorTextContent) {
    const nextRootNode = nextNode.getWritable();
    nextRootNode.__cachedText = editorTextContent;
    nextNode = nextRootNode;
  }
  {
    Object.freeze(nextNode);
  }
  return dom;
}
function reconcileDecorator(key, decorator) {
  let pendingDecorators = activeEditor$1._pendingDecorators;
  const currentDecorators = activeEditor$1._decorators;
  if (pendingDecorators === null) {
    if (currentDecorators[key] === decorator) {
      return;
    }
    pendingDecorators = cloneDecorators(activeEditor$1);
  }
  pendingDecorators[key] = decorator;
}
function getFirstChild(element) {
  return element.firstChild;
}
function getNextSibling(element) {
  let nextSibling = element.nextSibling;
  if (nextSibling !== null && nextSibling === activeEditor$1._blockCursorElement) {
    nextSibling = nextSibling.nextSibling;
  }
  return nextSibling;
}
function reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenLength, nextChildrenLength, dom) {
  const prevEndIndex = prevChildrenLength - 1;
  const nextEndIndex = nextChildrenLength - 1;
  let prevChildrenSet;
  let nextChildrenSet;
  let siblingDOM = getFirstChild(dom);
  let prevIndex = 0;
  let nextIndex = 0;
  while (prevIndex <= prevEndIndex && nextIndex <= nextEndIndex) {
    const prevKey = prevChildren[prevIndex];
    const nextKey = nextChildren[nextIndex];
    if (prevKey === nextKey) {
      siblingDOM = getNextSibling(reconcileNode(nextKey, dom));
      prevIndex++;
      nextIndex++;
    } else {
      if (prevChildrenSet === void 0) {
        prevChildrenSet = new Set(prevChildren);
      }
      if (nextChildrenSet === void 0) {
        nextChildrenSet = new Set(nextChildren);
      }
      const nextHasPrevKey = nextChildrenSet.has(prevKey);
      const prevHasNextKey = prevChildrenSet.has(nextKey);
      if (!nextHasPrevKey) {
        siblingDOM = getNextSibling(getPrevElementByKeyOrThrow(prevKey));
        destroyNode(prevKey, dom);
        prevIndex++;
      } else if (!prevHasNextKey) {
        createNode(nextKey, dom, siblingDOM);
        nextIndex++;
      } else {
        const childDOM = getElementByKeyOrThrow(activeEditor$1, nextKey);
        if (childDOM === siblingDOM) {
          siblingDOM = getNextSibling(reconcileNode(nextKey, dom));
        } else {
          if (siblingDOM != null) {
            dom.insertBefore(childDOM, siblingDOM);
          } else {
            dom.appendChild(childDOM);
          }
          reconcileNode(nextKey, dom);
        }
        prevIndex++;
        nextIndex++;
      }
    }
  }
  const appendNewChildren = prevIndex > prevEndIndex;
  const removeOldChildren = nextIndex > nextEndIndex;
  if (appendNewChildren && !removeOldChildren) {
    const previousNode = nextChildren[nextEndIndex + 1];
    const insertDOM = previousNode === void 0 ? null : activeEditor$1.getElementByKey(previousNode);
    createChildren(nextChildren, nextElement, nextIndex, nextEndIndex, dom, insertDOM);
  } else if (removeOldChildren && !appendNewChildren) {
    destroyChildren(prevChildren, prevIndex, prevEndIndex, dom);
  }
}
function reconcileRoot(prevEditorState, nextEditorState, editor, dirtyType, dirtyElements, dirtyLeaves) {
  subTreeTextContent = "";
  editorTextContent = "";
  subTreeDirectionedTextContent = "";
  treatAllNodesAsDirty = dirtyType === FULL_RECONCILE;
  activeTextDirection = null;
  activeEditor$1 = editor;
  activeEditorConfig = editor._config;
  activeEditorNodes = editor._nodes;
  activeMutationListeners = activeEditor$1._listeners.mutation;
  activeDirtyElements = dirtyElements;
  activeDirtyLeaves = dirtyLeaves;
  activePrevNodeMap = prevEditorState._nodeMap;
  activeNextNodeMap = nextEditorState._nodeMap;
  activeEditorStateReadOnly = nextEditorState._readOnly;
  activePrevKeyToDOMMap = new Map(editor._keyToDOMMap);
  const currentMutatedNodes = /* @__PURE__ */ new Map();
  mutatedNodes = currentMutatedNodes;
  reconcileNode("root", null);
  activeEditor$1 = void 0;
  activeEditorNodes = void 0;
  activeDirtyElements = void 0;
  activeDirtyLeaves = void 0;
  activePrevNodeMap = void 0;
  activeNextNodeMap = void 0;
  activeEditorConfig = void 0;
  activePrevKeyToDOMMap = void 0;
  mutatedNodes = void 0;
  return currentMutatedNodes;
}
function storeDOMWithKey(key, dom, editor) {
  const keyToDOMMap = editor._keyToDOMMap;
  dom["__lexicalKey_" + editor._key] = key;
  keyToDOMMap.set(key, dom);
}
function getPrevElementByKeyOrThrow(key) {
  const element = activePrevKeyToDOMMap.get(key);
  if (element === void 0) {
    {
      throw Error(`Reconciliation: could not find DOM element for node key ${key}`);
    }
  }
  return element;
}
var PASS_THROUGH_COMMAND = Object.freeze({});
var ANDROID_COMPOSITION_LATENCY = 30;
var rootElementEvents = [["keydown", onKeyDown], ["pointerdown", onPointerDown], ["compositionstart", onCompositionStart], ["compositionend", onCompositionEnd], ["input", onInput], ["click", onClick], ["cut", PASS_THROUGH_COMMAND], ["copy", PASS_THROUGH_COMMAND], ["dragstart", PASS_THROUGH_COMMAND], ["dragover", PASS_THROUGH_COMMAND], ["dragend", PASS_THROUGH_COMMAND], ["paste", PASS_THROUGH_COMMAND], ["focus", PASS_THROUGH_COMMAND], ["blur", PASS_THROUGH_COMMAND], ["drop", PASS_THROUGH_COMMAND]];
if (CAN_USE_BEFORE_INPUT) {
  rootElementEvents.push(["beforeinput", (event, editor) => onBeforeInput(event, editor)]);
}
var lastKeyDownTimeStamp = 0;
var lastKeyCode = 0;
var lastBeforeInputInsertTextTimeStamp = 0;
var unprocessedBeforeInputData = null;
var rootElementsRegistered = /* @__PURE__ */ new WeakMap();
var isSelectionChangeFromDOMUpdate = false;
var isSelectionChangeFromMouseDown = false;
var isInsertLineBreak = false;
var isFirefoxEndingComposition = false;
var collapsedSelectionFormat = [0, "", 0, "root", 0];
function $shouldPreventDefaultAndInsertText(selection, domTargetRange, text, timeStamp, isBeforeInput) {
  const anchor = selection.anchor;
  const focus = selection.focus;
  const anchorNode = anchor.getNode();
  const editor = getActiveEditor();
  const domSelection = getDOMSelection(editor._window);
  const domAnchorNode = domSelection !== null ? domSelection.anchorNode : null;
  const anchorKey = anchor.key;
  const backingAnchorElement = editor.getElementByKey(anchorKey);
  const textLength = text.length;
  return anchorKey !== focus.key || // If we're working with a non-text node.
  !$isTextNode(anchorNode) || // If we are replacing a range with a single character or grapheme, and not composing.
  (!isBeforeInput && (!CAN_USE_BEFORE_INPUT || // We check to see if there has been
  // a recent beforeinput event for "textInput". If there has been one in the last
  // 50ms then we proceed as normal. However, if there is not, then this is likely
  // a dangling `input` event caused by execCommand('insertText').
  lastBeforeInputInsertTextTimeStamp < timeStamp + 50) || anchorNode.isDirty() && textLength < 2 || doesContainGrapheme(text)) && anchor.offset !== focus.offset && !anchorNode.isComposing() || // Any non standard text node.
  $isTokenOrSegmented(anchorNode) || // If the text length is more than a single character and we're either
  // dealing with this in "beforeinput" or where the node has already recently
  // been changed (thus is dirty).
  anchorNode.isDirty() && textLength > 1 || // If the DOM selection element is not the same as the backing node during beforeinput.
  (isBeforeInput || !CAN_USE_BEFORE_INPUT) && backingAnchorElement !== null && !anchorNode.isComposing() && domAnchorNode !== getDOMTextNode(backingAnchorElement) || // If TargetRange is not the same as the DOM selection; browser trying to edit random parts
  // of the editor.
  domSelection !== null && domTargetRange !== null && (!domTargetRange.collapsed || domTargetRange.startContainer !== domSelection.anchorNode || domTargetRange.startOffset !== domSelection.anchorOffset) || // Check if we're changing from bold to italics, or some other format.
  anchorNode.getFormat() !== selection.format || anchorNode.getStyle() !== selection.style || // One last set of heuristics to check against.
  $shouldInsertTextAfterOrBeforeTextNode(selection, anchorNode);
}
function shouldSkipSelectionChange(domNode, offset) {
  return domNode !== null && domNode.nodeValue !== null && domNode.nodeType === DOM_TEXT_TYPE && offset !== 0 && offset !== domNode.nodeValue.length;
}
function onSelectionChange(domSelection, editor, isActive) {
  const {
    anchorNode: anchorDOM,
    anchorOffset,
    focusNode: focusDOM,
    focusOffset
  } = domSelection;
  if (isSelectionChangeFromDOMUpdate) {
    isSelectionChangeFromDOMUpdate = false;
    if (shouldSkipSelectionChange(anchorDOM, anchorOffset) && shouldSkipSelectionChange(focusDOM, focusOffset)) {
      return;
    }
  }
  updateEditor(editor, () => {
    if (!isActive) {
      $setSelection(null);
      return;
    }
    if (!isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {
      return;
    }
    const selection = $getSelection();
    if ($isRangeSelection(selection)) {
      const anchor = selection.anchor;
      const anchorNode = anchor.getNode();
      if (selection.isCollapsed()) {
        if (domSelection.type === "Range" && domSelection.anchorNode === domSelection.focusNode) {
          selection.dirty = true;
        }
        const windowEvent = getWindow(editor).event;
        const currentTimeStamp = windowEvent ? windowEvent.timeStamp : performance.now();
        const [lastFormat, lastStyle, lastOffset, lastKey, timeStamp] = collapsedSelectionFormat;
        const root = $getRoot();
        const isRootTextContentEmpty = editor.isComposing() === false && root.getTextContent() === "";
        if (currentTimeStamp < timeStamp + 200 && anchor.offset === lastOffset && anchor.key === lastKey) {
          selection.format = lastFormat;
          selection.style = lastStyle;
        } else {
          if (anchor.type === "text") {
            if (!$isTextNode(anchorNode)) {
              throw Error(`Point.getNode() must return TextNode when type is text`);
            }
            selection.format = anchorNode.getFormat();
            selection.style = anchorNode.getStyle();
          } else if (anchor.type === "element" && !isRootTextContentEmpty) {
            selection.format = 0;
            selection.style = "";
          }
        }
      } else {
        const anchorKey = anchor.key;
        const focus = selection.focus;
        const focusKey = focus.key;
        const nodes = selection.getNodes();
        const nodesLength = nodes.length;
        const isBackward = selection.isBackward();
        const startOffset = isBackward ? focusOffset : anchorOffset;
        const endOffset = isBackward ? anchorOffset : focusOffset;
        const startKey = isBackward ? focusKey : anchorKey;
        const endKey = isBackward ? anchorKey : focusKey;
        let combinedFormat = IS_ALL_FORMATTING;
        let hasTextNodes = false;
        for (let i2 = 0; i2 < nodesLength; i2++) {
          const node = nodes[i2];
          const textContentSize = node.getTextContentSize();
          if ($isTextNode(node) && textContentSize !== 0 && // Exclude empty text nodes at boundaries resulting from user's selection
          !(i2 === 0 && node.__key === startKey && startOffset === textContentSize || i2 === nodesLength - 1 && node.__key === endKey && endOffset === 0)) {
            hasTextNodes = true;
            combinedFormat &= node.getFormat();
            if (combinedFormat === 0) {
              break;
            }
          }
        }
        selection.format = hasTextNodes ? combinedFormat : 0;
      }
    }
    dispatchCommand(editor, SELECTION_CHANGE_COMMAND, void 0);
  });
}
function onClick(event, editor) {
  updateEditor(editor, () => {
    const selection = $getSelection();
    const domSelection = getDOMSelection(editor._window);
    const lastSelection = $getPreviousSelection();
    if (domSelection) {
      if ($isRangeSelection(selection)) {
        const anchor = selection.anchor;
        const anchorNode = anchor.getNode();
        if (anchor.type === "element" && anchor.offset === 0 && selection.isCollapsed() && !$isRootNode(anchorNode) && $getRoot().getChildrenSize() === 1 && anchorNode.getTopLevelElementOrThrow().isEmpty() && lastSelection !== null && selection.is(lastSelection)) {
          domSelection.removeAllRanges();
          selection.dirty = true;
        } else if (event.detail === 3 && !selection.isCollapsed()) {
          const focus = selection.focus;
          const focusNode = focus.getNode();
          if (anchorNode !== focusNode) {
            if ($isElementNode(anchorNode)) {
              anchorNode.select(0);
            } else {
              anchorNode.getParentOrThrow().select(0);
            }
          }
        }
      } else if (event.pointerType === "touch") {
        const domAnchorNode = domSelection.anchorNode;
        if (domAnchorNode !== null) {
          const nodeType = domAnchorNode.nodeType;
          if (nodeType === DOM_ELEMENT_TYPE || nodeType === DOM_TEXT_TYPE) {
            const newSelection = internalCreateRangeSelection(lastSelection, domSelection, editor, event);
            $setSelection(newSelection);
          }
        }
      }
    }
    dispatchCommand(editor, CLICK_COMMAND, event);
  });
}
function onPointerDown(event, editor) {
  const target = event.target;
  const pointerType = event.pointerType;
  if (target instanceof Node && pointerType !== "touch") {
    updateEditor(editor, () => {
      if (!$isSelectionCapturedInDecorator(target)) {
        isSelectionChangeFromMouseDown = true;
      }
    });
  }
}
function getTargetRange(event) {
  if (!event.getTargetRanges) {
    return null;
  }
  const targetRanges = event.getTargetRanges();
  if (targetRanges.length === 0) {
    return null;
  }
  return targetRanges[0];
}
function $canRemoveText(anchorNode, focusNode) {
  return anchorNode !== focusNode || $isElementNode(anchorNode) || $isElementNode(focusNode) || !anchorNode.isToken() || !focusNode.isToken();
}
function isPossiblyAndroidKeyPress(timeStamp) {
  return lastKeyCode === 229 && timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY;
}
function onBeforeInput(event, editor) {
  const inputType = event.inputType;
  const targetRange = getTargetRange(event);
  if (inputType === "deleteCompositionText" || // If we're pasting in FF, we shouldn't get this event
  // as the `paste` event should have triggered, unless the
  // user has dom.event.clipboardevents.enabled disabled in
  // about:config. In that case, we need to process the
  // pasted content in the DOM mutation phase.
  IS_FIREFOX && isFirefoxClipboardEvents(editor)) {
    return;
  } else if (inputType === "insertCompositionText") {
    return;
  }
  updateEditor(editor, () => {
    const selection = $getSelection();
    if (inputType === "deleteContentBackward") {
      if (selection === null) {
        const prevSelection = $getPreviousSelection();
        if (!$isRangeSelection(prevSelection)) {
          return;
        }
        $setSelection(prevSelection.clone());
      }
      if ($isRangeSelection(selection)) {
        const isSelectionAnchorSameAsFocus = selection.anchor.key === selection.focus.key;
        if (isPossiblyAndroidKeyPress(event.timeStamp) && editor.isComposing() && isSelectionAnchorSameAsFocus) {
          $setCompositionKey(null);
          lastKeyDownTimeStamp = 0;
          setTimeout(() => {
            updateEditor(editor, () => {
              $setCompositionKey(null);
            });
          }, ANDROID_COMPOSITION_LATENCY);
          if ($isRangeSelection(selection)) {
            const anchorNode2 = selection.anchor.getNode();
            anchorNode2.markDirty();
            selection.format = anchorNode2.getFormat();
            if (!$isTextNode(anchorNode2)) {
              throw Error(`Anchor node must be a TextNode`);
            }
            selection.style = anchorNode2.getStyle();
          }
        } else {
          $setCompositionKey(null);
          event.preventDefault();
          const selectedNodeText = selection.anchor.getNode().getTextContent();
          const hasSelectedAllTextInNode = selection.anchor.offset === 0 && selection.focus.offset === selectedNodeText.length;
          const shouldLetBrowserHandleDelete = IS_ANDROID_CHROME && isSelectionAnchorSameAsFocus && !hasSelectedAllTextInNode;
          if (!shouldLetBrowserHandleDelete) {
            dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);
          }
        }
        return;
      }
    }
    if (!$isRangeSelection(selection)) {
      return;
    }
    const data = event.data;
    if (unprocessedBeforeInputData !== null) {
      $updateSelectedTextFromDOM(false, editor, unprocessedBeforeInputData);
    }
    if ((!selection.dirty || unprocessedBeforeInputData !== null) && selection.isCollapsed() && !$isRootNode(selection.anchor.getNode()) && targetRange !== null) {
      selection.applyDOMRange(targetRange);
    }
    unprocessedBeforeInputData = null;
    const anchor = selection.anchor;
    const focus = selection.focus;
    const anchorNode = anchor.getNode();
    const focusNode = focus.getNode();
    if (inputType === "insertText" || inputType === "insertTranspose") {
      if (data === "\n") {
        event.preventDefault();
        dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);
      } else if (data === DOUBLE_LINE_BREAK) {
        event.preventDefault();
        dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, void 0);
      } else if (data == null && event.dataTransfer) {
        const text = event.dataTransfer.getData("text/plain");
        event.preventDefault();
        selection.insertRawText(text);
      } else if (data != null && $shouldPreventDefaultAndInsertText(selection, targetRange, data, event.timeStamp, true)) {
        event.preventDefault();
        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);
      } else {
        unprocessedBeforeInputData = data;
      }
      lastBeforeInputInsertTextTimeStamp = event.timeStamp;
      return;
    }
    event.preventDefault();
    switch (inputType) {
      case "insertFromYank":
      case "insertFromDrop":
      case "insertReplacementText": {
        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);
        break;
      }
      case "insertFromComposition": {
        $setCompositionKey(null);
        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);
        break;
      }
      case "insertLineBreak": {
        $setCompositionKey(null);
        dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);
        break;
      }
      case "insertParagraph": {
        $setCompositionKey(null);
        if (isInsertLineBreak && !IS_IOS) {
          isInsertLineBreak = false;
          dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);
        } else {
          dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, void 0);
        }
        break;
      }
      case "insertFromPaste":
      case "insertFromPasteAsQuotation": {
        dispatchCommand(editor, PASTE_COMMAND, event);
        break;
      }
      case "deleteByComposition": {
        if ($canRemoveText(anchorNode, focusNode)) {
          dispatchCommand(editor, REMOVE_TEXT_COMMAND, event);
        }
        break;
      }
      case "deleteByDrag":
      case "deleteByCut": {
        dispatchCommand(editor, REMOVE_TEXT_COMMAND, event);
        break;
      }
      case "deleteContent": {
        dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);
        break;
      }
      case "deleteWordBackward": {
        dispatchCommand(editor, DELETE_WORD_COMMAND, true);
        break;
      }
      case "deleteWordForward": {
        dispatchCommand(editor, DELETE_WORD_COMMAND, false);
        break;
      }
      case "deleteHardLineBackward":
      case "deleteSoftLineBackward": {
        dispatchCommand(editor, DELETE_LINE_COMMAND, true);
        break;
      }
      case "deleteContentForward":
      case "deleteHardLineForward":
      case "deleteSoftLineForward": {
        dispatchCommand(editor, DELETE_LINE_COMMAND, false);
        break;
      }
      case "formatStrikeThrough": {
        dispatchCommand(editor, FORMAT_TEXT_COMMAND, "strikethrough");
        break;
      }
      case "formatBold": {
        dispatchCommand(editor, FORMAT_TEXT_COMMAND, "bold");
        break;
      }
      case "formatItalic": {
        dispatchCommand(editor, FORMAT_TEXT_COMMAND, "italic");
        break;
      }
      case "formatUnderline": {
        dispatchCommand(editor, FORMAT_TEXT_COMMAND, "underline");
        break;
      }
      case "historyUndo": {
        dispatchCommand(editor, UNDO_COMMAND, void 0);
        break;
      }
      case "historyRedo": {
        dispatchCommand(editor, REDO_COMMAND, void 0);
        break;
      }
    }
  });
}
function onInput(event, editor) {
  event.stopPropagation();
  updateEditor(editor, () => {
    const selection = $getSelection();
    const data = event.data;
    const targetRange = getTargetRange(event);
    if (data != null && $isRangeSelection(selection) && $shouldPreventDefaultAndInsertText(selection, targetRange, data, event.timeStamp, false)) {
      if (isFirefoxEndingComposition) {
        onCompositionEndImpl(editor, data);
        isFirefoxEndingComposition = false;
      }
      const anchor = selection.anchor;
      const anchorNode = anchor.getNode();
      const domSelection = getDOMSelection(editor._window);
      if (domSelection === null) {
        return;
      }
      const offset = anchor.offset;
      if (!CAN_USE_BEFORE_INPUT || selection.isCollapsed() || !$isTextNode(anchorNode) || domSelection.anchorNode === null || anchorNode.getTextContent().slice(0, offset) + data + anchorNode.getTextContent().slice(offset + selection.focus.offset) !== getAnchorTextFromDOM(domSelection.anchorNode)) {
        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);
      }
      const textLength = data.length;
      if (IS_FIREFOX && textLength > 1 && event.inputType === "insertCompositionText" && !editor.isComposing()) {
        selection.anchor.offset -= textLength;
      }
      if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT && editor.isComposing()) {
        lastKeyDownTimeStamp = 0;
        $setCompositionKey(null);
      }
    } else {
      const characterData = data !== null ? data : void 0;
      $updateSelectedTextFromDOM(false, editor, characterData);
      if (isFirefoxEndingComposition) {
        onCompositionEndImpl(editor, data || void 0);
        isFirefoxEndingComposition = false;
      }
    }
    $flushMutations();
  });
  unprocessedBeforeInputData = null;
}
function onCompositionStart(event, editor) {
  updateEditor(editor, () => {
    const selection = $getSelection();
    if ($isRangeSelection(selection) && !editor.isComposing()) {
      const anchor = selection.anchor;
      const node = selection.anchor.getNode();
      $setCompositionKey(anchor.key);
      if (
        // If it has been 30ms since the last keydown, then we should
        // apply the empty space heuristic. We can't do this for Safari,
        // as the keydown fires after composition start.
        event.timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY || // FF has issues around composing multibyte characters, so we also
        // need to invoke the empty space heuristic below.
        anchor.type === "element" || !selection.isCollapsed() || node.getFormat() !== selection.format || $isTextNode(node) && node.getStyle() !== selection.style
      ) {
        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, COMPOSITION_START_CHAR);
      }
    }
  });
}
function onCompositionEndImpl(editor, data) {
  const compositionKey = editor._compositionKey;
  $setCompositionKey(null);
  if (compositionKey !== null && data != null) {
    if (data === "") {
      const node = $getNodeByKey(compositionKey);
      const textNode = getDOMTextNode(editor.getElementByKey(compositionKey));
      if (textNode !== null && textNode.nodeValue !== null && $isTextNode(node)) {
        $updateTextNodeFromDOMContent(node, textNode.nodeValue, null, null, true);
      }
      return;
    }
    if (data[data.length - 1] === "\n") {
      const selection = $getSelection();
      if ($isRangeSelection(selection)) {
        const focus = selection.focus;
        selection.anchor.set(focus.key, focus.offset, focus.type);
        dispatchCommand(editor, KEY_ENTER_COMMAND, null);
        return;
      }
    }
  }
  $updateSelectedTextFromDOM(true, editor, data);
}
function onCompositionEnd(event, editor) {
  if (IS_FIREFOX) {
    isFirefoxEndingComposition = true;
  } else {
    updateEditor(editor, () => {
      onCompositionEndImpl(editor, event.data);
    });
  }
}
function onKeyDown(event, editor) {
  lastKeyDownTimeStamp = event.timeStamp;
  lastKeyCode = event.keyCode;
  if (editor.isComposing()) {
    return;
  }
  const {
    keyCode,
    shiftKey,
    ctrlKey,
    metaKey,
    altKey
  } = event;
  if (dispatchCommand(editor, KEY_DOWN_COMMAND, event)) {
    return;
  }
  if (isMoveForward(keyCode, ctrlKey, altKey, metaKey)) {
    dispatchCommand(editor, KEY_ARROW_RIGHT_COMMAND, event);
  } else if (isMoveToEnd(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {
    dispatchCommand(editor, MOVE_TO_END, event);
  } else if (isMoveBackward(keyCode, ctrlKey, altKey, metaKey)) {
    dispatchCommand(editor, KEY_ARROW_LEFT_COMMAND, event);
  } else if (isMoveToStart(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {
    dispatchCommand(editor, MOVE_TO_START, event);
  } else if (isMoveUp(keyCode, ctrlKey, metaKey)) {
    dispatchCommand(editor, KEY_ARROW_UP_COMMAND, event);
  } else if (isMoveDown(keyCode, ctrlKey, metaKey)) {
    dispatchCommand(editor, KEY_ARROW_DOWN_COMMAND, event);
  } else if (isLineBreak(keyCode, shiftKey)) {
    isInsertLineBreak = true;
    dispatchCommand(editor, KEY_ENTER_COMMAND, event);
  } else if (isSpace(keyCode)) {
    dispatchCommand(editor, KEY_SPACE_COMMAND, event);
  } else if (isOpenLineBreak(keyCode, ctrlKey)) {
    event.preventDefault();
    isInsertLineBreak = true;
    dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, true);
  } else if (isParagraph(keyCode, shiftKey)) {
    isInsertLineBreak = false;
    dispatchCommand(editor, KEY_ENTER_COMMAND, event);
  } else if (isDeleteBackward(keyCode, altKey, metaKey, ctrlKey)) {
    if (isBackspace(keyCode)) {
      dispatchCommand(editor, KEY_BACKSPACE_COMMAND, event);
    } else {
      event.preventDefault();
      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);
    }
  } else if (isEscape(keyCode)) {
    dispatchCommand(editor, KEY_ESCAPE_COMMAND, event);
  } else if (isDeleteForward(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {
    if (isDelete(keyCode)) {
      dispatchCommand(editor, KEY_DELETE_COMMAND, event);
    } else {
      event.preventDefault();
      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);
    }
  } else if (isDeleteWordBackward(keyCode, altKey, ctrlKey)) {
    event.preventDefault();
    dispatchCommand(editor, DELETE_WORD_COMMAND, true);
  } else if (isDeleteWordForward(keyCode, altKey, ctrlKey)) {
    event.preventDefault();
    dispatchCommand(editor, DELETE_WORD_COMMAND, false);
  } else if (isDeleteLineBackward(keyCode, metaKey)) {
    event.preventDefault();
    dispatchCommand(editor, DELETE_LINE_COMMAND, true);
  } else if (isDeleteLineForward(keyCode, metaKey)) {
    event.preventDefault();
    dispatchCommand(editor, DELETE_LINE_COMMAND, false);
  } else if (isBold(keyCode, altKey, metaKey, ctrlKey)) {
    event.preventDefault();
    dispatchCommand(editor, FORMAT_TEXT_COMMAND, "bold");
  } else if (isUnderline(keyCode, altKey, metaKey, ctrlKey)) {
    event.preventDefault();
    dispatchCommand(editor, FORMAT_TEXT_COMMAND, "underline");
  } else if (isItalic(keyCode, altKey, metaKey, ctrlKey)) {
    event.preventDefault();
    dispatchCommand(editor, FORMAT_TEXT_COMMAND, "italic");
  } else if (isTab(keyCode, altKey, ctrlKey, metaKey)) {
    dispatchCommand(editor, KEY_TAB_COMMAND, event);
  } else if (isUndo(keyCode, shiftKey, metaKey, ctrlKey)) {
    event.preventDefault();
    dispatchCommand(editor, UNDO_COMMAND, void 0);
  } else if (isRedo(keyCode, shiftKey, metaKey, ctrlKey)) {
    event.preventDefault();
    dispatchCommand(editor, REDO_COMMAND, void 0);
  } else {
    const prevSelection = editor._editorState._selection;
    if ($isNodeSelection(prevSelection)) {
      if (isCopy(keyCode, shiftKey, metaKey, ctrlKey)) {
        event.preventDefault();
        dispatchCommand(editor, COPY_COMMAND, event);
      } else if (isCut(keyCode, shiftKey, metaKey, ctrlKey)) {
        event.preventDefault();
        dispatchCommand(editor, CUT_COMMAND, event);
      } else if (isSelectAll(keyCode, metaKey, ctrlKey)) {
        event.preventDefault();
        dispatchCommand(editor, SELECT_ALL_COMMAND, event);
      }
    } else if (!IS_FIREFOX && isSelectAll(keyCode, metaKey, ctrlKey)) {
      event.preventDefault();
      dispatchCommand(editor, SELECT_ALL_COMMAND, event);
    }
  }
  if (isModifier(ctrlKey, shiftKey, altKey, metaKey)) {
    dispatchCommand(editor, KEY_MODIFIER_COMMAND, event);
  }
}
function getRootElementRemoveHandles(rootElement) {
  let eventHandles = rootElement.__lexicalEventHandles;
  if (eventHandles === void 0) {
    eventHandles = [];
    rootElement.__lexicalEventHandles = eventHandles;
  }
  return eventHandles;
}
var activeNestedEditorsMap = /* @__PURE__ */ new Map();
function onDocumentSelectionChange(event) {
  const target = event.target;
  const targetWindow = target == null ? null : target.nodeType === 9 ? target.defaultView : target.ownerDocument.defaultView;
  const domSelection = getDOMSelection(targetWindow);
  if (domSelection === null) {
    return;
  }
  const nextActiveEditor = getNearestEditorFromDOMNode(domSelection.anchorNode);
  if (nextActiveEditor === null) {
    return;
  }
  if (isSelectionChangeFromMouseDown) {
    isSelectionChangeFromMouseDown = false;
    updateEditor(nextActiveEditor, () => {
      const lastSelection = $getPreviousSelection();
      const domAnchorNode = domSelection.anchorNode;
      if (domAnchorNode === null) {
        return;
      }
      const nodeType = domAnchorNode.nodeType;
      if (nodeType !== DOM_ELEMENT_TYPE && nodeType !== DOM_TEXT_TYPE) {
        return;
      }
      const newSelection = internalCreateRangeSelection(lastSelection, domSelection, nextActiveEditor, event);
      $setSelection(newSelection);
    });
  }
  const editors = getEditorsToPropagate(nextActiveEditor);
  const rootEditor = editors[editors.length - 1];
  const rootEditorKey = rootEditor._key;
  const activeNestedEditor = activeNestedEditorsMap.get(rootEditorKey);
  const prevActiveEditor = activeNestedEditor || rootEditor;
  if (prevActiveEditor !== nextActiveEditor) {
    onSelectionChange(domSelection, prevActiveEditor, false);
  }
  onSelectionChange(domSelection, nextActiveEditor, true);
  if (nextActiveEditor !== rootEditor) {
    activeNestedEditorsMap.set(rootEditorKey, nextActiveEditor);
  } else if (activeNestedEditor) {
    activeNestedEditorsMap.delete(rootEditorKey);
  }
}
function stopLexicalPropagation(event) {
  event._lexicalHandled = true;
}
function hasStoppedLexicalPropagation(event) {
  const stopped = event._lexicalHandled === true;
  return stopped;
}
function addRootElementEvents(rootElement, editor) {
  const doc = rootElement.ownerDocument;
  const documentRootElementsCount = rootElementsRegistered.get(doc);
  if (documentRootElementsCount === void 0) {
    doc.addEventListener("selectionchange", onDocumentSelectionChange);
  }
  rootElementsRegistered.set(doc, documentRootElementsCount || 0 + 1);
  rootElement.__lexicalEditor = editor;
  const removeHandles = getRootElementRemoveHandles(rootElement);
  for (let i2 = 0; i2 < rootElementEvents.length; i2++) {
    const [eventName, onEvent] = rootElementEvents[i2];
    const eventHandler = typeof onEvent === "function" ? (event) => {
      if (hasStoppedLexicalPropagation(event)) {
        return;
      }
      stopLexicalPropagation(event);
      if (editor.isEditable() || eventName === "click") {
        onEvent(event, editor);
      }
    } : (event) => {
      if (hasStoppedLexicalPropagation(event)) {
        return;
      }
      stopLexicalPropagation(event);
      if (editor.isEditable()) {
        switch (eventName) {
          case "cut":
            return dispatchCommand(editor, CUT_COMMAND, event);
          case "copy":
            return dispatchCommand(editor, COPY_COMMAND, event);
          case "paste":
            return dispatchCommand(editor, PASTE_COMMAND, event);
          case "dragstart":
            return dispatchCommand(editor, DRAGSTART_COMMAND, event);
          case "dragover":
            return dispatchCommand(editor, DRAGOVER_COMMAND, event);
          case "dragend":
            return dispatchCommand(editor, DRAGEND_COMMAND, event);
          case "focus":
            return dispatchCommand(editor, FOCUS_COMMAND, event);
          case "blur": {
            return dispatchCommand(editor, BLUR_COMMAND, event);
          }
          case "drop":
            return dispatchCommand(editor, DROP_COMMAND, event);
        }
      }
    };
    rootElement.addEventListener(eventName, eventHandler);
    removeHandles.push(() => {
      rootElement.removeEventListener(eventName, eventHandler);
    });
  }
}
function removeRootElementEvents(rootElement) {
  const doc = rootElement.ownerDocument;
  const documentRootElementsCount = rootElementsRegistered.get(doc);
  if (!(documentRootElementsCount !== void 0)) {
    throw Error(`Root element not registered`);
  }
  rootElementsRegistered.set(doc, documentRootElementsCount - 1);
  if (documentRootElementsCount === 1) {
    doc.removeEventListener("selectionchange", onDocumentSelectionChange);
  }
  const editor = rootElement.__lexicalEditor;
  if (editor !== null && editor !== void 0) {
    cleanActiveNestedEditorsMap(editor);
    rootElement.__lexicalEditor = null;
  }
  const removeHandles = getRootElementRemoveHandles(rootElement);
  for (let i2 = 0; i2 < removeHandles.length; i2++) {
    removeHandles[i2]();
  }
  rootElement.__lexicalEventHandles = [];
}
function cleanActiveNestedEditorsMap(editor) {
  if (editor._parentEditor !== null) {
    const editors = getEditorsToPropagate(editor);
    const rootEditor = editors[editors.length - 1];
    const rootEditorKey = rootEditor._key;
    if (activeNestedEditorsMap.get(rootEditorKey) === editor) {
      activeNestedEditorsMap.delete(rootEditorKey);
    }
  } else {
    activeNestedEditorsMap.delete(editor._key);
  }
}
function markSelectionChangeFromDOMUpdate() {
  isSelectionChangeFromDOMUpdate = true;
}
function markCollapsedSelectionFormat(format, style, offset, key, timeStamp) {
  collapsedSelectionFormat = [format, style, offset, key, timeStamp];
}
function removeNode(nodeToRemove, restoreSelection, preserveEmptyParent) {
  errorOnReadOnly();
  const key = nodeToRemove.__key;
  const parent = nodeToRemove.getParent();
  if (parent === null) {
    return;
  }
  const selection = $maybeMoveChildrenSelectionToParent(nodeToRemove);
  let selectionMoved = false;
  if ($isRangeSelection(selection) && restoreSelection) {
    const anchor = selection.anchor;
    const focus = selection.focus;
    if (anchor.key === key) {
      moveSelectionPointToSibling(anchor, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());
      selectionMoved = true;
    }
    if (focus.key === key) {
      moveSelectionPointToSibling(focus, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());
      selectionMoved = true;
    }
  } else if ($isNodeSelection(selection) && restoreSelection && nodeToRemove.isSelected()) {
    nodeToRemove.selectPrevious();
  }
  if ($isRangeSelection(selection) && restoreSelection && !selectionMoved) {
    const index = nodeToRemove.getIndexWithinParent();
    removeFromParent(nodeToRemove);
    $updateElementSelectionOnCreateDeleteNode(selection, parent, index, -1);
  } else {
    removeFromParent(nodeToRemove);
  }
  if (!preserveEmptyParent && !$isRootOrShadowRoot(parent) && !parent.canBeEmpty() && parent.isEmpty()) {
    removeNode(parent, restoreSelection);
  }
  if (restoreSelection && $isRootNode(parent) && parent.isEmpty()) {
    parent.selectEnd();
  }
}
var LexicalNode = class {
  // Allow us to look up the type including static props
  /** @internal */
  /** @internal */
  //@ts-ignore We set the key in the constructor.
  /** @internal */
  /** @internal */
  /** @internal */
  // Flow doesn't support abstract classes unfortunately, so we can't _force_
  // subclasses of Node to implement statics. All subclasses of Node should have
  // a static getType and clone method though. We define getType and clone here so we can call it
  // on any  Node, and we throw this error by default since the subclass should provide
  // their own implementation.
  /**
   * Returns the string type of this node. Every node must
   * implement this and it MUST BE UNIQUE amongst nodes registered
   * on the editor.
   *
   */
  static getType() {
    {
      throw Error(`LexicalNode: Node ${this.name} does not implement .getType().`);
    }
  }
  /**
   * Clones this node, creating a new node with a different key
   * and adding it to the EditorState (but not attaching it anywhere!). All nodes must
   * implement this method.
   *
   */
  static clone(_data) {
    {
      throw Error(`LexicalNode: Node ${this.name} does not implement .clone().`);
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  constructor(key) {
    this.__type = this.constructor.getType();
    this.__parent = null;
    this.__prev = null;
    this.__next = null;
    $setNodeKey(this, key);
    {
      if (this.__type !== "root") {
        errorOnReadOnly();
        errorOnTypeKlassMismatch(this.__type, this.constructor);
      }
    }
  }
  // Getters and Traversers
  /**
   * Returns the string type of this node.
   */
  getType() {
    return this.__type;
  }
  isInline() {
    {
      throw Error(`LexicalNode: Node ${this.constructor.name} does not implement .isInline().`);
    }
  }
  /**
   * Returns true if there is a path between this node and the RootNode, false otherwise.
   * This is a way of determining if the node is "attached" EditorState. Unattached nodes
   * won't be reconciled and will ultimatelt be cleaned up by the Lexical GC.
   */
  isAttached() {
    let nodeKey = this.__key;
    while (nodeKey !== null) {
      if (nodeKey === "root") {
        return true;
      }
      const node = $getNodeByKey(nodeKey);
      if (node === null) {
        break;
      }
      nodeKey = node.__parent;
    }
    return false;
  }
  /**
   * Returns true if this node is contained within the provided Selection., false otherwise.
   * Relies on the algorithms implemented in {@link BaseSelection.getNodes} to determine
   * what's included.
   *
   * @param selection - The selection that we want to determine if the node is in.
   */
  isSelected(selection) {
    const targetSelection = selection || $getSelection();
    if (targetSelection == null) {
      return false;
    }
    const isSelected = targetSelection.getNodes().some((n) => n.__key === this.__key);
    if ($isTextNode(this)) {
      return isSelected;
    }
    if ($isRangeSelection(targetSelection) && targetSelection.anchor.type === "element" && targetSelection.focus.type === "element" && targetSelection.anchor.key === targetSelection.focus.key && targetSelection.anchor.offset === targetSelection.focus.offset) {
      return false;
    }
    return isSelected;
  }
  /**
   * Returns this nodes key.
   */
  getKey() {
    return this.__key;
  }
  /**
   * Returns the zero-based index of this node within the parent.
   */
  getIndexWithinParent() {
    const parent = this.getParent();
    if (parent === null) {
      return -1;
    }
    let node = parent.getFirstChild();
    let index = 0;
    while (node !== null) {
      if (this.is(node)) {
        return index;
      }
      index++;
      node = node.getNextSibling();
    }
    return -1;
  }
  /**
   * Returns the parent of this node, or null if none is found.
   */
  getParent() {
    const parent = this.getLatest().__parent;
    if (parent === null) {
      return null;
    }
    return $getNodeByKey(parent);
  }
  /**
   * Returns the parent of this node, or throws if none is found.
   */
  getParentOrThrow() {
    const parent = this.getParent();
    if (parent === null) {
      {
        throw Error(`Expected node ${this.__key} to have a parent.`);
      }
    }
    return parent;
  }
  /**
   * Returns the highest (in the EditorState tree)
   * non-root ancestor of this node, or null if none is found. See {@link lexical!$isRootOrShadowRoot}
   * for more information on which Elements comprise "roots".
   */
  getTopLevelElement() {
    let node = this;
    while (node !== null) {
      const parent = node.getParent();
      if ($isRootOrShadowRoot(parent)) {
        if (!$isElementNode(node)) {
          throw Error(`Children of root nodes must be elements`);
        }
        return node;
      }
      node = parent;
    }
    return null;
  }
  /**
   * Returns the highest (in the EditorState tree)
   * non-root ancestor of this node, or throws if none is found. See {@link lexical!$isRootOrShadowRoot}
   * for more information on which Elements comprise "roots".
   */
  getTopLevelElementOrThrow() {
    const parent = this.getTopLevelElement();
    if (parent === null) {
      {
        throw Error(`Expected node ${this.__key} to have a top parent element.`);
      }
    }
    return parent;
  }
  /**
   * Returns a list of the every ancestor of this node,
   * all the way up to the RootNode.
   *
   */
  getParents() {
    const parents = [];
    let node = this.getParent();
    while (node !== null) {
      parents.push(node);
      node = node.getParent();
    }
    return parents;
  }
  /**
   * Returns a list of the keys of every ancestor of this node,
   * all the way up to the RootNode.
   *
   */
  getParentKeys() {
    const parents = [];
    let node = this.getParent();
    while (node !== null) {
      parents.push(node.__key);
      node = node.getParent();
    }
    return parents;
  }
  /**
   * Returns the "previous" siblings - that is, the node that comes
   * before this one in the same parent.
   *
   */
  getPreviousSibling() {
    const self = this.getLatest();
    const prevKey = self.__prev;
    return prevKey === null ? null : $getNodeByKey(prevKey);
  }
  /**
   * Returns the "previous" siblings - that is, the nodes that come between
   * this one and the first child of it's parent, inclusive.
   *
   */
  getPreviousSiblings() {
    const siblings = [];
    const parent = this.getParent();
    if (parent === null) {
      return siblings;
    }
    let node = parent.getFirstChild();
    while (node !== null) {
      if (node.is(this)) {
        break;
      }
      siblings.push(node);
      node = node.getNextSibling();
    }
    return siblings;
  }
  /**
   * Returns the "next" siblings - that is, the node that comes
   * after this one in the same parent
   *
   */
  getNextSibling() {
    const self = this.getLatest();
    const nextKey = self.__next;
    return nextKey === null ? null : $getNodeByKey(nextKey);
  }
  /**
   * Returns all "next" siblings - that is, the nodes that come between this
   * one and the last child of it's parent, inclusive.
   *
   */
  getNextSiblings() {
    const siblings = [];
    let node = this.getNextSibling();
    while (node !== null) {
      siblings.push(node);
      node = node.getNextSibling();
    }
    return siblings;
  }
  /**
   * Returns the closest common ancestor of this node and the provided one or null
   * if one cannot be found.
   *
   * @param node - the other node to find the common ancestor of.
   */
  getCommonAncestor(node) {
    const a2 = this.getParents();
    const b2 = node.getParents();
    if ($isElementNode(this)) {
      a2.unshift(this);
    }
    if ($isElementNode(node)) {
      b2.unshift(node);
    }
    const aLength = a2.length;
    const bLength = b2.length;
    if (aLength === 0 || bLength === 0 || a2[aLength - 1] !== b2[bLength - 1]) {
      return null;
    }
    const bSet = new Set(b2);
    for (let i2 = 0; i2 < aLength; i2++) {
      const ancestor = a2[i2];
      if (bSet.has(ancestor)) {
        return ancestor;
      }
    }
    return null;
  }
  /**
   * Returns true if the provided node is the exact same one as this node, from Lexical's perspective.
   * Always use this instead of referential equality.
   *
   * @param object - the node to perform the equality comparison on.
   */
  is(object) {
    if (object == null) {
      return false;
    }
    return this.__key === object.__key;
  }
  /**
   * Returns true if this node logical precedes the target node in the editor state.
   *
   * @param targetNode - the node we're testing to see if it's after this one.
   */
  isBefore(targetNode) {
    if (this === targetNode) {
      return false;
    }
    if (targetNode.isParentOf(this)) {
      return true;
    }
    if (this.isParentOf(targetNode)) {
      return false;
    }
    const commonAncestor = this.getCommonAncestor(targetNode);
    let indexA = 0;
    let indexB = 0;
    let node = this;
    while (true) {
      const parent = node.getParentOrThrow();
      if (parent === commonAncestor) {
        indexA = node.getIndexWithinParent();
        break;
      }
      node = parent;
    }
    node = targetNode;
    while (true) {
      const parent = node.getParentOrThrow();
      if (parent === commonAncestor) {
        indexB = node.getIndexWithinParent();
        break;
      }
      node = parent;
    }
    return indexA < indexB;
  }
  /**
   * Returns true if this node is the parent of the target node, false otherwise.
   *
   * @param targetNode - the would-be child node.
   */
  isParentOf(targetNode) {
    const key = this.__key;
    if (key === targetNode.__key) {
      return false;
    }
    let node = targetNode;
    while (node !== null) {
      if (node.__key === key) {
        return true;
      }
      node = node.getParent();
    }
    return false;
  }
  // TO-DO: this function can be simplified a lot
  /**
   * Returns a list of nodes that are between this node and
   * the target node in the EditorState.
   *
   * @param targetNode - the node that marks the other end of the range of nodes to be returned.
   */
  getNodesBetween(targetNode) {
    const isBefore = this.isBefore(targetNode);
    const nodes = [];
    const visited = /* @__PURE__ */ new Set();
    let node = this;
    while (true) {
      if (node === null) {
        break;
      }
      const key = node.__key;
      if (!visited.has(key)) {
        visited.add(key);
        nodes.push(node);
      }
      if (node === targetNode) {
        break;
      }
      const child = $isElementNode(node) ? isBefore ? node.getFirstChild() : node.getLastChild() : null;
      if (child !== null) {
        node = child;
        continue;
      }
      const nextSibling = isBefore ? node.getNextSibling() : node.getPreviousSibling();
      if (nextSibling !== null) {
        node = nextSibling;
        continue;
      }
      const parent = node.getParentOrThrow();
      if (!visited.has(parent.__key)) {
        nodes.push(parent);
      }
      if (parent === targetNode) {
        break;
      }
      let parentSibling = null;
      let ancestor = parent;
      do {
        if (ancestor === null) {
          {
            throw Error(`getNodesBetween: ancestor is null`);
          }
        }
        parentSibling = isBefore ? ancestor.getNextSibling() : ancestor.getPreviousSibling();
        ancestor = ancestor.getParent();
        if (ancestor !== null) {
          if (parentSibling === null && !visited.has(ancestor.__key)) {
            nodes.push(ancestor);
          }
        } else {
          break;
        }
      } while (parentSibling === null);
      node = parentSibling;
    }
    if (!isBefore) {
      nodes.reverse();
    }
    return nodes;
  }
  /**
   * Returns true if this node has been marked dirty during this update cycle.
   *
   */
  isDirty() {
    const editor = getActiveEditor();
    const dirtyLeaves = editor._dirtyLeaves;
    return dirtyLeaves !== null && dirtyLeaves.has(this.__key);
  }
  /**
   * Returns the latest version of the node from the active EditorState.
   * This is used to avoid getting values from stale node references.
   *
   */
  getLatest() {
    const latest = $getNodeByKey(this.__key);
    if (latest === null) {
      {
        throw Error(`Lexical node does not exist in active editor state. Avoid using the same node references between nested closures from editorState.read/editor.update.`);
      }
    }
    return latest;
  }
  /**
   * Returns a mutable version of the node. Will throw an error if
   * called outside of a Lexical Editor {@link LexicalEditor.update} callback.
   *
   */
  getWritable() {
    errorOnReadOnly();
    const editorState = getActiveEditorState();
    const editor = getActiveEditor();
    const nodeMap = editorState._nodeMap;
    const key = this.__key;
    const latestNode = this.getLatest();
    const parent = latestNode.__parent;
    const cloneNotNeeded = editor._cloneNotNeeded;
    const selection = $getSelection();
    if (selection !== null) {
      selection.setCachedNodes(null);
    }
    if (cloneNotNeeded.has(key)) {
      internalMarkNodeAsDirty(latestNode);
      return latestNode;
    }
    const constructor = latestNode.constructor;
    const mutableNode = constructor.clone(latestNode);
    mutableNode.__parent = parent;
    mutableNode.__next = latestNode.__next;
    mutableNode.__prev = latestNode.__prev;
    if ($isElementNode(latestNode) && $isElementNode(mutableNode)) {
      mutableNode.__first = latestNode.__first;
      mutableNode.__last = latestNode.__last;
      mutableNode.__size = latestNode.__size;
      mutableNode.__indent = latestNode.__indent;
      mutableNode.__format = latestNode.__format;
      mutableNode.__dir = latestNode.__dir;
    } else if ($isTextNode(latestNode) && $isTextNode(mutableNode)) {
      mutableNode.__format = latestNode.__format;
      mutableNode.__style = latestNode.__style;
      mutableNode.__mode = latestNode.__mode;
      mutableNode.__detail = latestNode.__detail;
    }
    cloneNotNeeded.add(key);
    mutableNode.__key = key;
    internalMarkNodeAsDirty(mutableNode);
    nodeMap.set(key, mutableNode);
    return mutableNode;
  }
  /**
   * Returns the text content of the node. Override this for
   * custom nodes that should have a representation in plain text
   * format (for copy + paste, for example)
   *
   */
  getTextContent() {
    return "";
  }
  /**
   * Returns the length of the string produced by calling getTextContent on this node.
   *
   */
  getTextContentSize() {
    return this.getTextContent().length;
  }
  // View
  /**
   * Called during the reconciliation process to determine which nodes
   * to insert into the DOM for this Lexical Node.
   *
   * This method must return exactly one HTMLElement. Nested elements are not supported.
   *
   * Do not attempt to update the Lexical EditorState during this phase of the update lifecyle.
   *
   * @param _config - allows access to things like the EditorTheme (to apply classes) during reconciliation.
   * @param _editor - allows access to the editor for context during reconciliation.
   *
   * */
  createDOM(_config, _editor) {
    {
      throw Error(`createDOM: base method not extended`);
    }
  }
  /**
   * Called when a node changes and should update the DOM
   * in whatever way is necessary to make it align with any changes that might
   * have happened during the update.
   *
   * Returning "true" here will cause lexical to unmount and recreate the DOM node
   * (by calling createDOM). You would need to do this if the element tag changes,
   * for instance.
   *
   * */
  updateDOM(_prevNode, _dom, _config) {
    {
      throw Error(`updateDOM: base method not extended`);
    }
  }
  /**
   * Controls how the this node is serialized to HTML. This is important for
   * copy and paste between Lexical and non-Lexical editors, or Lexical editors with different namespaces,
   * in which case the primary transfer format is HTML. It's also important if you're serializing
   * to HTML for any other reason via {@link @lexical/html!$generateHtmlFromNodes}. You could
   * also use this method to build your own HTML renderer.
   *
   * */
  exportDOM(editor) {
    const element = this.createDOM(editor._config, editor);
    return {
      element
    };
  }
  /**
   * Controls how the this node is serialized to JSON. This is important for
   * copy and paste between Lexical editors sharing the same namespace. It's also important
   * if you're serializing to JSON for persistent storage somewhere.
   * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).
   *
   * */
  exportJSON() {
    {
      throw Error(`exportJSON: base method not extended`);
    }
  }
  /**
   * Controls how the this node is deserialized from JSON. This is usually boilerplate,
   * but provides an abstraction between the node implementation and serialized interface that can
   * be important if you ever make breaking changes to a node schema (by adding or removing properties).
   * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).
   *
   * */
  static importJSON(_serializedNode) {
    {
      throw Error(`LexicalNode: Node ${this.name} does not implement .importJSON().`);
    }
  }
  /**
   * @experimental
   *
   * Registers the returned function as a transform on the node during
   * Editor initialization. Most such use cases should be addressed via
   * the {@link LexicalEditor.registerNodeTransform} API.
   *
   * Experimental - use at your own risk.
   */
  static transform() {
    return null;
  }
  // Setters and mutators
  /**
   * Removes this LexicalNode from the EditorState. If the node isn't re-inserted
   * somewhere, the Lexical garbage collector will eventually clean it up.
   *
   * @param preserveEmptyParent - If falsy, the node's parent will be removed if
   * it's empty after the removal operation. This is the default behavior, subject to
   * other node heuristics such as {@link ElementNode#canBeEmpty}
   * */
  remove(preserveEmptyParent) {
    removeNode(this, true, preserveEmptyParent);
  }
  /**
   * Replaces this LexicalNode with the provided node, optionally transferring the children
   * of the replaced node to the replacing node.
   *
   * @param replaceWith - The node to replace this one with.
   * @param includeChildren - Whether or not to transfer the children of this node to the replacing node.
   * */
  replace(replaceWith, includeChildren) {
    errorOnReadOnly();
    let selection = $getSelection();
    if (selection !== null) {
      selection = selection.clone();
    }
    errorOnInsertTextNodeOnRoot(this, replaceWith);
    const self = this.getLatest();
    const toReplaceKey = this.__key;
    const key = replaceWith.__key;
    const writableReplaceWith = replaceWith.getWritable();
    const writableParent = this.getParentOrThrow().getWritable();
    const size = writableParent.__size;
    removeFromParent(writableReplaceWith);
    const prevSibling = self.getPreviousSibling();
    const nextSibling = self.getNextSibling();
    const prevKey = self.__prev;
    const nextKey = self.__next;
    const parentKey = self.__parent;
    removeNode(self, false, true);
    if (prevSibling === null) {
      writableParent.__first = key;
    } else {
      const writablePrevSibling = prevSibling.getWritable();
      writablePrevSibling.__next = key;
    }
    writableReplaceWith.__prev = prevKey;
    if (nextSibling === null) {
      writableParent.__last = key;
    } else {
      const writableNextSibling = nextSibling.getWritable();
      writableNextSibling.__prev = key;
    }
    writableReplaceWith.__next = nextKey;
    writableReplaceWith.__parent = parentKey;
    writableParent.__size = size;
    if (includeChildren) {
      if (!($isElementNode(this) && $isElementNode(writableReplaceWith))) {
        throw Error(`includeChildren should only be true for ElementNodes`);
      }
      this.getChildren().forEach((child) => {
        writableReplaceWith.append(child);
      });
    }
    if ($isRangeSelection(selection)) {
      $setSelection(selection);
      const anchor = selection.anchor;
      const focus = selection.focus;
      if (anchor.key === toReplaceKey) {
        $moveSelectionPointToEnd(anchor, writableReplaceWith);
      }
      if (focus.key === toReplaceKey) {
        $moveSelectionPointToEnd(focus, writableReplaceWith);
      }
    }
    if ($getCompositionKey() === toReplaceKey) {
      $setCompositionKey(key);
    }
    return writableReplaceWith;
  }
  /**
   * Inserts a node after this LexicalNode (as the next sibling).
   *
   * @param nodeToInsert - The node to insert after this one.
   * @param restoreSelection - Whether or not to attempt to resolve the
   * selection to the appropriate place after the operation is complete.
   * */
  insertAfter(nodeToInsert, restoreSelection = true) {
    errorOnReadOnly();
    errorOnInsertTextNodeOnRoot(this, nodeToInsert);
    const writableSelf = this.getWritable();
    const writableNodeToInsert = nodeToInsert.getWritable();
    const oldParent = writableNodeToInsert.getParent();
    const selection = $getSelection();
    let elementAnchorSelectionOnNode = false;
    let elementFocusSelectionOnNode = false;
    if (oldParent !== null) {
      const oldIndex = nodeToInsert.getIndexWithinParent();
      removeFromParent(writableNodeToInsert);
      if ($isRangeSelection(selection)) {
        const oldParentKey = oldParent.__key;
        const anchor = selection.anchor;
        const focus = selection.focus;
        elementAnchorSelectionOnNode = anchor.type === "element" && anchor.key === oldParentKey && anchor.offset === oldIndex + 1;
        elementFocusSelectionOnNode = focus.type === "element" && focus.key === oldParentKey && focus.offset === oldIndex + 1;
      }
    }
    const nextSibling = this.getNextSibling();
    const writableParent = this.getParentOrThrow().getWritable();
    const insertKey = writableNodeToInsert.__key;
    const nextKey = writableSelf.__next;
    if (nextSibling === null) {
      writableParent.__last = insertKey;
    } else {
      const writableNextSibling = nextSibling.getWritable();
      writableNextSibling.__prev = insertKey;
    }
    writableParent.__size++;
    writableSelf.__next = insertKey;
    writableNodeToInsert.__next = nextKey;
    writableNodeToInsert.__prev = writableSelf.__key;
    writableNodeToInsert.__parent = writableSelf.__parent;
    if (restoreSelection && $isRangeSelection(selection)) {
      const index = this.getIndexWithinParent();
      $updateElementSelectionOnCreateDeleteNode(selection, writableParent, index + 1);
      const writableParentKey = writableParent.__key;
      if (elementAnchorSelectionOnNode) {
        selection.anchor.set(writableParentKey, index + 2, "element");
      }
      if (elementFocusSelectionOnNode) {
        selection.focus.set(writableParentKey, index + 2, "element");
      }
    }
    return nodeToInsert;
  }
  /**
   * Inserts a node before this LexicalNode (as the previous sibling).
   *
   * @param nodeToInsert - The node to insert before this one.
   * @param restoreSelection - Whether or not to attempt to resolve the
   * selection to the appropriate place after the operation is complete.
   * */
  insertBefore(nodeToInsert, restoreSelection = true) {
    errorOnReadOnly();
    errorOnInsertTextNodeOnRoot(this, nodeToInsert);
    const writableSelf = this.getWritable();
    const writableNodeToInsert = nodeToInsert.getWritable();
    const insertKey = writableNodeToInsert.__key;
    removeFromParent(writableNodeToInsert);
    const prevSibling = this.getPreviousSibling();
    const writableParent = this.getParentOrThrow().getWritable();
    const prevKey = writableSelf.__prev;
    const index = this.getIndexWithinParent();
    if (prevSibling === null) {
      writableParent.__first = insertKey;
    } else {
      const writablePrevSibling = prevSibling.getWritable();
      writablePrevSibling.__next = insertKey;
    }
    writableParent.__size++;
    writableSelf.__prev = insertKey;
    writableNodeToInsert.__prev = prevKey;
    writableNodeToInsert.__next = writableSelf.__key;
    writableNodeToInsert.__parent = writableSelf.__parent;
    const selection = $getSelection();
    if (restoreSelection && $isRangeSelection(selection)) {
      const parent = this.getParentOrThrow();
      $updateElementSelectionOnCreateDeleteNode(selection, parent, index);
    }
    return nodeToInsert;
  }
  /**
   * Whether or not this node has a required parent. Used during copy + paste operations
   * to normalize nodes that would otherwise be orphaned. For example, ListItemNodes without
   * a ListNode parent or TextNodes with a ParagraphNode parent.
   *
   * */
  isParentRequired() {
    return false;
  }
  /**
   * The creation logic for any required parent. Should be implemented if {@link isParentRequired} returns true.
   *
   * */
  createParentElementNode() {
    return $createParagraphNode();
  }
  selectStart() {
    return this.selectPrevious();
  }
  selectEnd() {
    return this.selectNext(0, 0);
  }
  /**
   * Moves selection to the previous sibling of this node, at the specified offsets.
   *
   * @param anchorOffset - The anchor offset for selection.
   * @param focusOffset -  The focus offset for selection
   * */
  selectPrevious(anchorOffset, focusOffset) {
    errorOnReadOnly();
    const prevSibling = this.getPreviousSibling();
    const parent = this.getParentOrThrow();
    if (prevSibling === null) {
      return parent.select(0, 0);
    }
    if ($isElementNode(prevSibling)) {
      return prevSibling.select();
    } else if (!$isTextNode(prevSibling)) {
      const index = prevSibling.getIndexWithinParent() + 1;
      return parent.select(index, index);
    }
    return prevSibling.select(anchorOffset, focusOffset);
  }
  /**
   * Moves selection to the next sibling of this node, at the specified offsets.
   *
   * @param anchorOffset - The anchor offset for selection.
   * @param focusOffset -  The focus offset for selection
   * */
  selectNext(anchorOffset, focusOffset) {
    errorOnReadOnly();
    const nextSibling = this.getNextSibling();
    const parent = this.getParentOrThrow();
    if (nextSibling === null) {
      return parent.select();
    }
    if ($isElementNode(nextSibling)) {
      return nextSibling.select(0, 0);
    } else if (!$isTextNode(nextSibling)) {
      const index = nextSibling.getIndexWithinParent();
      return parent.select(index, index);
    }
    return nextSibling.select(anchorOffset, focusOffset);
  }
  /**
   * Marks a node dirty, triggering transforms and
   * forcing it to be reconciled during the update cycle.
   *
   * */
  markDirty() {
    this.getWritable();
  }
};
function errorOnTypeKlassMismatch(type, klass) {
  const registeredNode = getActiveEditor()._nodes.get(type);
  if (registeredNode === void 0) {
    {
      throw Error(`Create node: Attempted to create node ${klass.name} that was not configured to be used on the editor.`);
    }
  }
  const editorKlass = registeredNode.klass;
  if (editorKlass !== klass) {
    {
      throw Error(`Create node: Type ${type} in node ${klass.name} does not match registered node ${editorKlass.name} with the same type`);
    }
  }
}
function insertRangeAfter(node, firstToInsert, lastToInsert) {
  const lastToInsert2 = lastToInsert || firstToInsert.getParentOrThrow().getLastChild();
  let current = firstToInsert;
  const nodesToInsert = [firstToInsert];
  while (current !== lastToInsert2) {
    if (!current.getNextSibling()) {
      {
        throw Error(`insertRangeAfter: lastToInsert must be a later sibling of firstToInsert`);
      }
    }
    current = current.getNextSibling();
    nodesToInsert.push(current);
  }
  let currentNode = node;
  for (const nodeToInsert of nodesToInsert) {
    currentNode = currentNode.insertAfter(nodeToInsert);
  }
}
var LineBreakNode = class _LineBreakNode extends LexicalNode {
  static getType() {
    return "linebreak";
  }
  static clone(node) {
    return new _LineBreakNode(node.__key);
  }
  constructor(key) {
    super(key);
  }
  getTextContent() {
    return "\n";
  }
  createDOM() {
    return document.createElement("br");
  }
  updateDOM() {
    return false;
  }
  static importDOM() {
    return {
      br: (node) => {
        if (isOnlyChild(node)) {
          return null;
        }
        return {
          conversion: convertLineBreakElement,
          priority: 0
        };
      }
    };
  }
  static importJSON(serializedLineBreakNode) {
    return $createLineBreakNode();
  }
  exportJSON() {
    return {
      type: "linebreak",
      version: 1
    };
  }
};
function convertLineBreakElement(node) {
  return {
    node: $createLineBreakNode()
  };
}
function $createLineBreakNode() {
  return $applyNodeReplacement(new LineBreakNode());
}
function $isLineBreakNode(node) {
  return node instanceof LineBreakNode;
}
function isOnlyChild(node) {
  const parentElement = node.parentElement;
  if (parentElement !== null) {
    const firstChild = parentElement.firstChild;
    if (firstChild === node || firstChild.nextSibling === node && isWhitespaceDomTextNode(firstChild)) {
      const lastChild = parentElement.lastChild;
      if (lastChild === node || lastChild.previousSibling === node && isWhitespaceDomTextNode(lastChild)) {
        return true;
      }
    }
  }
  return false;
}
function isWhitespaceDomTextNode(node) {
  return node.nodeType === DOM_TEXT_TYPE && /^( |\t|\r?\n)+$/.test(node.textContent || "");
}
function getElementOuterTag(node, format) {
  if (format & IS_CODE) {
    return "code";
  }
  if (format & IS_HIGHLIGHT) {
    return "mark";
  }
  if (format & IS_SUBSCRIPT) {
    return "sub";
  }
  if (format & IS_SUPERSCRIPT) {
    return "sup";
  }
  return null;
}
function getElementInnerTag(node, format) {
  if (format & IS_BOLD) {
    return "strong";
  }
  if (format & IS_ITALIC) {
    return "em";
  }
  return "span";
}
function setTextThemeClassNames(tag, prevFormat, nextFormat, dom, textClassNames) {
  const domClassList = dom.classList;
  let classNames = getCachedClassNameArray(textClassNames, "base");
  if (classNames !== void 0) {
    domClassList.add(...classNames);
  }
  classNames = getCachedClassNameArray(textClassNames, "underlineStrikethrough");
  let hasUnderlineStrikethrough = false;
  const prevUnderlineStrikethrough = prevFormat & IS_UNDERLINE && prevFormat & IS_STRIKETHROUGH;
  const nextUnderlineStrikethrough = nextFormat & IS_UNDERLINE && nextFormat & IS_STRIKETHROUGH;
  if (classNames !== void 0) {
    if (nextUnderlineStrikethrough) {
      hasUnderlineStrikethrough = true;
      if (!prevUnderlineStrikethrough) {
        domClassList.add(...classNames);
      }
    } else if (prevUnderlineStrikethrough) {
      domClassList.remove(...classNames);
    }
  }
  for (const key in TEXT_TYPE_TO_FORMAT) {
    const format = key;
    const flag = TEXT_TYPE_TO_FORMAT[format];
    classNames = getCachedClassNameArray(textClassNames, key);
    if (classNames !== void 0) {
      if (nextFormat & flag) {
        if (hasUnderlineStrikethrough && (key === "underline" || key === "strikethrough")) {
          if (prevFormat & flag) {
            domClassList.remove(...classNames);
          }
          continue;
        }
        if ((prevFormat & flag) === 0 || prevUnderlineStrikethrough && key === "underline" || key === "strikethrough") {
          domClassList.add(...classNames);
        }
      } else if (prevFormat & flag) {
        domClassList.remove(...classNames);
      }
    }
  }
}
function diffComposedText(a2, b2) {
  const aLength = a2.length;
  const bLength = b2.length;
  let left = 0;
  let right = 0;
  while (left < aLength && left < bLength && a2[left] === b2[left]) {
    left++;
  }
  while (right + left < aLength && right + left < bLength && a2[aLength - right - 1] === b2[bLength - right - 1]) {
    right++;
  }
  return [left, aLength - left - right, b2.slice(left, bLength - right)];
}
function setTextContent(nextText, dom, node) {
  const firstChild = dom.firstChild;
  const isComposing = node.isComposing();
  const suffix = isComposing ? COMPOSITION_SUFFIX : "";
  const text = nextText + suffix;
  if (firstChild == null) {
    dom.textContent = text;
  } else {
    const nodeValue = firstChild.nodeValue;
    if (nodeValue !== text) {
      if (isComposing || IS_FIREFOX) {
        const [index, remove, insert] = diffComposedText(nodeValue, text);
        if (remove !== 0) {
          firstChild.deleteData(index, remove);
        }
        firstChild.insertData(index, insert);
      } else {
        firstChild.nodeValue = text;
      }
    }
  }
}
function createTextInnerDOM(innerDOM, node, innerTag, format, text, config) {
  setTextContent(text, innerDOM, node);
  const theme = config.theme;
  const textClassNames = theme.text;
  if (textClassNames !== void 0) {
    setTextThemeClassNames(innerTag, 0, format, innerDOM, textClassNames);
  }
}
function wrapElementWith(element, tag) {
  const el = document.createElement(tag);
  el.appendChild(element);
  return el;
}
var TextNode = class _TextNode extends LexicalNode {
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  static getType() {
    return "text";
  }
  static clone(node) {
    return new _TextNode(node.__text, node.__key);
  }
  constructor(text, key) {
    super(key);
    this.__text = text;
    this.__format = 0;
    this.__style = "";
    this.__mode = 0;
    this.__detail = 0;
  }
  /**
   * Returns a 32-bit integer that represents the TextFormatTypes currently applied to the
   * TextNode. You probably don't want to use this method directly - consider using TextNode.hasFormat instead.
   *
   * @returns a number representing the format of the text node.
   */
  getFormat() {
    const self = this.getLatest();
    return self.__format;
  }
  /**
   * Returns a 32-bit integer that represents the TextDetailTypes currently applied to the
   * TextNode. You probably don't want to use this method directly - consider using TextNode.isDirectionless
   * or TextNode.isUnmergeable instead.
   *
   * @returns a number representing the detail of the text node.
   */
  getDetail() {
    const self = this.getLatest();
    return self.__detail;
  }
  /**
   * Returns the mode (TextModeType) of the TextNode, which may be "normal", "token", or "segmented"
   *
   * @returns TextModeType.
   */
  getMode() {
    const self = this.getLatest();
    return TEXT_TYPE_TO_MODE[self.__mode];
  }
  /**
   * Returns the styles currently applied to the node. This is analogous to CSSText in the DOM.
   *
   * @returns CSSText-like string of styles applied to the underlying DOM node.
   */
  getStyle() {
    const self = this.getLatest();
    return self.__style;
  }
  /**
   * Returns whether or not the node is in "token" mode. TextNodes in token mode can be navigated through character-by-character
   * with a RangeSelection, but are deleted as a single entity (not invdividually by character).
   *
   * @returns true if the node is in token mode, false otherwise.
   */
  isToken() {
    const self = this.getLatest();
    return self.__mode === IS_TOKEN;
  }
  /**
   *
   * @returns true if Lexical detects that an IME or other 3rd-party script is attempting to
   * mutate the TextNode, false otherwise.
   */
  isComposing() {
    return this.__key === $getCompositionKey();
  }
  /**
   * Returns whether or not the node is in "segemented" mode. TextNodes in segemented mode can be navigated through character-by-character
   * with a RangeSelection, but are deleted in space-delimited "segments".
   *
   * @returns true if the node is in segmented mode, false otherwise.
   */
  isSegmented() {
    const self = this.getLatest();
    return self.__mode === IS_SEGMENTED;
  }
  /**
   * Returns whether or not the node is "directionless". Directionless nodes don't respect changes between RTL and LTR modes.
   *
   * @returns true if the node is directionless, false otherwise.
   */
  isDirectionless() {
    const self = this.getLatest();
    return (self.__detail & IS_DIRECTIONLESS) !== 0;
  }
  /**
   * Returns whether or not the node is unmergeable. In some scenarios, Lexical tries to merge
   * adjacent TextNodes into a single TextNode. If a TextNode is unmergeable, this won't happen.
   *
   * @returns true if the node is unmergeable, false otherwise.
   */
  isUnmergeable() {
    const self = this.getLatest();
    return (self.__detail & IS_UNMERGEABLE) !== 0;
  }
  /**
   * Returns whether or not the node has the provided format applied. Use this with the human-readable TextFormatType
   * string values to get the format of a TextNode.
   *
   * @param type - the TextFormatType to check for.
   *
   * @returns true if the node has the provided format, false otherwise.
   */
  hasFormat(type) {
    const formatFlag = TEXT_TYPE_TO_FORMAT[type];
    return (this.getFormat() & formatFlag) !== 0;
  }
  /**
   * Returns whether or not the node is simple text. Simple text is defined as a TextNode that has the string type "text"
   * (i.e., not a subclass) and has no mode applied to it (i.e., not segmented or token).
   *
   * @returns true if the node is simple text, false otherwise.
   */
  isSimpleText() {
    return this.__type === "text" && this.__mode === 0;
  }
  /**
   * Returns the text content of the node as a string.
   *
   * @returns a string representing the text content of the node.
   */
  getTextContent() {
    const self = this.getLatest();
    return self.__text;
  }
  /**
   * Returns the format flags applied to the node as a 32-bit integer.
   *
   * @returns a number representing the TextFormatTypes applied to the node.
   */
  getFormatFlags(type, alignWithFormat) {
    const self = this.getLatest();
    const format = self.__format;
    return toggleTextFormatType(format, type, alignWithFormat);
  }
  /**
   *
   * @returns true if the text node supports font styling, false otherwise.
   */
  canHaveFormat() {
    return true;
  }
  // View
  createDOM(config, editor) {
    const format = this.__format;
    const outerTag = getElementOuterTag(this, format);
    const innerTag = getElementInnerTag(this, format);
    const tag = outerTag === null ? innerTag : outerTag;
    const dom = document.createElement(tag);
    let innerDOM = dom;
    if (this.hasFormat("code")) {
      dom.setAttribute("spellcheck", "false");
    }
    if (outerTag !== null) {
      innerDOM = document.createElement(innerTag);
      dom.appendChild(innerDOM);
    }
    const text = this.__text;
    createTextInnerDOM(innerDOM, this, innerTag, format, text, config);
    const style = this.__style;
    if (style !== "") {
      dom.style.cssText = style;
    }
    return dom;
  }
  updateDOM(prevNode, dom, config) {
    const nextText = this.__text;
    const prevFormat = prevNode.__format;
    const nextFormat = this.__format;
    const prevOuterTag = getElementOuterTag(this, prevFormat);
    const nextOuterTag = getElementOuterTag(this, nextFormat);
    const prevInnerTag = getElementInnerTag(this, prevFormat);
    const nextInnerTag = getElementInnerTag(this, nextFormat);
    const prevTag = prevOuterTag === null ? prevInnerTag : prevOuterTag;
    const nextTag = nextOuterTag === null ? nextInnerTag : nextOuterTag;
    if (prevTag !== nextTag) {
      return true;
    }
    if (prevOuterTag === nextOuterTag && prevInnerTag !== nextInnerTag) {
      const prevInnerDOM = dom.firstChild;
      if (prevInnerDOM == null) {
        {
          throw Error(`updateDOM: prevInnerDOM is null or undefined`);
        }
      }
      const nextInnerDOM = document.createElement(nextInnerTag);
      createTextInnerDOM(nextInnerDOM, this, nextInnerTag, nextFormat, nextText, config);
      dom.replaceChild(nextInnerDOM, prevInnerDOM);
      return false;
    }
    let innerDOM = dom;
    if (nextOuterTag !== null) {
      if (prevOuterTag !== null) {
        innerDOM = dom.firstChild;
        if (innerDOM == null) {
          {
            throw Error(`updateDOM: innerDOM is null or undefined`);
          }
        }
      }
    }
    setTextContent(nextText, innerDOM, this);
    const theme = config.theme;
    const textClassNames = theme.text;
    if (textClassNames !== void 0 && prevFormat !== nextFormat) {
      setTextThemeClassNames(nextInnerTag, prevFormat, nextFormat, innerDOM, textClassNames);
    }
    const prevStyle = prevNode.__style;
    const nextStyle = this.__style;
    if (prevStyle !== nextStyle) {
      dom.style.cssText = nextStyle;
    }
    return false;
  }
  static importDOM() {
    return {
      "#text": () => ({
        conversion: convertTextDOMNode,
        priority: 0
      }),
      b: () => ({
        conversion: convertBringAttentionToElement,
        priority: 0
      }),
      code: () => ({
        conversion: convertTextFormatElement,
        priority: 0
      }),
      em: () => ({
        conversion: convertTextFormatElement,
        priority: 0
      }),
      i: () => ({
        conversion: convertTextFormatElement,
        priority: 0
      }),
      s: () => ({
        conversion: convertTextFormatElement,
        priority: 0
      }),
      span: () => ({
        conversion: convertSpanElement,
        priority: 0
      }),
      strong: () => ({
        conversion: convertTextFormatElement,
        priority: 0
      }),
      sub: () => ({
        conversion: convertTextFormatElement,
        priority: 0
      }),
      sup: () => ({
        conversion: convertTextFormatElement,
        priority: 0
      }),
      u: () => ({
        conversion: convertTextFormatElement,
        priority: 0
      })
    };
  }
  static importJSON(serializedNode) {
    const node = $createTextNode(serializedNode.text);
    node.setFormat(serializedNode.format);
    node.setDetail(serializedNode.detail);
    node.setMode(serializedNode.mode);
    node.setStyle(serializedNode.style);
    return node;
  }
  // This improves Lexical's basic text output in copy+paste plus
  // for headless mode where people might use Lexical to generate
  // HTML content and not have the ability to use CSS classes.
  exportDOM(editor) {
    let {
      element
    } = super.exportDOM(editor);
    if (!(element !== null && isHTMLElement(element))) {
      throw Error(`Expected TextNode createDOM to always return a HTMLElement`);
    }
    element.style.whiteSpace = "pre-wrap";
    if (this.hasFormat("bold")) {
      element = wrapElementWith(element, "b");
    }
    if (this.hasFormat("italic")) {
      element = wrapElementWith(element, "i");
    }
    if (this.hasFormat("strikethrough")) {
      element = wrapElementWith(element, "s");
    }
    if (this.hasFormat("underline")) {
      element = wrapElementWith(element, "u");
    }
    return {
      element
    };
  }
  exportJSON() {
    return {
      detail: this.getDetail(),
      format: this.getFormat(),
      mode: this.getMode(),
      style: this.getStyle(),
      text: this.getTextContent(),
      type: "text",
      version: 1
    };
  }
  // Mutators
  selectionTransform(prevSelection, nextSelection) {
    return;
  }
  /**
   * Sets the node format to the provided TextFormatType or 32-bit integer. Note that the TextFormatType
   * version of the argument can only specify one format and doing so will remove all other formats that
   * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleFormat}
   *
   * @param format - TextFormatType or 32-bit integer representing the node format.
   *
   * @returns this TextNode.
   * // TODO 0.12 This should just be a `string`.
   */
  setFormat(format) {
    const self = this.getWritable();
    self.__format = typeof format === "string" ? TEXT_TYPE_TO_FORMAT[format] : format;
    return self;
  }
  /**
   * Sets the node detail to the provided TextDetailType or 32-bit integer. Note that the TextDetailType
   * version of the argument can only specify one detail value and doing so will remove all other detail values that
   * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleDirectionless}
   * or {@link TextNode.togglerUnmergeable}
   *
   * @param detail - TextDetailType or 32-bit integer representing the node detail.
   *
   * @returns this TextNode.
   * // TODO 0.12 This should just be a `string`.
   */
  setDetail(detail) {
    const self = this.getWritable();
    self.__detail = typeof detail === "string" ? DETAIL_TYPE_TO_DETAIL[detail] : detail;
    return self;
  }
  /**
   * Sets the node style to the provided CSSText-like string. Set this property as you
   * would an HTMLElement style attribute to apply inline styles to the underlying DOM Element.
   *
   * @param style - CSSText to be applied to the underlying HTMLElement.
   *
   * @returns this TextNode.
   */
  setStyle(style) {
    const self = this.getWritable();
    self.__style = style;
    return self;
  }
  /**
   * Applies the provided format to this TextNode if it's not present. Removes it if it's present.
   * The subscript and superscript formats are mutually exclusive.
   * Prefer using this method to turn specific formats on and off.
   *
   * @param type - TextFormatType to toggle.
   *
   * @returns this TextNode.
   */
  toggleFormat(type) {
    const format = this.getFormat();
    const newFormat = toggleTextFormatType(format, type, null);
    return this.setFormat(newFormat);
  }
  /**
   * Toggles the directionless detail value of the node. Prefer using this method over setDetail.
   *
   * @returns this TextNode.
   */
  toggleDirectionless() {
    const self = this.getWritable();
    self.__detail ^= IS_DIRECTIONLESS;
    return self;
  }
  /**
   * Toggles the unmergeable detail value of the node. Prefer using this method over setDetail.
   *
   * @returns this TextNode.
   */
  toggleUnmergeable() {
    const self = this.getWritable();
    self.__detail ^= IS_UNMERGEABLE;
    return self;
  }
  /**
   * Sets the mode of the node.
   *
   * @returns this TextNode.
   */
  setMode(type) {
    const mode = TEXT_MODE_TO_TYPE[type];
    if (this.__mode === mode) {
      return this;
    }
    const self = this.getWritable();
    self.__mode = mode;
    return self;
  }
  /**
   * Sets the text content of the node.
   *
   * @param text - the string to set as the text value of the node.
   *
   * @returns this TextNode.
   */
  setTextContent(text) {
    if (this.__text === text) {
      return this;
    }
    const self = this.getWritable();
    self.__text = text;
    return self;
  }
  /**
   * Sets the current Lexical selection to be a RangeSelection with anchor and focus on this TextNode at the provided offsets.
   *
   * @param _anchorOffset - the offset at which the Selection anchor will be placed.
   * @param _focusOffset - the offset at which the Selection focus will be placed.
   *
   * @returns the new RangeSelection.
   */
  select(_anchorOffset, _focusOffset) {
    errorOnReadOnly();
    let anchorOffset = _anchorOffset;
    let focusOffset = _focusOffset;
    const selection = $getSelection();
    const text = this.getTextContent();
    const key = this.__key;
    if (typeof text === "string") {
      const lastOffset = text.length;
      if (anchorOffset === void 0) {
        anchorOffset = lastOffset;
      }
      if (focusOffset === void 0) {
        focusOffset = lastOffset;
      }
    } else {
      anchorOffset = 0;
      focusOffset = 0;
    }
    if (!$isRangeSelection(selection)) {
      return internalMakeRangeSelection(key, anchorOffset, key, focusOffset, "text", "text");
    } else {
      const compositionKey = $getCompositionKey();
      if (compositionKey === selection.anchor.key || compositionKey === selection.focus.key) {
        $setCompositionKey(key);
      }
      selection.setTextNodeRange(this, anchorOffset, this, focusOffset);
    }
    return selection;
  }
  selectStart() {
    return this.select(0, 0);
  }
  selectEnd() {
    const size = this.getTextContentSize();
    return this.select(size, size);
  }
  /**
   * Inserts the provided text into this TextNode at the provided offset, deleting the number of characters
   * specified. Can optionally calculate a new selection after the operation is complete.
   *
   * @param offset - the offset at which the splice operation should begin.
   * @param delCount - the number of characters to delete, starting from the offset.
   * @param newText - the text to insert into the TextNode at the offset.
   * @param moveSelection - optional, whether or not to move selection to the end of the inserted substring.
   *
   * @returns this TextNode.
   */
  spliceText(offset, delCount, newText, moveSelection) {
    const writableSelf = this.getWritable();
    const text = writableSelf.__text;
    const handledTextLength = newText.length;
    let index = offset;
    if (index < 0) {
      index = handledTextLength + index;
      if (index < 0) {
        index = 0;
      }
    }
    const selection = $getSelection();
    if (moveSelection && $isRangeSelection(selection)) {
      const newOffset = offset + handledTextLength;
      selection.setTextNodeRange(writableSelf, newOffset, writableSelf, newOffset);
    }
    const updatedText = text.slice(0, index) + newText + text.slice(index + delCount);
    writableSelf.__text = updatedText;
    return writableSelf;
  }
  /**
   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes
   * when a user event would cause text to be inserted before them in the editor. If true, Lexical will attempt
   * to insert text into this node. If false, it will insert the text in a new sibling node.
   *
   * @returns true if text can be inserted before the node, false otherwise.
   */
  canInsertTextBefore() {
    return true;
  }
  /**
   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes
   * when a user event would cause text to be inserted after them in the editor. If true, Lexical will attempt
   * to insert text into this node. If false, it will insert the text in a new sibling node.
   *
   * @returns true if text can be inserted after the node, false otherwise.
   */
  canInsertTextAfter() {
    return true;
  }
  /**
   * Splits this TextNode at the provided character offsets, forming new TextNodes from the substrings
   * formed by the split, and inserting those new TextNodes into the editor, replacing the one that was split.
   *
   * @param splitOffsets - rest param of the text content character offsets at which this node should be split.
   *
   * @returns an Array containing the newly-created TextNodes.
   */
  splitText(...splitOffsets) {
    errorOnReadOnly();
    const self = this.getLatest();
    const textContent = self.getTextContent();
    const key = self.__key;
    const compositionKey = $getCompositionKey();
    const offsetsSet = new Set(splitOffsets);
    const parts = [];
    const textLength = textContent.length;
    let string = "";
    for (let i2 = 0; i2 < textLength; i2++) {
      if (string !== "" && offsetsSet.has(i2)) {
        parts.push(string);
        string = "";
      }
      string += textContent[i2];
    }
    if (string !== "") {
      parts.push(string);
    }
    const partsLength = parts.length;
    if (partsLength === 0) {
      return [];
    } else if (parts[0] === textContent) {
      return [self];
    }
    const firstPart = parts[0];
    const parent = self.getParentOrThrow();
    let writableNode;
    const format = self.getFormat();
    const style = self.getStyle();
    const detail = self.__detail;
    let hasReplacedSelf = false;
    if (self.isSegmented()) {
      writableNode = $createTextNode(firstPart);
      writableNode.__format = format;
      writableNode.__style = style;
      writableNode.__detail = detail;
      hasReplacedSelf = true;
    } else {
      writableNode = self.getWritable();
      writableNode.__text = firstPart;
    }
    const selection = $getSelection();
    const splitNodes = [writableNode];
    let textSize = firstPart.length;
    for (let i2 = 1; i2 < partsLength; i2++) {
      const part = parts[i2];
      const partSize = part.length;
      const sibling = $createTextNode(part).getWritable();
      sibling.__format = format;
      sibling.__style = style;
      sibling.__detail = detail;
      const siblingKey = sibling.__key;
      const nextTextSize = textSize + partSize;
      if ($isRangeSelection(selection)) {
        const anchor = selection.anchor;
        const focus = selection.focus;
        if (anchor.key === key && anchor.type === "text" && anchor.offset > textSize && anchor.offset <= nextTextSize) {
          anchor.key = siblingKey;
          anchor.offset -= textSize;
          selection.dirty = true;
        }
        if (focus.key === key && focus.type === "text" && focus.offset > textSize && focus.offset <= nextTextSize) {
          focus.key = siblingKey;
          focus.offset -= textSize;
          selection.dirty = true;
        }
      }
      if (compositionKey === key) {
        $setCompositionKey(siblingKey);
      }
      textSize = nextTextSize;
      splitNodes.push(sibling);
    }
    internalMarkSiblingsAsDirty(this);
    const writableParent = parent.getWritable();
    const insertionIndex = this.getIndexWithinParent();
    if (hasReplacedSelf) {
      writableParent.splice(insertionIndex, 0, splitNodes);
      this.remove();
    } else {
      writableParent.splice(insertionIndex, 1, splitNodes);
    }
    if ($isRangeSelection(selection)) {
      $updateElementSelectionOnCreateDeleteNode(selection, parent, insertionIndex, partsLength - 1);
    }
    return splitNodes;
  }
  /**
   * Merges the target TextNode into this TextNode, removing the target node.
   *
   * @param target - the TextNode to merge into this one.
   *
   * @returns this TextNode.
   */
  mergeWithSibling(target) {
    const isBefore = target === this.getPreviousSibling();
    if (!isBefore && target !== this.getNextSibling()) {
      {
        throw Error(`mergeWithSibling: sibling must be a previous or next sibling`);
      }
    }
    const key = this.__key;
    const targetKey = target.__key;
    const text = this.__text;
    const textLength = text.length;
    const compositionKey = $getCompositionKey();
    if (compositionKey === targetKey) {
      $setCompositionKey(key);
    }
    const selection = $getSelection();
    if ($isRangeSelection(selection)) {
      const anchor = selection.anchor;
      const focus = selection.focus;
      if (anchor !== null && anchor.key === targetKey) {
        adjustPointOffsetForMergedSibling(anchor, isBefore, key, target, textLength);
        selection.dirty = true;
      }
      if (focus !== null && focus.key === targetKey) {
        adjustPointOffsetForMergedSibling(focus, isBefore, key, target, textLength);
        selection.dirty = true;
      }
    }
    const targetText = target.__text;
    const newText = isBefore ? targetText + text : text + targetText;
    this.setTextContent(newText);
    const writableSelf = this.getWritable();
    target.remove();
    return writableSelf;
  }
  /**
   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes
   * when used with the registerLexicalTextEntity function. If you're using registerLexicalTextEntity, the
   * node class that you create and replace matched text with should return true from this method.
   *
   * @returns true if the node is to be treated as a "text entity", false otherwise.
   */
  isTextEntity() {
    return false;
  }
};
function convertSpanElement(domNode) {
  const span = domNode;
  const hasBoldFontWeight = span.style.fontWeight === "700";
  const hasLinethroughTextDecoration = span.style.textDecoration === "line-through";
  const hasItalicFontStyle = span.style.fontStyle === "italic";
  const hasUnderlineTextDecoration = span.style.textDecoration === "underline";
  const verticalAlign = span.style.verticalAlign;
  return {
    forChild: (lexicalNode) => {
      if (!$isTextNode(lexicalNode)) {
        return lexicalNode;
      }
      if (hasBoldFontWeight) {
        lexicalNode.toggleFormat("bold");
      }
      if (hasLinethroughTextDecoration) {
        lexicalNode.toggleFormat("strikethrough");
      }
      if (hasItalicFontStyle) {
        lexicalNode.toggleFormat("italic");
      }
      if (hasUnderlineTextDecoration) {
        lexicalNode.toggleFormat("underline");
      }
      if (verticalAlign === "sub") {
        lexicalNode.toggleFormat("subscript");
      }
      if (verticalAlign === "super") {
        lexicalNode.toggleFormat("superscript");
      }
      return lexicalNode;
    },
    node: null
  };
}
function convertBringAttentionToElement(domNode) {
  const b2 = domNode;
  const hasNormalFontWeight = b2.style.fontWeight === "normal";
  return {
    forChild: (lexicalNode) => {
      if ($isTextNode(lexicalNode) && !hasNormalFontWeight) {
        lexicalNode.toggleFormat("bold");
      }
      return lexicalNode;
    },
    node: null
  };
}
var preParentCache = /* @__PURE__ */ new WeakMap();
function isNodePre(node) {
  return node.nodeName === "PRE" || node.nodeType === DOM_ELEMENT_TYPE && node.style !== void 0 && node.style.whiteSpace !== void 0 && node.style.whiteSpace.startsWith("pre");
}
function findParentPreDOMNode(node) {
  let cached;
  let parent = node.parentNode;
  const visited = [node];
  while (parent !== null && (cached = preParentCache.get(parent)) === void 0 && !isNodePre(parent)) {
    visited.push(parent);
    parent = parent.parentNode;
  }
  const resultNode = cached === void 0 ? parent : cached;
  for (let i2 = 0; i2 < visited.length; i2++) {
    preParentCache.set(visited[i2], resultNode);
  }
  return resultNode;
}
function convertTextDOMNode(domNode) {
  const domNode_ = domNode;
  const parentDom = domNode.parentElement;
  if (!(parentDom !== null)) {
    throw Error(`Expected parentElement of Text not to be null`);
  }
  let textContent = domNode_.textContent || "";
  if (findParentPreDOMNode(domNode_) !== null) {
    const parts = textContent.split(/(\r?\n|\t)/);
    const nodes = [];
    const length = parts.length;
    for (let i2 = 0; i2 < length; i2++) {
      const part = parts[i2];
      if (part === "\n" || part === "\r\n") {
        nodes.push($createLineBreakNode());
      } else if (part === "	") {
        nodes.push($createTabNode());
      } else if (part !== "") {
        nodes.push($createTextNode(part));
      }
    }
    return {
      node: nodes
    };
  }
  textContent = textContent.replace(/\r/g, "").replace(/[ \t\n]+/g, " ");
  if (textContent === "") {
    return {
      node: null
    };
  }
  if (textContent[0] === " ") {
    let previousText = domNode_;
    let isStartOfLine = true;
    while (previousText !== null && (previousText = findTextInLine(previousText, false)) !== null) {
      const previousTextContent = previousText.textContent || "";
      if (previousTextContent.length > 0) {
        if (/[ \t\n]$/.test(previousTextContent)) {
          textContent = textContent.slice(1);
        }
        isStartOfLine = false;
        break;
      }
    }
    if (isStartOfLine) {
      textContent = textContent.slice(1);
    }
  }
  if (textContent[textContent.length - 1] === " ") {
    let nextText = domNode_;
    let isEndOfLine = true;
    while (nextText !== null && (nextText = findTextInLine(nextText, true)) !== null) {
      const nextTextContent = (nextText.textContent || "").replace(/^( |\t|\r?\n)+/, "");
      if (nextTextContent.length > 0) {
        isEndOfLine = false;
        break;
      }
    }
    if (isEndOfLine) {
      textContent = textContent.slice(0, textContent.length - 1);
    }
  }
  if (textContent === "") {
    return {
      node: null
    };
  }
  return {
    node: $createTextNode(textContent)
  };
}
var inlineParents = new RegExp(/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/, "i");
function findTextInLine(text, forward) {
  let node = text;
  while (true) {
    let sibling;
    while ((sibling = forward ? node.nextSibling : node.previousSibling) === null) {
      const parentElement = node.parentElement;
      if (parentElement === null) {
        return null;
      }
      node = parentElement;
    }
    node = sibling;
    if (node.nodeType === DOM_ELEMENT_TYPE) {
      const display = node.style.display;
      if (display === "" && node.nodeName.match(inlineParents) === null || display !== "" && !display.startsWith("inline")) {
        return null;
      }
    }
    let descendant = node;
    while ((descendant = forward ? node.firstChild : node.lastChild) !== null) {
      node = descendant;
    }
    if (node.nodeType === DOM_TEXT_TYPE) {
      return node;
    } else if (node.nodeName === "BR") {
      return null;
    }
  }
}
var nodeNameToTextFormat = {
  code: "code",
  em: "italic",
  i: "italic",
  s: "strikethrough",
  strong: "bold",
  sub: "subscript",
  sup: "superscript",
  u: "underline"
};
function convertTextFormatElement(domNode) {
  const format = nodeNameToTextFormat[domNode.nodeName.toLowerCase()];
  if (format === void 0) {
    return {
      node: null
    };
  }
  return {
    forChild: (lexicalNode) => {
      if ($isTextNode(lexicalNode) && !lexicalNode.hasFormat(format)) {
        lexicalNode.toggleFormat(format);
      }
      return lexicalNode;
    },
    node: null
  };
}
function $createTextNode(text = "") {
  return $applyNodeReplacement(new TextNode(text));
}
function $isTextNode(node) {
  return node instanceof TextNode;
}
var TabNode = class _TabNode extends TextNode {
  static getType() {
    return "tab";
  }
  static clone(node) {
    const newNode = new _TabNode(node.__key);
    newNode.__text = node.__text;
    newNode.__format = node.__format;
    newNode.__style = node.__style;
    return newNode;
  }
  constructor(key) {
    super("	", key);
    this.__detail = IS_UNMERGEABLE;
  }
  static importDOM() {
    return null;
  }
  static importJSON(serializedTabNode) {
    const node = $createTabNode();
    node.setFormat(serializedTabNode.format);
    node.setStyle(serializedTabNode.style);
    return node;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      type: "tab",
      version: 1
    };
  }
  setTextContent(_text) {
    {
      throw Error(`TabNode does not support setTextContent`);
    }
  }
  setDetail(_detail) {
    {
      throw Error(`TabNode does not support setDetail`);
    }
  }
  setMode(_type) {
    {
      throw Error(`TabNode does not support setMode`);
    }
  }
  canInsertTextBefore() {
    return false;
  }
  canInsertTextAfter() {
    return false;
  }
};
function $createTabNode() {
  return $applyNodeReplacement(new TabNode());
}
function $isTabNode(node) {
  return node instanceof TabNode;
}
var Point = class {
  constructor(key, offset, type) {
    this._selection = null;
    this.key = key;
    this.offset = offset;
    this.type = type;
  }
  is(point) {
    return this.key === point.key && this.offset === point.offset && this.type === point.type;
  }
  isBefore(b2) {
    let aNode = this.getNode();
    let bNode = b2.getNode();
    const aOffset = this.offset;
    const bOffset = b2.offset;
    if ($isElementNode(aNode)) {
      const aNodeDescendant = aNode.getDescendantByIndex(aOffset);
      aNode = aNodeDescendant != null ? aNodeDescendant : aNode;
    }
    if ($isElementNode(bNode)) {
      const bNodeDescendant = bNode.getDescendantByIndex(bOffset);
      bNode = bNodeDescendant != null ? bNodeDescendant : bNode;
    }
    if (aNode === bNode) {
      return aOffset < bOffset;
    }
    return aNode.isBefore(bNode);
  }
  getNode() {
    const key = this.key;
    const node = $getNodeByKey(key);
    if (node === null) {
      {
        throw Error(`Point.getNode: node not found`);
      }
    }
    return node;
  }
  set(key, offset, type) {
    const selection = this._selection;
    const oldKey = this.key;
    this.key = key;
    this.offset = offset;
    this.type = type;
    if (!isCurrentlyReadOnlyMode()) {
      if ($getCompositionKey() === oldKey) {
        $setCompositionKey(key);
      }
      if (selection !== null) {
        selection.setCachedNodes(null);
        selection.dirty = true;
      }
    }
  }
};
function $createPoint(key, offset, type) {
  return new Point(key, offset, type);
}
function selectPointOnNode(point, node) {
  let key = node.__key;
  let offset = point.offset;
  let type = "element";
  if ($isTextNode(node)) {
    type = "text";
    const textContentLength = node.getTextContentSize();
    if (offset > textContentLength) {
      offset = textContentLength;
    }
  } else if (!$isElementNode(node)) {
    const nextSibling = node.getNextSibling();
    if ($isTextNode(nextSibling)) {
      key = nextSibling.__key;
      offset = 0;
      type = "text";
    } else {
      const parentNode = node.getParent();
      if (parentNode) {
        key = parentNode.__key;
        offset = node.getIndexWithinParent() + 1;
      }
    }
  }
  point.set(key, offset, type);
}
function $moveSelectionPointToEnd(point, node) {
  if ($isElementNode(node)) {
    const lastNode = node.getLastDescendant();
    if ($isElementNode(lastNode) || $isTextNode(lastNode)) {
      selectPointOnNode(point, lastNode);
    } else {
      selectPointOnNode(point, node);
    }
  } else {
    selectPointOnNode(point, node);
  }
}
function $transferStartingElementPointToTextPoint(start, end, format, style) {
  const element = start.getNode();
  const placementNode = element.getChildAtIndex(start.offset);
  const textNode = $createTextNode();
  const target = $isRootNode(element) ? $createParagraphNode().append(textNode) : textNode;
  textNode.setFormat(format);
  textNode.setStyle(style);
  if (placementNode === null) {
    element.append(target);
  } else {
    placementNode.insertBefore(target);
  }
  if (start.is(end)) {
    end.set(textNode.__key, 0, "text");
  }
  start.set(textNode.__key, 0, "text");
}
function $setPointValues(point, key, offset, type) {
  point.key = key;
  point.offset = offset;
  point.type = type;
}
var NodeSelection = class _NodeSelection {
  constructor(objects) {
    this._cachedNodes = null;
    this._nodes = objects;
    this.dirty = false;
  }
  getCachedNodes() {
    return this._cachedNodes;
  }
  setCachedNodes(nodes) {
    this._cachedNodes = nodes;
  }
  is(selection) {
    if (!$isNodeSelection(selection)) {
      return false;
    }
    const a2 = this._nodes;
    const b2 = selection._nodes;
    return a2.size === b2.size && Array.from(a2).every((key) => b2.has(key));
  }
  isCollapsed() {
    return false;
  }
  isBackward() {
    return false;
  }
  getStartEndPoints() {
    return null;
  }
  add(key) {
    this.dirty = true;
    this._nodes.add(key);
    this._cachedNodes = null;
  }
  delete(key) {
    this.dirty = true;
    this._nodes.delete(key);
    this._cachedNodes = null;
  }
  clear() {
    this.dirty = true;
    this._nodes.clear();
    this._cachedNodes = null;
  }
  has(key) {
    return this._nodes.has(key);
  }
  clone() {
    return new _NodeSelection(new Set(this._nodes));
  }
  extract() {
    return this.getNodes();
  }
  insertRawText(text) {
  }
  insertText() {
  }
  insertNodes(nodes) {
    const selectedNodes = this.getNodes();
    const selectedNodesLength = selectedNodes.length;
    const lastSelectedNode = selectedNodes[selectedNodesLength - 1];
    let selectionAtEnd;
    if ($isTextNode(lastSelectedNode)) {
      selectionAtEnd = lastSelectedNode.select();
    } else {
      const index = lastSelectedNode.getIndexWithinParent() + 1;
      selectionAtEnd = lastSelectedNode.getParentOrThrow().select(index, index);
    }
    selectionAtEnd.insertNodes(nodes);
    for (let i2 = 0; i2 < selectedNodesLength; i2++) {
      selectedNodes[i2].remove();
    }
  }
  getNodes() {
    const cachedNodes = this._cachedNodes;
    if (cachedNodes !== null) {
      return cachedNodes;
    }
    const objects = this._nodes;
    const nodes = [];
    for (const object of objects) {
      const node = $getNodeByKey(object);
      if (node !== null) {
        nodes.push(node);
      }
    }
    if (!isCurrentlyReadOnlyMode()) {
      this._cachedNodes = nodes;
    }
    return nodes;
  }
  getTextContent() {
    const nodes = this.getNodes();
    let textContent = "";
    for (let i2 = 0; i2 < nodes.length; i2++) {
      textContent += nodes[i2].getTextContent();
    }
    return textContent;
  }
};
function $isRangeSelection(x2) {
  return x2 instanceof RangeSelection;
}
var RangeSelection = class _RangeSelection {
  constructor(anchor, focus, format, style) {
    this.anchor = anchor;
    this.focus = focus;
    anchor._selection = this;
    focus._selection = this;
    this._cachedNodes = null;
    this.format = format;
    this.style = style;
    this.dirty = false;
  }
  getCachedNodes() {
    return this._cachedNodes;
  }
  setCachedNodes(nodes) {
    this._cachedNodes = nodes;
  }
  /**
   * Used to check if the provided selections is equal to this one by value,
   * inluding anchor, focus, format, and style properties.
   * @param selection - the Selection to compare this one to.
   * @returns true if the Selections are equal, false otherwise.
   */
  is(selection) {
    if (!$isRangeSelection(selection)) {
      return false;
    }
    return this.anchor.is(selection.anchor) && this.focus.is(selection.focus) && this.format === selection.format && this.style === selection.style;
  }
  /**
   * Returns whether the Selection is "collapsed", meaning the anchor and focus are
   * the same node and have the same offset.
   *
   * @returns true if the Selection is collapsed, false otherwise.
   */
  isCollapsed() {
    return this.anchor.is(this.focus);
  }
  /**
   * Gets all the nodes in the Selection. Uses caching to make it generally suitable
   * for use in hot paths.
   *
   * @returns an Array containing all the nodes in the Selection
   */
  getNodes() {
    const cachedNodes = this._cachedNodes;
    if (cachedNodes !== null) {
      return cachedNodes;
    }
    const anchor = this.anchor;
    const focus = this.focus;
    const isBefore = anchor.isBefore(focus);
    const firstPoint = isBefore ? anchor : focus;
    const lastPoint = isBefore ? focus : anchor;
    let firstNode = firstPoint.getNode();
    let lastNode = lastPoint.getNode();
    const startOffset = firstPoint.offset;
    const endOffset = lastPoint.offset;
    if ($isElementNode(firstNode)) {
      const firstNodeDescendant = firstNode.getDescendantByIndex(startOffset);
      firstNode = firstNodeDescendant != null ? firstNodeDescendant : firstNode;
    }
    if ($isElementNode(lastNode)) {
      let lastNodeDescendant = lastNode.getDescendantByIndex(endOffset);
      if (lastNodeDescendant !== null && lastNodeDescendant !== firstNode && lastNode.getChildAtIndex(endOffset) === lastNodeDescendant) {
        lastNodeDescendant = lastNodeDescendant.getPreviousSibling();
      }
      lastNode = lastNodeDescendant != null ? lastNodeDescendant : lastNode;
    }
    let nodes;
    if (firstNode.is(lastNode)) {
      if ($isElementNode(firstNode) && firstNode.getChildrenSize() > 0) {
        nodes = [];
      } else {
        nodes = [firstNode];
      }
    } else {
      nodes = firstNode.getNodesBetween(lastNode);
    }
    if (!isCurrentlyReadOnlyMode()) {
      this._cachedNodes = nodes;
    }
    return nodes;
  }
  /**
   * Sets this Selection to be of type "text" at the provided anchor and focus values.
   *
   * @param anchorNode - the anchor node to set on the Selection
   * @param anchorOffset - the offset to set on the Selection
   * @param focusNode - the focus node to set on the Selection
   * @param focusOffset - the focus offset to set on the Selection
   */
  setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset) {
    $setPointValues(this.anchor, anchorNode.__key, anchorOffset, "text");
    $setPointValues(this.focus, focusNode.__key, focusOffset, "text");
    this._cachedNodes = null;
    this.dirty = true;
  }
  /**
   * Gets the (plain) text content of all the nodes in the selection.
   *
   * @returns a string representing the text content of all the nodes in the Selection
   */
  getTextContent() {
    const nodes = this.getNodes();
    if (nodes.length === 0) {
      return "";
    }
    const firstNode = nodes[0];
    const lastNode = nodes[nodes.length - 1];
    const anchor = this.anchor;
    const focus = this.focus;
    const isBefore = anchor.isBefore(focus);
    const [anchorOffset, focusOffset] = $getCharacterOffsets(this);
    let textContent = "";
    let prevWasElement = true;
    for (let i2 = 0; i2 < nodes.length; i2++) {
      const node = nodes[i2];
      if ($isElementNode(node) && !node.isInline()) {
        if (!prevWasElement) {
          textContent += "\n";
        }
        if (node.isEmpty()) {
          prevWasElement = false;
        } else {
          prevWasElement = true;
        }
      } else {
        prevWasElement = false;
        if ($isTextNode(node)) {
          let text = node.getTextContent();
          if (node === firstNode) {
            if (node === lastNode) {
              if (anchor.type !== "element" || focus.type !== "element" || focus.offset === anchor.offset) {
                text = anchorOffset < focusOffset ? text.slice(anchorOffset, focusOffset) : text.slice(focusOffset, anchorOffset);
              }
            } else {
              text = isBefore ? text.slice(anchorOffset) : text.slice(focusOffset);
            }
          } else if (node === lastNode) {
            text = isBefore ? text.slice(0, focusOffset) : text.slice(0, anchorOffset);
          }
          textContent += text;
        } else if (($isDecoratorNode(node) || $isLineBreakNode(node)) && (node !== lastNode || !this.isCollapsed())) {
          textContent += node.getTextContent();
        }
      }
    }
    return textContent;
  }
  /**
   * Attempts to map a DOM selection range onto this Lexical Selection,
   * setting the anchor, focus, and type accordingly
   *
   * @param range a DOM Selection range conforming to the StaticRange interface.
   */
  applyDOMRange(range) {
    const editor = getActiveEditor();
    const currentEditorState = editor.getEditorState();
    const lastSelection = currentEditorState._selection;
    const resolvedSelectionPoints = internalResolveSelectionPoints(range.startContainer, range.startOffset, range.endContainer, range.endOffset, editor, lastSelection);
    if (resolvedSelectionPoints === null) {
      return;
    }
    const [anchorPoint, focusPoint] = resolvedSelectionPoints;
    $setPointValues(this.anchor, anchorPoint.key, anchorPoint.offset, anchorPoint.type);
    $setPointValues(this.focus, focusPoint.key, focusPoint.offset, focusPoint.type);
    this._cachedNodes = null;
  }
  /**
   * Creates a new RangeSelection, copying over all the property values from this one.
   *
   * @returns a new RangeSelection with the same property values as this one.
   */
  clone() {
    const anchor = this.anchor;
    const focus = this.focus;
    const selection = new _RangeSelection($createPoint(anchor.key, anchor.offset, anchor.type), $createPoint(focus.key, focus.offset, focus.type), this.format, this.style);
    return selection;
  }
  /**
   * Toggles the provided format on all the TextNodes in the Selection.
   *
   * @param format a string TextFormatType to toggle on the TextNodes in the selection
   */
  toggleFormat(format) {
    this.format = toggleTextFormatType(this.format, format, null);
    this.dirty = true;
  }
  /**
   * Sets the value of the style property on the Selection
   *
   * @param style - the style to set at the value of the style property.
   */
  setStyle(style) {
    this.style = style;
    this.dirty = true;
  }
  /**
   * Returns whether the provided TextFormatType is present on the Selection. This will be true if any node in the Selection
   * has the specified format.
   *
   * @param type the TextFormatType to check for.
   * @returns true if the provided format is currently toggled on on the Selection, false otherwise.
   */
  hasFormat(type) {
    const formatFlag = TEXT_TYPE_TO_FORMAT[type];
    return (this.format & formatFlag) !== 0;
  }
  /**
   * Attempts to insert the provided text into the EditorState at the current Selection.
   * converts tabs, newlines, and carriage returns into LexicalNodes.
   *
   * @param text the text to insert into the Selection
   */
  insertRawText(text) {
    const parts = text.split(/(\r?\n|\t)/);
    const nodes = [];
    const length = parts.length;
    for (let i2 = 0; i2 < length; i2++) {
      const part = parts[i2];
      if (part === "\n" || part === "\r\n") {
        nodes.push($createLineBreakNode());
      } else if (part === "	") {
        nodes.push($createTabNode());
      } else {
        nodes.push($createTextNode(part));
      }
    }
    this.insertNodes(nodes);
  }
  /**
   * Attempts to insert the provided text into the EditorState at the current Selection as a new
   * Lexical TextNode, according to a series of insertion heuristics based on the selection type and position.
   *
   * @param text the text to insert into the Selection
   */
  insertText(text) {
    const anchor = this.anchor;
    const focus = this.focus;
    const isBefore = this.isCollapsed() || anchor.isBefore(focus);
    const format = this.format;
    const style = this.style;
    if (isBefore && anchor.type === "element") {
      $transferStartingElementPointToTextPoint(anchor, focus, format, style);
    } else if (!isBefore && focus.type === "element") {
      $transferStartingElementPointToTextPoint(focus, anchor, format, style);
    }
    const selectedNodes = this.getNodes();
    const selectedNodesLength = selectedNodes.length;
    const firstPoint = isBefore ? anchor : focus;
    const endPoint = isBefore ? focus : anchor;
    const startOffset = firstPoint.offset;
    const endOffset = endPoint.offset;
    let firstNode = selectedNodes[0];
    if (!$isTextNode(firstNode)) {
      {
        throw Error(`insertText: first node is not a text node`);
      }
    }
    const firstNodeText = firstNode.getTextContent();
    const firstNodeTextLength = firstNodeText.length;
    const firstNodeParent = firstNode.getParentOrThrow();
    const lastIndex = selectedNodesLength - 1;
    let lastNode = selectedNodes[lastIndex];
    if (this.isCollapsed() && startOffset === firstNodeTextLength && (firstNode.isSegmented() || firstNode.isToken() || !firstNode.canInsertTextAfter() || !firstNodeParent.canInsertTextAfter() && firstNode.getNextSibling() === null)) {
      let nextSibling = firstNode.getNextSibling();
      if (!$isTextNode(nextSibling) || !nextSibling.canInsertTextBefore() || $isTokenOrSegmented(nextSibling)) {
        nextSibling = $createTextNode();
        nextSibling.setFormat(format);
        if (!firstNodeParent.canInsertTextAfter()) {
          firstNodeParent.insertAfter(nextSibling);
        } else {
          firstNode.insertAfter(nextSibling);
        }
      }
      nextSibling.select(0, 0);
      firstNode = nextSibling;
      if (text !== "") {
        this.insertText(text);
        return;
      }
    } else if (this.isCollapsed() && startOffset === 0 && (firstNode.isSegmented() || firstNode.isToken() || !firstNode.canInsertTextBefore() || !firstNodeParent.canInsertTextBefore() && firstNode.getPreviousSibling() === null)) {
      let prevSibling = firstNode.getPreviousSibling();
      if (!$isTextNode(prevSibling) || $isTokenOrSegmented(prevSibling)) {
        prevSibling = $createTextNode();
        prevSibling.setFormat(format);
        if (!firstNodeParent.canInsertTextBefore()) {
          firstNodeParent.insertBefore(prevSibling);
        } else {
          firstNode.insertBefore(prevSibling);
        }
      }
      prevSibling.select();
      firstNode = prevSibling;
      if (text !== "") {
        this.insertText(text);
        return;
      }
    } else if (firstNode.isSegmented() && startOffset !== firstNodeTextLength) {
      const textNode = $createTextNode(firstNode.getTextContent());
      textNode.setFormat(format);
      firstNode.replace(textNode);
      firstNode = textNode;
    } else if (!this.isCollapsed() && text !== "") {
      const lastNodeParent = lastNode.getParent();
      if (!firstNodeParent.canInsertTextBefore() || !firstNodeParent.canInsertTextAfter() || $isElementNode(lastNodeParent) && (!lastNodeParent.canInsertTextBefore() || !lastNodeParent.canInsertTextAfter())) {
        this.insertText("");
        normalizeSelectionPointsForBoundaries(this.anchor, this.focus, null);
        this.insertText(text);
        return;
      }
    }
    if (selectedNodesLength === 1) {
      if (firstNode.isToken()) {
        const textNode = $createTextNode(text);
        textNode.select();
        firstNode.replace(textNode);
        return;
      }
      const firstNodeFormat = firstNode.getFormat();
      const firstNodeStyle = firstNode.getStyle();
      if (startOffset === endOffset && (firstNodeFormat !== format || firstNodeStyle !== style)) {
        if (firstNode.getTextContent() === "") {
          firstNode.setFormat(format);
          firstNode.setStyle(style);
        } else {
          const textNode = $createTextNode(text);
          textNode.setFormat(format);
          textNode.setStyle(style);
          textNode.select();
          if (startOffset === 0) {
            firstNode.insertBefore(textNode, false);
          } else {
            const [targetNode] = firstNode.splitText(startOffset);
            targetNode.insertAfter(textNode, false);
          }
          if (textNode.isComposing() && this.anchor.type === "text") {
            this.anchor.offset -= text.length;
          }
          return;
        }
      } else if ($isTabNode(firstNode)) {
        const textNode = $createTextNode(text);
        textNode.setFormat(format);
        textNode.setStyle(style);
        textNode.select();
        firstNode.replace(textNode);
        return;
      }
      const delCount = endOffset - startOffset;
      firstNode = firstNode.spliceText(startOffset, delCount, text, true);
      if (firstNode.getTextContent() === "") {
        firstNode.remove();
      } else if (this.anchor.type === "text") {
        if (firstNode.isComposing()) {
          this.anchor.offset -= text.length;
        } else {
          this.format = firstNodeFormat;
          this.style = firstNodeStyle;
        }
      }
    } else {
      const markedNodeKeysForKeep = /* @__PURE__ */ new Set([...firstNode.getParentKeys(), ...lastNode.getParentKeys()]);
      const firstElement = $isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();
      let lastElement = $isElementNode(lastNode) ? lastNode : lastNode.getParentOrThrow();
      let lastElementChild = lastNode;
      if (!firstElement.is(lastElement) && lastElement.isInline()) {
        do {
          lastElementChild = lastElement;
          lastElement = lastElement.getParentOrThrow();
        } while (lastElement.isInline());
      }
      if (endPoint.type === "text" && (endOffset !== 0 || lastNode.getTextContent() === "") || endPoint.type === "element" && lastNode.getIndexWithinParent() < endOffset) {
        if ($isTextNode(lastNode) && !lastNode.isToken() && endOffset !== lastNode.getTextContentSize()) {
          if (lastNode.isSegmented()) {
            const textNode = $createTextNode(lastNode.getTextContent());
            lastNode.replace(textNode);
            lastNode = textNode;
          }
          if (!$isRootNode(endPoint.getNode()) && endPoint.type === "text") {
            lastNode = lastNode.spliceText(0, endOffset, "");
          }
          markedNodeKeysForKeep.add(lastNode.__key);
        } else {
          const lastNodeParent = lastNode.getParentOrThrow();
          if (!lastNodeParent.canBeEmpty() && lastNodeParent.getChildrenSize() === 1) {
            lastNodeParent.remove();
          } else {
            lastNode.remove();
          }
        }
      } else {
        markedNodeKeysForKeep.add(lastNode.__key);
      }
      const lastNodeChildren = lastElement.getChildren();
      const selectedNodesSet = new Set(selectedNodes);
      const firstAndLastElementsAreEqual = firstElement.is(lastElement);
      const insertionTarget = firstElement.isInline() && firstNode.getNextSibling() === null ? firstElement : firstNode;
      for (let i2 = lastNodeChildren.length - 1; i2 >= 0; i2--) {
        const lastNodeChild = lastNodeChildren[i2];
        if (lastNodeChild.is(firstNode) || $isElementNode(lastNodeChild) && lastNodeChild.isParentOf(firstNode)) {
          break;
        }
        if (lastNodeChild.isAttached()) {
          if (!selectedNodesSet.has(lastNodeChild) || lastNodeChild.is(lastElementChild)) {
            if (!firstAndLastElementsAreEqual) {
              insertionTarget.insertAfter(lastNodeChild, false);
            }
          } else {
            lastNodeChild.remove();
          }
        }
      }
      if (!firstAndLastElementsAreEqual) {
        let parent = lastElement;
        let lastRemovedParent = null;
        while (parent !== null) {
          const children = parent.getChildren();
          const childrenLength = children.length;
          if (childrenLength === 0 || children[childrenLength - 1].is(lastRemovedParent)) {
            markedNodeKeysForKeep.delete(parent.__key);
            lastRemovedParent = parent;
          }
          parent = parent.getParent();
        }
      }
      if (!firstNode.isToken()) {
        firstNode = firstNode.spliceText(startOffset, firstNodeTextLength - startOffset, text, true);
        if (firstNode.getTextContent() === "") {
          firstNode.remove();
        } else if (firstNode.isComposing() && this.anchor.type === "text") {
          this.anchor.offset -= text.length;
        }
      } else if (startOffset === firstNodeTextLength) {
        firstNode.select();
      } else {
        const textNode = $createTextNode(text);
        textNode.select();
        firstNode.replace(textNode);
      }
      for (let i2 = 1; i2 < selectedNodesLength; i2++) {
        const selectedNode = selectedNodes[i2];
        const key = selectedNode.__key;
        if (!markedNodeKeysForKeep.has(key)) {
          selectedNode.remove();
        }
      }
    }
  }
  /**
   * Removes the text in the Selection, adjusting the EditorState accordingly.
   */
  removeText() {
    this.insertText("");
  }
  /**
   * Applies the provided format to the TextNodes in the Selection, splitting or
   * merging nodes as necessary.
   *
   * @param formatType the format type to apply to the nodes in the Selection.
   */
  formatText(formatType) {
    if (this.isCollapsed()) {
      this.toggleFormat(formatType);
      $setCompositionKey(null);
      return;
    }
    const selectedNodes = this.getNodes();
    const selectedTextNodes = [];
    for (const selectedNode of selectedNodes) {
      if ($isTextNode(selectedNode)) {
        selectedTextNodes.push(selectedNode);
      }
    }
    const selectedTextNodesLength = selectedTextNodes.length;
    if (selectedTextNodesLength === 0) {
      this.toggleFormat(formatType);
      $setCompositionKey(null);
      return;
    }
    const anchor = this.anchor;
    const focus = this.focus;
    const isBackward = this.isBackward();
    const startPoint = isBackward ? focus : anchor;
    const endPoint = isBackward ? anchor : focus;
    let firstIndex = 0;
    let firstNode = selectedTextNodes[0];
    let startOffset = startPoint.type === "element" ? 0 : startPoint.offset;
    if (startPoint.type === "text" && startOffset === firstNode.getTextContentSize()) {
      firstIndex = 1;
      firstNode = selectedTextNodes[1];
      startOffset = 0;
    }
    if (firstNode == null) {
      return;
    }
    const firstNextFormat = firstNode.getFormatFlags(formatType, null);
    const lastIndex = selectedTextNodesLength - 1;
    let lastNode = selectedTextNodes[lastIndex];
    const endOffset = endPoint.type === "text" ? endPoint.offset : lastNode.getTextContentSize();
    if (firstNode.is(lastNode)) {
      if (startOffset === endOffset) {
        return;
      }
      if (startOffset === 0 && endOffset === firstNode.getTextContentSize()) {
        firstNode.setFormat(firstNextFormat);
      } else {
        const splitNodes = firstNode.splitText(startOffset, endOffset);
        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];
        replacement.setFormat(firstNextFormat);
        if (startPoint.type === "text") {
          startPoint.set(replacement.__key, 0, "text");
        }
        if (endPoint.type === "text") {
          endPoint.set(replacement.__key, endOffset - startOffset, "text");
        }
      }
      this.format = firstNextFormat;
      return;
    }
    if (startOffset !== 0) {
      [, firstNode] = firstNode.splitText(startOffset);
      startOffset = 0;
    }
    firstNode.setFormat(firstNextFormat);
    const lastNextFormat = lastNode.getFormatFlags(formatType, firstNextFormat);
    if (endOffset > 0) {
      if (endOffset !== lastNode.getTextContentSize()) {
        [lastNode] = lastNode.splitText(endOffset);
      }
      lastNode.setFormat(lastNextFormat);
    }
    for (let i2 = firstIndex + 1; i2 < lastIndex; i2++) {
      const textNode = selectedTextNodes[i2];
      if (!textNode.isToken()) {
        const nextFormat = textNode.getFormatFlags(formatType, lastNextFormat);
        textNode.setFormat(nextFormat);
      }
    }
    if (startPoint.type === "text") {
      startPoint.set(firstNode.__key, startOffset, "text");
    }
    if (endPoint.type === "text") {
      endPoint.set(lastNode.__key, endOffset, "text");
    }
    this.format = firstNextFormat | lastNextFormat;
  }
  /**
   * Attempts to "intelligently" insert an arbitrary list of Lexical nodes into the EditorState at the
   * current Selection according to a set of heuristics that determine how surrounding nodes
   * should be changed, replaced, or moved to accomodate the incoming ones.
   *
   * @param nodes - the nodes to insert
   */
  insertNodes(nodes) {
    if (nodes.length === 0) {
      return;
    }
    if (this.anchor.key === "root") {
      this.insertParagraph();
      const selection = $getSelection();
      if (!$isRangeSelection(selection)) {
        throw Error(`Expected RangeSelection after insertParagraph`);
      }
      return selection.insertNodes(nodes);
    }
    const firstPoint = this.isBackward() ? this.focus : this.anchor;
    const firstBlock = $getAncestor(firstPoint.getNode(), INTERNAL_$isBlock);
    const last = nodes[nodes.length - 1];
    if ("__language" in firstBlock && $isElementNode(firstBlock)) {
      if ("__language" in nodes[0]) {
        this.insertText(nodes[0].getTextContent());
      } else {
        const index = removeTextAndSplitBlock(this);
        firstBlock.splice(index, 0, nodes);
        last.selectEnd();
      }
      return;
    }
    const notInline = (node) => ($isElementNode(node) || $isDecoratorNode(node)) && !node.isInline();
    if (!nodes.some(notInline)) {
      if (!$isElementNode(firstBlock)) {
        throw Error(`Expected 'firstBlock' to be an ElementNode`);
      }
      const index = removeTextAndSplitBlock(this);
      firstBlock.splice(index, 0, nodes);
      last.selectEnd();
      return;
    }
    const blocksParent = $wrapInlineNodes(nodes);
    const nodeToSelect = blocksParent.getLastDescendant();
    const blocks = blocksParent.getChildren();
    const isLI = (node) => "__value" in node && "__checked" in node;
    const isMergeable = (node) => $isElementNode(node) && INTERNAL_$isBlock(node) && !node.isEmpty() && $isElementNode(firstBlock) && (!firstBlock.isEmpty() || isLI(firstBlock));
    const shouldInsert = !$isElementNode(firstBlock) || !firstBlock.isEmpty();
    const insertedParagraph = shouldInsert ? this.insertParagraph() : null;
    const lastToInsert = blocks[blocks.length - 1];
    let firstToInsert = blocks[0];
    if (isMergeable(firstToInsert)) {
      if (!$isElementNode(firstBlock)) {
        throw Error(`Expected 'firstBlock' to be an ElementNode`);
      }
      firstBlock.append(...firstToInsert.getChildren());
      firstToInsert = blocks[1];
    }
    if (firstToInsert) {
      insertRangeAfter(firstBlock, firstToInsert);
    }
    const lastInsertedBlock = $getAncestor(nodeToSelect, INTERNAL_$isBlock);
    if (insertedParagraph && $isElementNode(lastInsertedBlock) && (isLI(insertedParagraph) || INTERNAL_$isBlock(lastToInsert))) {
      lastInsertedBlock.append(...insertedParagraph.getChildren());
      insertedParagraph.remove();
    }
    if ($isElementNode(firstBlock) && firstBlock.isEmpty()) {
      firstBlock.remove();
    }
    nodeToSelect.selectEnd();
    const lastChild = $isElementNode(firstBlock) ? firstBlock.getLastChild() : null;
    if ($isLineBreakNode(lastChild) && lastInsertedBlock !== firstBlock) {
      lastChild.remove();
    }
  }
  /**
   * Inserts a new ParagraphNode into the EditorState at the current Selection
   *
   * @returns the newly inserted node.
   */
  insertParagraph() {
    if (this.anchor.key === "root") {
      const paragraph = $createParagraphNode();
      $getRoot().splice(this.anchor.offset, 0, [paragraph]);
      paragraph.select();
      return paragraph;
    }
    const index = removeTextAndSplitBlock(this);
    const block = $getAncestor(this.anchor.getNode(), INTERNAL_$isBlock);
    if (!$isElementNode(block)) {
      throw Error(`Expected ancestor to be an ElementNode`);
    }
    const firstToAppend = block.getChildAtIndex(index);
    const nodesToInsert = firstToAppend ? [firstToAppend, ...firstToAppend.getNextSiblings()] : [];
    const newBlock = block.insertNewAfter(this, false);
    if (newBlock) {
      newBlock.append(...nodesToInsert);
      newBlock.selectStart();
      return newBlock;
    }
    return null;
  }
  /**
   * Inserts a logical linebreak, which may be a new LineBreakNode or a new ParagraphNode, into the EditorState at the
   * current Selection.
   */
  insertLineBreak(selectStart) {
    const lineBreak = $createLineBreakNode();
    this.insertNodes([lineBreak]);
    if (selectStart) {
      const parent = lineBreak.getParentOrThrow();
      const index = lineBreak.getIndexWithinParent();
      parent.select(index, index);
    }
  }
  /**
   * Extracts the nodes in the Selection, splitting nodes where necessary
   * to get offset-level precision.
   *
   * @returns The nodes in the Selection
   */
  extract() {
    const selectedNodes = this.getNodes();
    const selectedNodesLength = selectedNodes.length;
    const lastIndex = selectedNodesLength - 1;
    const anchor = this.anchor;
    const focus = this.focus;
    let firstNode = selectedNodes[0];
    let lastNode = selectedNodes[lastIndex];
    const [anchorOffset, focusOffset] = $getCharacterOffsets(this);
    if (selectedNodesLength === 0) {
      return [];
    } else if (selectedNodesLength === 1) {
      if ($isTextNode(firstNode) && !this.isCollapsed()) {
        const startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;
        const endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;
        const splitNodes = firstNode.splitText(startOffset, endOffset);
        const node = startOffset === 0 ? splitNodes[0] : splitNodes[1];
        return node != null ? [node] : [];
      }
      return [firstNode];
    }
    const isBefore = anchor.isBefore(focus);
    if ($isTextNode(firstNode)) {
      const startOffset = isBefore ? anchorOffset : focusOffset;
      if (startOffset === firstNode.getTextContentSize()) {
        selectedNodes.shift();
      } else if (startOffset !== 0) {
        [, firstNode] = firstNode.splitText(startOffset);
        selectedNodes[0] = firstNode;
      }
    }
    if ($isTextNode(lastNode)) {
      const lastNodeText = lastNode.getTextContent();
      const lastNodeTextLength = lastNodeText.length;
      const endOffset = isBefore ? focusOffset : anchorOffset;
      if (endOffset === 0) {
        selectedNodes.pop();
      } else if (endOffset !== lastNodeTextLength) {
        [lastNode] = lastNode.splitText(endOffset);
        selectedNodes[lastIndex] = lastNode;
      }
    }
    return selectedNodes;
  }
  /**
   * Modifies the Selection according to the parameters and a set of heuristics that account for
   * various node types. Can be used to safely move or extend selection by one logical "unit" without
   * dealing explicitly with all the possible node types.
   *
   * @param alter the type of modification to perform
   * @param isBackward whether or not selection is backwards
   * @param granularity the granularity at which to apply the modification
   */
  modify(alter, isBackward, granularity) {
    const focus = this.focus;
    const anchor = this.anchor;
    const collapse = alter === "move";
    const possibleNode = $getAdjacentNode(focus, isBackward);
    if ($isDecoratorNode(possibleNode) && !possibleNode.isIsolated()) {
      if (collapse && possibleNode.isKeyboardSelectable()) {
        const nodeSelection = $createNodeSelection();
        nodeSelection.add(possibleNode.__key);
        $setSelection(nodeSelection);
        return;
      }
      const sibling = isBackward ? possibleNode.getPreviousSibling() : possibleNode.getNextSibling();
      if (!$isTextNode(sibling)) {
        const parent = possibleNode.getParentOrThrow();
        let offset;
        let elementKey;
        if ($isElementNode(sibling)) {
          elementKey = sibling.__key;
          offset = isBackward ? sibling.getChildrenSize() : 0;
        } else {
          offset = possibleNode.getIndexWithinParent();
          elementKey = parent.__key;
          if (!isBackward) {
            offset++;
          }
        }
        focus.set(elementKey, offset, "element");
        if (collapse) {
          anchor.set(elementKey, offset, "element");
        }
        return;
      } else {
        const siblingKey = sibling.__key;
        const offset = isBackward ? sibling.getTextContent().length : 0;
        focus.set(siblingKey, offset, "text");
        if (collapse) {
          anchor.set(siblingKey, offset, "text");
        }
        return;
      }
    }
    const editor = getActiveEditor();
    const domSelection = getDOMSelection(editor._window);
    if (!domSelection) {
      return;
    }
    const blockCursorElement = editor._blockCursorElement;
    const rootElement = editor._rootElement;
    if (rootElement !== null && blockCursorElement !== null && $isElementNode(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty()) {
      removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);
    }
    moveNativeSelection(domSelection, alter, isBackward ? "backward" : "forward", granularity);
    if (domSelection.rangeCount > 0) {
      const range = domSelection.getRangeAt(0);
      const anchorNode = this.anchor.getNode();
      const root = $isRootNode(anchorNode) ? anchorNode : $getNearestRootOrShadowRoot(anchorNode);
      this.applyDOMRange(range);
      this.dirty = true;
      if (!collapse) {
        const nodes = this.getNodes();
        const validNodes = [];
        let shrinkSelection = false;
        for (let i2 = 0; i2 < nodes.length; i2++) {
          const nextNode = nodes[i2];
          if ($hasAncestor(nextNode, root)) {
            validNodes.push(nextNode);
          } else {
            shrinkSelection = true;
          }
        }
        if (shrinkSelection && validNodes.length > 0) {
          if (isBackward) {
            const firstValidNode = validNodes[0];
            if ($isElementNode(firstValidNode)) {
              firstValidNode.selectStart();
            } else {
              firstValidNode.getParentOrThrow().selectStart();
            }
          } else {
            const lastValidNode = validNodes[validNodes.length - 1];
            if ($isElementNode(lastValidNode)) {
              lastValidNode.selectEnd();
            } else {
              lastValidNode.getParentOrThrow().selectEnd();
            }
          }
        }
        if (domSelection.anchorNode !== range.startContainer || domSelection.anchorOffset !== range.startOffset) {
          $swapPoints(this);
        }
      }
    }
  }
  /**
   * Helper for handling forward character and word deletion that prevents element nodes
   * like a table, columns layout being destroyed
   *
   * @param anchor the anchor
   * @param anchorNode the anchor node in the selection
   * @param isBackward whether or not selection is backwards
   */
  forwardDeletion(anchor, anchorNode, isBackward) {
    if (!isBackward && // Delete forward handle case
    (anchor.type === "element" && $isElementNode(anchorNode) && anchor.offset === anchorNode.getChildrenSize() || anchor.type === "text" && anchor.offset === anchorNode.getTextContentSize())) {
      const parent = anchorNode.getParent();
      const nextSibling = anchorNode.getNextSibling() || (parent === null ? null : parent.getNextSibling());
      if ($isElementNode(nextSibling) && nextSibling.isShadowRoot()) {
        return true;
      }
    }
    return false;
  }
  /**
   * Performs one logical character deletion operation on the EditorState based on the current Selection.
   * Handles different node types.
   *
   * @param isBackward whether or not the selection is backwards.
   */
  deleteCharacter(isBackward) {
    const wasCollapsed = this.isCollapsed();
    if (this.isCollapsed()) {
      const anchor = this.anchor;
      let anchorNode = anchor.getNode();
      if (this.forwardDeletion(anchor, anchorNode, isBackward)) {
        return;
      }
      const focus = this.focus;
      const possibleNode = $getAdjacentNode(focus, isBackward);
      if ($isDecoratorNode(possibleNode) && !possibleNode.isIsolated()) {
        if (possibleNode.isKeyboardSelectable() && $isElementNode(anchorNode) && anchorNode.getChildrenSize() === 0) {
          anchorNode.remove();
          const nodeSelection = $createNodeSelection();
          nodeSelection.add(possibleNode.__key);
          $setSelection(nodeSelection);
        } else {
          possibleNode.remove();
          const editor = getActiveEditor();
          editor.dispatchCommand(SELECTION_CHANGE_COMMAND, void 0);
        }
        return;
      } else if (!isBackward && $isElementNode(possibleNode) && $isElementNode(anchorNode) && anchorNode.isEmpty()) {
        anchorNode.remove();
        possibleNode.selectStart();
        return;
      }
      this.modify("extend", isBackward, "character");
      if (!this.isCollapsed()) {
        const focusNode = focus.type === "text" ? focus.getNode() : null;
        anchorNode = anchor.type === "text" ? anchor.getNode() : null;
        if (focusNode !== null && focusNode.isSegmented()) {
          const offset = focus.offset;
          const textContentSize = focusNode.getTextContentSize();
          if (focusNode.is(anchorNode) || isBackward && offset !== textContentSize || !isBackward && offset !== 0) {
            $removeSegment(focusNode, isBackward, offset);
            return;
          }
        } else if (anchorNode !== null && anchorNode.isSegmented()) {
          const offset = anchor.offset;
          const textContentSize = anchorNode.getTextContentSize();
          if (anchorNode.is(focusNode) || isBackward && offset !== 0 || !isBackward && offset !== textContentSize) {
            $removeSegment(anchorNode, isBackward, offset);
            return;
          }
        }
        $updateCaretSelectionForUnicodeCharacter(this, isBackward);
      } else if (isBackward && anchor.offset === 0) {
        const element = anchor.type === "element" ? anchor.getNode() : anchor.getNode().getParentOrThrow();
        if (element.collapseAtStart(this)) {
          return;
        }
      }
    }
    this.removeText();
    if (isBackward && !wasCollapsed && this.isCollapsed() && this.anchor.type === "element" && this.anchor.offset === 0) {
      const anchorNode = this.anchor.getNode();
      if (anchorNode.isEmpty() && $isRootNode(anchorNode.getParent()) && anchorNode.getIndexWithinParent() === 0) {
        anchorNode.collapseAtStart(this);
      }
    }
  }
  /**
   * Performs one logical line deletion operation on the EditorState based on the current Selection.
   * Handles different node types.
   *
   * @param isBackward whether or not the selection is backwards.
   */
  deleteLine(isBackward) {
    if (this.isCollapsed()) {
      if (this.anchor.type === "text") {
        this.modify("extend", isBackward, "lineboundary");
      }
      const endPoint = isBackward ? this.focus : this.anchor;
      if (endPoint.offset === 0) {
        this.modify("extend", isBackward, "character");
      }
    }
    this.removeText();
  }
  /**
   * Performs one logical word deletion operation on the EditorState based on the current Selection.
   * Handles different node types.
   *
   * @param isBackward whether or not the selection is backwards.
   */
  deleteWord(isBackward) {
    if (this.isCollapsed()) {
      const anchor = this.anchor;
      const anchorNode = anchor.getNode();
      if (this.forwardDeletion(anchor, anchorNode, isBackward)) {
        return;
      }
      this.modify("extend", isBackward, "word");
    }
    this.removeText();
  }
  /**
   * Returns whether the Selection is "backwards", meaning the focus
   * logically precedes the anchor in the EditorState.
   * @returns true if the Selection is backwards, false otherwise.
   */
  isBackward() {
    return this.focus.isBefore(this.anchor);
  }
  getStartEndPoints() {
    return [this.anchor, this.focus];
  }
};
function $isNodeSelection(x2) {
  return x2 instanceof NodeSelection;
}
function getCharacterOffset(point) {
  const offset = point.offset;
  if (point.type === "text") {
    return offset;
  }
  const parent = point.getNode();
  return offset === parent.getChildrenSize() ? parent.getTextContent().length : 0;
}
function $getCharacterOffsets(selection) {
  const anchorAndFocus = selection.getStartEndPoints();
  if (anchorAndFocus === null) {
    return [0, 0];
  }
  const [anchor, focus] = anchorAndFocus;
  if (anchor.type === "element" && focus.type === "element" && anchor.key === focus.key && anchor.offset === focus.offset) {
    return [0, 0];
  }
  return [getCharacterOffset(anchor), getCharacterOffset(focus)];
}
function $swapPoints(selection) {
  const focus = selection.focus;
  const anchor = selection.anchor;
  const anchorKey = anchor.key;
  const anchorOffset = anchor.offset;
  const anchorType = anchor.type;
  $setPointValues(anchor, focus.key, focus.offset, focus.type);
  $setPointValues(focus, anchorKey, anchorOffset, anchorType);
  selection._cachedNodes = null;
}
function moveNativeSelection(domSelection, alter, direction, granularity) {
  domSelection.modify(alter, direction, granularity);
}
function $updateCaretSelectionForUnicodeCharacter(selection, isBackward) {
  const anchor = selection.anchor;
  const focus = selection.focus;
  const anchorNode = anchor.getNode();
  const focusNode = focus.getNode();
  if (anchorNode === focusNode && anchor.type === "text" && focus.type === "text") {
    const anchorOffset = anchor.offset;
    const focusOffset = focus.offset;
    const isBefore = anchorOffset < focusOffset;
    const startOffset = isBefore ? anchorOffset : focusOffset;
    const endOffset = isBefore ? focusOffset : anchorOffset;
    const characterOffset = endOffset - 1;
    if (startOffset !== characterOffset) {
      const text = anchorNode.getTextContent().slice(startOffset, endOffset);
      if (!doesContainGrapheme(text)) {
        if (isBackward) {
          focus.offset = characterOffset;
        } else {
          anchor.offset = characterOffset;
        }
      }
    }
  }
}
function $removeSegment(node, isBackward, offset) {
  const textNode = node;
  const textContent = textNode.getTextContent();
  const split = textContent.split(/(?=\s)/g);
  const splitLength = split.length;
  let segmentOffset = 0;
  let restoreOffset = 0;
  for (let i2 = 0; i2 < splitLength; i2++) {
    const text = split[i2];
    const isLast = i2 === splitLength - 1;
    restoreOffset = segmentOffset;
    segmentOffset += text.length;
    if (isBackward && segmentOffset === offset || segmentOffset > offset || isLast) {
      split.splice(i2, 1);
      if (isLast) {
        restoreOffset = void 0;
      }
      break;
    }
  }
  const nextTextContent = split.join("").trim();
  if (nextTextContent === "") {
    textNode.remove();
  } else {
    textNode.setTextContent(nextTextContent);
    textNode.select(restoreOffset, restoreOffset);
  }
}
function shouldResolveAncestor(resolvedElement, resolvedOffset, lastPoint) {
  const parent = resolvedElement.getParent();
  return lastPoint === null || parent === null || !parent.canBeEmpty() || parent !== lastPoint.getNode();
}
function internalResolveSelectionPoint(dom, offset, lastPoint, editor) {
  let resolvedOffset = offset;
  let resolvedNode;
  if (dom.nodeType === DOM_ELEMENT_TYPE) {
    let moveSelectionToEnd = false;
    const childNodes = dom.childNodes;
    const childNodesLength = childNodes.length;
    if (resolvedOffset === childNodesLength) {
      moveSelectionToEnd = true;
      resolvedOffset = childNodesLength - 1;
    }
    let childDOM = childNodes[resolvedOffset];
    let hasBlockCursor = false;
    if (childDOM === editor._blockCursorElement) {
      childDOM = childNodes[resolvedOffset + 1];
      hasBlockCursor = true;
    } else if (editor._blockCursorElement !== null) {
      resolvedOffset--;
    }
    resolvedNode = getNodeFromDOM(childDOM);
    if ($isTextNode(resolvedNode)) {
      resolvedOffset = getTextNodeOffset(resolvedNode, moveSelectionToEnd);
    } else {
      let resolvedElement = getNodeFromDOM(dom);
      if (resolvedElement === null) {
        return null;
      }
      if ($isElementNode(resolvedElement)) {
        let child = resolvedElement.getChildAtIndex(resolvedOffset);
        if ($isElementNode(child) && shouldResolveAncestor(child, resolvedOffset, lastPoint)) {
          const descendant = moveSelectionToEnd ? child.getLastDescendant() : child.getFirstDescendant();
          if (descendant === null) {
            resolvedElement = child;
            resolvedOffset = 0;
          } else {
            child = descendant;
            resolvedElement = $isElementNode(child) ? child : child.getParentOrThrow();
          }
        }
        if ($isTextNode(child)) {
          resolvedNode = child;
          resolvedElement = null;
          resolvedOffset = getTextNodeOffset(child, moveSelectionToEnd);
        } else if (child !== resolvedElement && moveSelectionToEnd && !hasBlockCursor) {
          resolvedOffset++;
        }
      } else {
        const index = resolvedElement.getIndexWithinParent();
        if (offset === 0 && $isDecoratorNode(resolvedElement) && getNodeFromDOM(dom) === resolvedElement) {
          resolvedOffset = index;
        } else {
          resolvedOffset = index + 1;
        }
        resolvedElement = resolvedElement.getParentOrThrow();
      }
      if ($isElementNode(resolvedElement)) {
        return $createPoint(resolvedElement.__key, resolvedOffset, "element");
      }
    }
  } else {
    resolvedNode = getNodeFromDOM(dom);
  }
  if (!$isTextNode(resolvedNode)) {
    return null;
  }
  return $createPoint(resolvedNode.__key, resolvedOffset, "text");
}
function resolveSelectionPointOnBoundary(point, isBackward, isCollapsed) {
  const offset = point.offset;
  const node = point.getNode();
  if (offset === 0) {
    const prevSibling = node.getPreviousSibling();
    const parent = node.getParent();
    if (!isBackward) {
      if ($isElementNode(prevSibling) && !isCollapsed && prevSibling.isInline()) {
        point.key = prevSibling.__key;
        point.offset = prevSibling.getChildrenSize();
        point.type = "element";
      } else if ($isTextNode(prevSibling)) {
        point.key = prevSibling.__key;
        point.offset = prevSibling.getTextContent().length;
      }
    } else if ((isCollapsed || !isBackward) && prevSibling === null && $isElementNode(parent) && parent.isInline()) {
      const parentSibling = parent.getPreviousSibling();
      if ($isTextNode(parentSibling)) {
        point.key = parentSibling.__key;
        point.offset = parentSibling.getTextContent().length;
      }
    }
  } else if (offset === node.getTextContent().length) {
    const nextSibling = node.getNextSibling();
    const parent = node.getParent();
    if (isBackward && $isElementNode(nextSibling) && nextSibling.isInline()) {
      point.key = nextSibling.__key;
      point.offset = 0;
      point.type = "element";
    } else if ((isCollapsed || isBackward) && nextSibling === null && $isElementNode(parent) && parent.isInline() && !parent.canInsertTextAfter()) {
      const parentSibling = parent.getNextSibling();
      if ($isTextNode(parentSibling)) {
        point.key = parentSibling.__key;
        point.offset = 0;
      }
    }
  }
}
function normalizeSelectionPointsForBoundaries(anchor, focus, lastSelection) {
  if (anchor.type === "text" && focus.type === "text") {
    const isBackward = anchor.isBefore(focus);
    const isCollapsed = anchor.is(focus);
    resolveSelectionPointOnBoundary(anchor, isBackward, isCollapsed);
    resolveSelectionPointOnBoundary(focus, !isBackward, isCollapsed);
    if (isCollapsed) {
      focus.key = anchor.key;
      focus.offset = anchor.offset;
      focus.type = anchor.type;
    }
    const editor = getActiveEditor();
    if (editor.isComposing() && editor._compositionKey !== anchor.key && $isRangeSelection(lastSelection)) {
      const lastAnchor = lastSelection.anchor;
      const lastFocus = lastSelection.focus;
      $setPointValues(anchor, lastAnchor.key, lastAnchor.offset, lastAnchor.type);
      $setPointValues(focus, lastFocus.key, lastFocus.offset, lastFocus.type);
    }
  }
}
function internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection) {
  if (anchorDOM === null || focusDOM === null || !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {
    return null;
  }
  const resolvedAnchorPoint = internalResolveSelectionPoint(anchorDOM, anchorOffset, $isRangeSelection(lastSelection) ? lastSelection.anchor : null, editor);
  if (resolvedAnchorPoint === null) {
    return null;
  }
  const resolvedFocusPoint = internalResolveSelectionPoint(focusDOM, focusOffset, $isRangeSelection(lastSelection) ? lastSelection.focus : null, editor);
  if (resolvedFocusPoint === null) {
    return null;
  }
  if (resolvedAnchorPoint.type === "element" && resolvedFocusPoint.type === "element") {
    const anchorNode = getNodeFromDOM(anchorDOM);
    const focusNode = getNodeFromDOM(focusDOM);
    if ($isDecoratorNode(anchorNode) && $isDecoratorNode(focusNode)) {
      return null;
    }
  }
  normalizeSelectionPointsForBoundaries(resolvedAnchorPoint, resolvedFocusPoint, lastSelection);
  return [resolvedAnchorPoint, resolvedFocusPoint];
}
function $isBlockElementNode(node) {
  return $isElementNode(node) && !node.isInline();
}
function internalMakeRangeSelection(anchorKey, anchorOffset, focusKey, focusOffset, anchorType, focusType) {
  const editorState = getActiveEditorState();
  const selection = new RangeSelection($createPoint(anchorKey, anchorOffset, anchorType), $createPoint(focusKey, focusOffset, focusType), 0, "");
  selection.dirty = true;
  editorState._selection = selection;
  return selection;
}
function $createRangeSelection() {
  const anchor = $createPoint("root", 0, "element");
  const focus = $createPoint("root", 0, "element");
  return new RangeSelection(anchor, focus, 0, "");
}
function $createNodeSelection() {
  return new NodeSelection(/* @__PURE__ */ new Set());
}
function internalCreateSelection(editor) {
  const currentEditorState = editor.getEditorState();
  const lastSelection = currentEditorState._selection;
  const domSelection = getDOMSelection(editor._window);
  if ($isRangeSelection(lastSelection) || lastSelection == null) {
    return internalCreateRangeSelection(lastSelection, domSelection, editor, null);
  }
  return lastSelection.clone();
}
function internalCreateRangeSelection(lastSelection, domSelection, editor, event) {
  const windowObj = editor._window;
  if (windowObj === null) {
    return null;
  }
  const windowEvent = event || windowObj.event;
  const eventType = windowEvent ? windowEvent.type : void 0;
  const isSelectionChange = eventType === "selectionchange";
  const useDOMSelection = !getIsProcessingMutations() && (isSelectionChange || eventType === "beforeinput" || eventType === "compositionstart" || eventType === "compositionend" || eventType === "click" && windowEvent && windowEvent.detail === 3 || eventType === "drop" || eventType === void 0);
  let anchorDOM, focusDOM, anchorOffset, focusOffset;
  if (!$isRangeSelection(lastSelection) || useDOMSelection) {
    if (domSelection === null) {
      return null;
    }
    anchorDOM = domSelection.anchorNode;
    focusDOM = domSelection.focusNode;
    anchorOffset = domSelection.anchorOffset;
    focusOffset = domSelection.focusOffset;
    if (isSelectionChange && $isRangeSelection(lastSelection) && !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {
      return lastSelection.clone();
    }
  } else {
    return lastSelection.clone();
  }
  const resolvedSelectionPoints = internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection);
  if (resolvedSelectionPoints === null) {
    return null;
  }
  const [resolvedAnchorPoint, resolvedFocusPoint] = resolvedSelectionPoints;
  return new RangeSelection(resolvedAnchorPoint, resolvedFocusPoint, !$isRangeSelection(lastSelection) ? 0 : lastSelection.format, !$isRangeSelection(lastSelection) ? "" : lastSelection.style);
}
function $getSelection() {
  const editorState = getActiveEditorState();
  return editorState._selection;
}
function $getPreviousSelection() {
  const editor = getActiveEditor();
  return editor._editorState._selection;
}
function $updateElementSelectionOnCreateDeleteNode(selection, parentNode, nodeOffset, times = 1) {
  const anchor = selection.anchor;
  const focus = selection.focus;
  const anchorNode = anchor.getNode();
  const focusNode = focus.getNode();
  if (!parentNode.is(anchorNode) && !parentNode.is(focusNode)) {
    return;
  }
  const parentKey = parentNode.__key;
  if (selection.isCollapsed()) {
    const selectionOffset = anchor.offset;
    if (nodeOffset <= selectionOffset && times > 0 || nodeOffset < selectionOffset && times < 0) {
      const newSelectionOffset = Math.max(0, selectionOffset + times);
      anchor.set(parentKey, newSelectionOffset, "element");
      focus.set(parentKey, newSelectionOffset, "element");
      $updateSelectionResolveTextNodes(selection);
    }
  } else {
    const isBackward = selection.isBackward();
    const firstPoint = isBackward ? focus : anchor;
    const firstPointNode = firstPoint.getNode();
    const lastPoint = isBackward ? anchor : focus;
    const lastPointNode = lastPoint.getNode();
    if (parentNode.is(firstPointNode)) {
      const firstPointOffset = firstPoint.offset;
      if (nodeOffset <= firstPointOffset && times > 0 || nodeOffset < firstPointOffset && times < 0) {
        firstPoint.set(parentKey, Math.max(0, firstPointOffset + times), "element");
      }
    }
    if (parentNode.is(lastPointNode)) {
      const lastPointOffset = lastPoint.offset;
      if (nodeOffset <= lastPointOffset && times > 0 || nodeOffset < lastPointOffset && times < 0) {
        lastPoint.set(parentKey, Math.max(0, lastPointOffset + times), "element");
      }
    }
  }
  $updateSelectionResolveTextNodes(selection);
}
function $updateSelectionResolveTextNodes(selection) {
  const anchor = selection.anchor;
  const anchorOffset = anchor.offset;
  const focus = selection.focus;
  const focusOffset = focus.offset;
  const anchorNode = anchor.getNode();
  const focusNode = focus.getNode();
  if (selection.isCollapsed()) {
    if (!$isElementNode(anchorNode)) {
      return;
    }
    const childSize = anchorNode.getChildrenSize();
    const anchorOffsetAtEnd = anchorOffset >= childSize;
    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);
    if ($isTextNode(child)) {
      let newOffset = 0;
      if (anchorOffsetAtEnd) {
        newOffset = child.getTextContentSize();
      }
      anchor.set(child.__key, newOffset, "text");
      focus.set(child.__key, newOffset, "text");
    }
    return;
  }
  if ($isElementNode(anchorNode)) {
    const childSize = anchorNode.getChildrenSize();
    const anchorOffsetAtEnd = anchorOffset >= childSize;
    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);
    if ($isTextNode(child)) {
      let newOffset = 0;
      if (anchorOffsetAtEnd) {
        newOffset = child.getTextContentSize();
      }
      anchor.set(child.__key, newOffset, "text");
    }
  }
  if ($isElementNode(focusNode)) {
    const childSize = focusNode.getChildrenSize();
    const focusOffsetAtEnd = focusOffset >= childSize;
    const child = focusOffsetAtEnd ? focusNode.getChildAtIndex(childSize - 1) : focusNode.getChildAtIndex(focusOffset);
    if ($isTextNode(child)) {
      let newOffset = 0;
      if (focusOffsetAtEnd) {
        newOffset = child.getTextContentSize();
      }
      focus.set(child.__key, newOffset, "text");
    }
  }
}
function applySelectionTransforms(nextEditorState, editor) {
  const prevEditorState = editor.getEditorState();
  const prevSelection = prevEditorState._selection;
  const nextSelection = nextEditorState._selection;
  if ($isRangeSelection(nextSelection)) {
    const anchor = nextSelection.anchor;
    const focus = nextSelection.focus;
    let anchorNode;
    if (anchor.type === "text") {
      anchorNode = anchor.getNode();
      anchorNode.selectionTransform(prevSelection, nextSelection);
    }
    if (focus.type === "text") {
      const focusNode = focus.getNode();
      if (anchorNode !== focusNode) {
        focusNode.selectionTransform(prevSelection, nextSelection);
      }
    }
  }
}
function moveSelectionPointToSibling(point, node, parent, prevSibling, nextSibling) {
  let siblingKey = null;
  let offset = 0;
  let type = null;
  if (prevSibling !== null) {
    siblingKey = prevSibling.__key;
    if ($isTextNode(prevSibling)) {
      offset = prevSibling.getTextContentSize();
      type = "text";
    } else if ($isElementNode(prevSibling)) {
      offset = prevSibling.getChildrenSize();
      type = "element";
    }
  } else {
    if (nextSibling !== null) {
      siblingKey = nextSibling.__key;
      if ($isTextNode(nextSibling)) {
        type = "text";
      } else if ($isElementNode(nextSibling)) {
        type = "element";
      }
    }
  }
  if (siblingKey !== null && type !== null) {
    point.set(siblingKey, offset, type);
  } else {
    offset = node.getIndexWithinParent();
    if (offset === -1) {
      offset = parent.getChildrenSize();
    }
    point.set(parent.__key, offset, "element");
  }
}
function adjustPointOffsetForMergedSibling(point, isBefore, key, target, textLength) {
  if (point.type === "text") {
    point.key = key;
    if (!isBefore) {
      point.offset += textLength;
    }
  } else if (point.offset > target.getIndexWithinParent()) {
    point.offset -= 1;
  }
}
function updateDOMSelection(prevSelection, nextSelection, editor, domSelection, tags, rootElement, nodeCount) {
  const anchorDOMNode = domSelection.anchorNode;
  const focusDOMNode = domSelection.focusNode;
  const anchorOffset = domSelection.anchorOffset;
  const focusOffset = domSelection.focusOffset;
  const activeElement = document.activeElement;
  if (tags.has("collaboration") && activeElement !== rootElement || activeElement !== null && isSelectionCapturedInDecoratorInput(activeElement)) {
    return;
  }
  if (!$isRangeSelection(nextSelection)) {
    if (prevSelection !== null && isSelectionWithinEditor(editor, anchorDOMNode, focusDOMNode)) {
      domSelection.removeAllRanges();
    }
    return;
  }
  const anchor = nextSelection.anchor;
  const focus = nextSelection.focus;
  const anchorKey = anchor.key;
  const focusKey = focus.key;
  const anchorDOM = getElementByKeyOrThrow(editor, anchorKey);
  const focusDOM = getElementByKeyOrThrow(editor, focusKey);
  const nextAnchorOffset = anchor.offset;
  const nextFocusOffset = focus.offset;
  const nextFormat = nextSelection.format;
  const nextStyle = nextSelection.style;
  const isCollapsed = nextSelection.isCollapsed();
  let nextAnchorNode = anchorDOM;
  let nextFocusNode = focusDOM;
  let anchorFormatOrStyleChanged = false;
  if (anchor.type === "text") {
    nextAnchorNode = getDOMTextNode(anchorDOM);
    const anchorNode = anchor.getNode();
    anchorFormatOrStyleChanged = anchorNode.getFormat() !== nextFormat || anchorNode.getStyle() !== nextStyle;
  } else if ($isRangeSelection(prevSelection) && prevSelection.anchor.type === "text") {
    anchorFormatOrStyleChanged = true;
  }
  if (focus.type === "text") {
    nextFocusNode = getDOMTextNode(focusDOM);
  }
  if (nextAnchorNode === null || nextFocusNode === null) {
    return;
  }
  if (isCollapsed && (prevSelection === null || anchorFormatOrStyleChanged || $isRangeSelection(prevSelection) && (prevSelection.format !== nextFormat || prevSelection.style !== nextStyle))) {
    markCollapsedSelectionFormat(nextFormat, nextStyle, nextAnchorOffset, anchorKey, performance.now());
  }
  if (anchorOffset === nextAnchorOffset && focusOffset === nextFocusOffset && anchorDOMNode === nextAnchorNode && focusDOMNode === nextFocusNode && // Badly interpreted range selection when collapsed - #1482
  !(domSelection.type === "Range" && isCollapsed)) {
    if (activeElement === null || !rootElement.contains(activeElement)) {
      rootElement.focus({
        preventScroll: true
      });
    }
    if (anchor.type !== "element") {
      return;
    }
  }
  try {
    domSelection.setBaseAndExtent(nextAnchorNode, nextAnchorOffset, nextFocusNode, nextFocusOffset);
  } catch (error) {
  }
  if (!tags.has("skip-scroll-into-view") && nextSelection.isCollapsed() && rootElement !== null && rootElement === document.activeElement) {
    const selectionTarget = nextSelection instanceof RangeSelection && nextSelection.anchor.type === "element" ? nextAnchorNode.childNodes[nextAnchorOffset] || null : domSelection.rangeCount > 0 ? domSelection.getRangeAt(0) : null;
    if (selectionTarget !== null) {
      let selectionRect;
      if (selectionTarget instanceof Text) {
        const range = document.createRange();
        range.selectNode(selectionTarget);
        selectionRect = range.getBoundingClientRect();
      } else {
        selectionRect = selectionTarget.getBoundingClientRect();
      }
      scrollIntoViewIfNeeded(editor, selectionRect, rootElement);
    }
  }
  markSelectionChangeFromDOMUpdate();
}
function $insertNodes(nodes) {
  let selection = $getSelection() || $getPreviousSelection();
  if (selection === null) {
    selection = $getRoot().selectEnd();
  }
  selection.insertNodes(nodes);
}
function $getTextContent() {
  const selection = $getSelection();
  if (selection === null) {
    return "";
  }
  return selection.getTextContent();
}
function removeTextAndSplitBlock(selection) {
  if (!selection.isCollapsed()) {
    selection.removeText();
  }
  const anchor = selection.anchor;
  let node = anchor.getNode();
  let offset = anchor.offset;
  while (!INTERNAL_$isBlock(node)) {
    [node, offset] = splitNodeAtPoint(node, offset);
  }
  return offset;
}
function splitNodeAtPoint(node, offset) {
  const parent = node.getParent();
  if (!parent) {
    const paragraph = $createParagraphNode();
    $getRoot().append(paragraph);
    paragraph.select();
    return [$getRoot(), 0];
  }
  if ($isTextNode(node)) {
    const split = node.splitText(offset);
    if (split.length === 0) {
      return [parent, node.getIndexWithinParent()];
    }
    const x2 = offset === 0 ? 0 : 1;
    const index = split[0].getIndexWithinParent() + x2;
    return [parent, index];
  }
  if (!$isElementNode(node) || offset === 0) {
    return [parent, node.getIndexWithinParent()];
  }
  const firstToAppend = node.getChildAtIndex(offset);
  if (firstToAppend) {
    const insertPoint = new RangeSelection($createPoint(node.__key, offset, "element"), $createPoint(node.__key, offset, "element"), 0, "");
    const newElement = node.insertNewAfter(insertPoint);
    if (newElement) {
      newElement.append(firstToAppend, ...firstToAppend.getNextSiblings());
    }
  }
  return [parent, node.getIndexWithinParent() + 1];
}
function $wrapInlineNodes(nodes) {
  const virtualRoot = $createParagraphNode();
  let currentBlock = null;
  for (let i2 = 0; i2 < nodes.length; i2++) {
    const node = nodes[i2];
    const isLineBreakNode = $isLineBreakNode(node);
    if (isLineBreakNode || $isDecoratorNode(node) && node.isInline() || $isElementNode(node) && node.isInline() || $isTextNode(node) || node.isParentRequired()) {
      if (currentBlock === null) {
        currentBlock = node.createParentElementNode();
        virtualRoot.append(currentBlock);
        if (isLineBreakNode) {
          continue;
        }
      }
      if (currentBlock !== null) {
        currentBlock.append(node);
      }
    } else {
      virtualRoot.append(node);
      currentBlock = null;
    }
  }
  return virtualRoot;
}
var activeEditorState = null;
var activeEditor = null;
var isReadOnlyMode = false;
var isAttemptingToRecoverFromReconcilerError = false;
var infiniteTransformCount = 0;
var observerOptions = {
  characterData: true,
  childList: true,
  subtree: true
};
function isCurrentlyReadOnlyMode() {
  return isReadOnlyMode || activeEditorState !== null && activeEditorState._readOnly;
}
function errorOnReadOnly() {
  if (isReadOnlyMode) {
    {
      throw Error(`Cannot use method in read-only mode.`);
    }
  }
}
function errorOnInfiniteTransforms() {
  if (infiniteTransformCount > 99) {
    {
      throw Error(`One or more transforms are endlessly triggering additional transforms. May have encountered infinite recursion caused by transforms that have their preconditions too lose and/or conflict with each other.`);
    }
  }
}
function getActiveEditorState() {
  if (activeEditorState === null) {
    {
      throw Error(`Unable to find an active editor state. State helpers or node methods can only be used synchronously during the callback of editor.update() or editorState.read().`);
    }
  }
  return activeEditorState;
}
function getActiveEditor() {
  if (activeEditor === null) {
    {
      throw Error(`Unable to find an active editor. This method can only be used synchronously during the callback of editor.update().`);
    }
  }
  return activeEditor;
}
function internalGetActiveEditor() {
  return activeEditor;
}
function $applyTransforms(editor, node, transformsCache) {
  const type = node.__type;
  const registeredNode = getRegisteredNodeOrThrow(editor, type);
  let transformsArr = transformsCache.get(type);
  if (transformsArr === void 0) {
    transformsArr = Array.from(registeredNode.transforms);
    transformsCache.set(type, transformsArr);
  }
  const transformsArrLength = transformsArr.length;
  for (let i2 = 0; i2 < transformsArrLength; i2++) {
    transformsArr[i2](node);
    if (!node.isAttached()) {
      break;
    }
  }
}
function $isNodeValidForTransform(node, compositionKey) {
  return node !== void 0 && // We don't want to transform nodes being composed
  node.__key !== compositionKey && node.isAttached();
}
function $normalizeAllDirtyTextNodes(editorState, editor) {
  const dirtyLeaves = editor._dirtyLeaves;
  const nodeMap = editorState._nodeMap;
  for (const nodeKey of dirtyLeaves) {
    const node = nodeMap.get(nodeKey);
    if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {
      $normalizeTextNode(node);
    }
  }
}
function $applyAllTransforms(editorState, editor) {
  const dirtyLeaves = editor._dirtyLeaves;
  const dirtyElements = editor._dirtyElements;
  const nodeMap = editorState._nodeMap;
  const compositionKey = $getCompositionKey();
  const transformsCache = /* @__PURE__ */ new Map();
  let untransformedDirtyLeaves = dirtyLeaves;
  let untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;
  let untransformedDirtyElements = dirtyElements;
  let untransformedDirtyElementsLength = untransformedDirtyElements.size;
  while (untransformedDirtyLeavesLength > 0 || untransformedDirtyElementsLength > 0) {
    if (untransformedDirtyLeavesLength > 0) {
      editor._dirtyLeaves = /* @__PURE__ */ new Set();
      for (const nodeKey of untransformedDirtyLeaves) {
        const node = nodeMap.get(nodeKey);
        if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {
          $normalizeTextNode(node);
        }
        if (node !== void 0 && $isNodeValidForTransform(node, compositionKey)) {
          $applyTransforms(editor, node, transformsCache);
        }
        dirtyLeaves.add(nodeKey);
      }
      untransformedDirtyLeaves = editor._dirtyLeaves;
      untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;
      if (untransformedDirtyLeavesLength > 0) {
        infiniteTransformCount++;
        continue;
      }
    }
    editor._dirtyLeaves = /* @__PURE__ */ new Set();
    editor._dirtyElements = /* @__PURE__ */ new Map();
    for (const currentUntransformedDirtyElement of untransformedDirtyElements) {
      const nodeKey = currentUntransformedDirtyElement[0];
      const intentionallyMarkedAsDirty = currentUntransformedDirtyElement[1];
      if (nodeKey !== "root" && !intentionallyMarkedAsDirty) {
        continue;
      }
      const node = nodeMap.get(nodeKey);
      if (node !== void 0 && $isNodeValidForTransform(node, compositionKey)) {
        $applyTransforms(editor, node, transformsCache);
      }
      dirtyElements.set(nodeKey, intentionallyMarkedAsDirty);
    }
    untransformedDirtyLeaves = editor._dirtyLeaves;
    untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;
    untransformedDirtyElements = editor._dirtyElements;
    untransformedDirtyElementsLength = untransformedDirtyElements.size;
    infiniteTransformCount++;
  }
  editor._dirtyLeaves = dirtyLeaves;
  editor._dirtyElements = dirtyElements;
}
function $parseSerializedNode(serializedNode) {
  const internalSerializedNode = serializedNode;
  return $parseSerializedNodeImpl(internalSerializedNode, getActiveEditor()._nodes);
}
function $parseSerializedNodeImpl(serializedNode, registeredNodes) {
  const type = serializedNode.type;
  const registeredNode = registeredNodes.get(type);
  if (registeredNode === void 0) {
    {
      throw Error(`parseEditorState: type "${type}" + not found`);
    }
  }
  const nodeClass = registeredNode.klass;
  if (serializedNode.type !== nodeClass.getType()) {
    {
      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .importJSON().`);
    }
  }
  const node = nodeClass.importJSON(serializedNode);
  const children = serializedNode.children;
  if ($isElementNode(node) && Array.isArray(children)) {
    for (let i2 = 0; i2 < children.length; i2++) {
      const serializedJSONChildNode = children[i2];
      const childNode = $parseSerializedNodeImpl(serializedJSONChildNode, registeredNodes);
      node.append(childNode);
    }
  }
  return node;
}
function parseEditorState(serializedEditorState, editor, updateFn) {
  const editorState = createEmptyEditorState();
  const previousActiveEditorState = activeEditorState;
  const previousReadOnlyMode = isReadOnlyMode;
  const previousActiveEditor = activeEditor;
  const previousDirtyElements = editor._dirtyElements;
  const previousDirtyLeaves = editor._dirtyLeaves;
  const previousCloneNotNeeded = editor._cloneNotNeeded;
  const previousDirtyType = editor._dirtyType;
  editor._dirtyElements = /* @__PURE__ */ new Map();
  editor._dirtyLeaves = /* @__PURE__ */ new Set();
  editor._cloneNotNeeded = /* @__PURE__ */ new Set();
  editor._dirtyType = 0;
  activeEditorState = editorState;
  isReadOnlyMode = false;
  activeEditor = editor;
  try {
    const registeredNodes = editor._nodes;
    const serializedNode = serializedEditorState.root;
    $parseSerializedNodeImpl(serializedNode, registeredNodes);
    if (updateFn) {
      updateFn();
    }
    editorState._readOnly = true;
    {
      handleDEVOnlyPendingUpdateGuarantees(editorState);
    }
  } catch (error) {
    if (error instanceof Error) {
      editor._onError(error);
    }
  } finally {
    editor._dirtyElements = previousDirtyElements;
    editor._dirtyLeaves = previousDirtyLeaves;
    editor._cloneNotNeeded = previousCloneNotNeeded;
    editor._dirtyType = previousDirtyType;
    activeEditorState = previousActiveEditorState;
    isReadOnlyMode = previousReadOnlyMode;
    activeEditor = previousActiveEditor;
  }
  return editorState;
}
function readEditorState(editorState, callbackFn) {
  const previousActiveEditorState = activeEditorState;
  const previousReadOnlyMode = isReadOnlyMode;
  const previousActiveEditor = activeEditor;
  activeEditorState = editorState;
  isReadOnlyMode = true;
  activeEditor = null;
  try {
    return callbackFn();
  } finally {
    activeEditorState = previousActiveEditorState;
    isReadOnlyMode = previousReadOnlyMode;
    activeEditor = previousActiveEditor;
  }
}
function handleDEVOnlyPendingUpdateGuarantees(pendingEditorState) {
  const nodeMap = pendingEditorState._nodeMap;
  nodeMap.set = () => {
    throw new Error("Cannot call set() on a frozen Lexical node map");
  };
  nodeMap.clear = () => {
    throw new Error("Cannot call clear() on a frozen Lexical node map");
  };
  nodeMap.delete = () => {
    throw new Error("Cannot call delete() on a frozen Lexical node map");
  };
}
function commitPendingUpdates(editor, recoveryEditorState) {
  const pendingEditorState = editor._pendingEditorState;
  const rootElement = editor._rootElement;
  const shouldSkipDOM = editor._headless || rootElement === null;
  if (pendingEditorState === null) {
    return;
  }
  const currentEditorState = editor._editorState;
  const currentSelection = currentEditorState._selection;
  const pendingSelection = pendingEditorState._selection;
  const needsUpdate = editor._dirtyType !== NO_DIRTY_NODES;
  const previousActiveEditorState = activeEditorState;
  const previousReadOnlyMode = isReadOnlyMode;
  const previousActiveEditor = activeEditor;
  const previouslyUpdating = editor._updating;
  const observer = editor._observer;
  let mutatedNodes2 = null;
  editor._pendingEditorState = null;
  editor._editorState = pendingEditorState;
  if (!shouldSkipDOM && needsUpdate && observer !== null) {
    activeEditor = editor;
    activeEditorState = pendingEditorState;
    isReadOnlyMode = false;
    editor._updating = true;
    try {
      const dirtyType = editor._dirtyType;
      const dirtyElements2 = editor._dirtyElements;
      const dirtyLeaves2 = editor._dirtyLeaves;
      observer.disconnect();
      mutatedNodes2 = reconcileRoot(currentEditorState, pendingEditorState, editor, dirtyType, dirtyElements2, dirtyLeaves2);
    } catch (error) {
      if (error instanceof Error) {
        editor._onError(error);
      }
      if (!isAttemptingToRecoverFromReconcilerError) {
        resetEditor(editor, null, rootElement, pendingEditorState);
        initMutationObserver(editor);
        editor._dirtyType = FULL_RECONCILE;
        isAttemptingToRecoverFromReconcilerError = true;
        commitPendingUpdates(editor, currentEditorState);
        isAttemptingToRecoverFromReconcilerError = false;
      } else {
        throw error;
      }
      return;
    } finally {
      observer.observe(rootElement, observerOptions);
      editor._updating = previouslyUpdating;
      activeEditorState = previousActiveEditorState;
      isReadOnlyMode = previousReadOnlyMode;
      activeEditor = previousActiveEditor;
    }
  }
  if (!pendingEditorState._readOnly) {
    pendingEditorState._readOnly = true;
    {
      handleDEVOnlyPendingUpdateGuarantees(pendingEditorState);
      if ($isRangeSelection(pendingSelection)) {
        Object.freeze(pendingSelection.anchor);
        Object.freeze(pendingSelection.focus);
      }
      Object.freeze(pendingSelection);
    }
  }
  const dirtyLeaves = editor._dirtyLeaves;
  const dirtyElements = editor._dirtyElements;
  const normalizedNodes = editor._normalizedNodes;
  const tags = editor._updateTags;
  const deferred = editor._deferred;
  if (needsUpdate) {
    editor._dirtyType = NO_DIRTY_NODES;
    editor._cloneNotNeeded.clear();
    editor._dirtyLeaves = /* @__PURE__ */ new Set();
    editor._dirtyElements = /* @__PURE__ */ new Map();
    editor._normalizedNodes = /* @__PURE__ */ new Set();
    editor._updateTags = /* @__PURE__ */ new Set();
  }
  $garbageCollectDetachedDecorators(editor, pendingEditorState);
  const domSelection = shouldSkipDOM ? null : getDOMSelection(editor._window);
  if (editor._editable && // domSelection will be null in headless
  domSelection !== null && (needsUpdate || pendingSelection === null || pendingSelection.dirty)) {
    activeEditor = editor;
    activeEditorState = pendingEditorState;
    try {
      if (observer !== null) {
        observer.disconnect();
      }
      if (needsUpdate || pendingSelection === null || pendingSelection.dirty) {
        const blockCursorElement = editor._blockCursorElement;
        if (blockCursorElement !== null) {
          removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);
        }
        updateDOMSelection(currentSelection, pendingSelection, editor, domSelection, tags, rootElement);
      }
      updateDOMBlockCursorElement(editor, rootElement, pendingSelection);
      if (observer !== null) {
        observer.observe(rootElement, observerOptions);
      }
    } finally {
      activeEditor = previousActiveEditor;
      activeEditorState = previousActiveEditorState;
    }
  }
  if (mutatedNodes2 !== null) {
    triggerMutationListeners(editor, mutatedNodes2, tags, dirtyLeaves, currentEditorState);
  }
  if (!$isRangeSelection(pendingSelection) && pendingSelection !== null && (currentSelection === null || !currentSelection.is(pendingSelection))) {
    editor.dispatchCommand(SELECTION_CHANGE_COMMAND, void 0);
  }
  const pendingDecorators = editor._pendingDecorators;
  if (pendingDecorators !== null) {
    editor._decorators = pendingDecorators;
    editor._pendingDecorators = null;
    triggerListeners("decorator", editor, true, pendingDecorators);
  }
  triggerTextContentListeners(editor, recoveryEditorState || currentEditorState, pendingEditorState);
  triggerListeners("update", editor, true, {
    dirtyElements,
    dirtyLeaves,
    editorState: pendingEditorState,
    normalizedNodes,
    prevEditorState: recoveryEditorState || currentEditorState,
    tags
  });
  triggerDeferredUpdateCallbacks(editor, deferred);
  triggerEnqueuedUpdates(editor);
}
function triggerTextContentListeners(editor, currentEditorState, pendingEditorState) {
  const currentTextContent = getEditorStateTextContent(currentEditorState);
  const latestTextContent = getEditorStateTextContent(pendingEditorState);
  if (currentTextContent !== latestTextContent) {
    triggerListeners("textcontent", editor, true, latestTextContent);
  }
}
function triggerMutationListeners(editor, mutatedNodes2, updateTags, dirtyLeaves, prevEditorState) {
  const listeners = Array.from(editor._listeners.mutation);
  const listenersLength = listeners.length;
  for (let i2 = 0; i2 < listenersLength; i2++) {
    const [listener, klass] = listeners[i2];
    const mutatedNodesByType = mutatedNodes2.get(klass);
    if (mutatedNodesByType !== void 0) {
      listener(mutatedNodesByType, {
        dirtyLeaves,
        prevEditorState,
        updateTags
      });
    }
  }
}
function triggerListeners(type, editor, isCurrentlyEnqueuingUpdates, ...payload) {
  const previouslyUpdating = editor._updating;
  editor._updating = isCurrentlyEnqueuingUpdates;
  try {
    const listeners = Array.from(editor._listeners[type]);
    for (let i2 = 0; i2 < listeners.length; i2++) {
      listeners[i2].apply(null, payload);
    }
  } finally {
    editor._updating = previouslyUpdating;
  }
}
function triggerCommandListeners(editor, type, payload) {
  if (editor._updating === false || activeEditor !== editor) {
    let returnVal = false;
    editor.update(() => {
      returnVal = triggerCommandListeners(editor, type, payload);
    });
    return returnVal;
  }
  const editors = getEditorsToPropagate(editor);
  for (let i2 = 4; i2 >= 0; i2--) {
    for (let e = 0; e < editors.length; e++) {
      const currentEditor = editors[e];
      const commandListeners = currentEditor._commands;
      const listenerInPriorityOrder = commandListeners.get(type);
      if (listenerInPriorityOrder !== void 0) {
        const listenersSet = listenerInPriorityOrder[i2];
        if (listenersSet !== void 0) {
          const listeners = Array.from(listenersSet);
          const listenersLength = listeners.length;
          for (let j2 = 0; j2 < listenersLength; j2++) {
            if (listeners[j2](payload, editor) === true) {
              return true;
            }
          }
        }
      }
    }
  }
  return false;
}
function triggerEnqueuedUpdates(editor) {
  const queuedUpdates = editor._updates;
  if (queuedUpdates.length !== 0) {
    const queuedUpdate = queuedUpdates.shift();
    if (queuedUpdate) {
      const [updateFn, options] = queuedUpdate;
      beginUpdate(editor, updateFn, options);
    }
  }
}
function triggerDeferredUpdateCallbacks(editor, deferred) {
  editor._deferred = [];
  if (deferred.length !== 0) {
    const previouslyUpdating = editor._updating;
    editor._updating = true;
    try {
      for (let i2 = 0; i2 < deferred.length; i2++) {
        deferred[i2]();
      }
    } finally {
      editor._updating = previouslyUpdating;
    }
  }
}
function processNestedUpdates(editor, initialSkipTransforms) {
  const queuedUpdates = editor._updates;
  let skipTransforms = initialSkipTransforms || false;
  while (queuedUpdates.length !== 0) {
    const queuedUpdate = queuedUpdates.shift();
    if (queuedUpdate) {
      const [nextUpdateFn, options] = queuedUpdate;
      let onUpdate;
      let tag;
      if (options !== void 0) {
        onUpdate = options.onUpdate;
        tag = options.tag;
        if (options.skipTransforms) {
          skipTransforms = true;
        }
        if (onUpdate) {
          editor._deferred.push(onUpdate);
        }
        if (tag) {
          editor._updateTags.add(tag);
        }
      }
      nextUpdateFn();
    }
  }
  return skipTransforms;
}
function beginUpdate(editor, updateFn, options) {
  const updateTags = editor._updateTags;
  let onUpdate;
  let tag;
  let skipTransforms = false;
  let discrete = false;
  if (options !== void 0) {
    onUpdate = options.onUpdate;
    tag = options.tag;
    if (tag != null) {
      updateTags.add(tag);
    }
    skipTransforms = options.skipTransforms || false;
    discrete = options.discrete || false;
  }
  if (onUpdate) {
    editor._deferred.push(onUpdate);
  }
  const currentEditorState = editor._editorState;
  let pendingEditorState = editor._pendingEditorState;
  let editorStateWasCloned = false;
  if (pendingEditorState === null || pendingEditorState._readOnly) {
    pendingEditorState = editor._pendingEditorState = cloneEditorState(pendingEditorState || currentEditorState);
    editorStateWasCloned = true;
  }
  pendingEditorState._flushSync = discrete;
  const previousActiveEditorState = activeEditorState;
  const previousReadOnlyMode = isReadOnlyMode;
  const previousActiveEditor = activeEditor;
  const previouslyUpdating = editor._updating;
  activeEditorState = pendingEditorState;
  isReadOnlyMode = false;
  editor._updating = true;
  activeEditor = editor;
  try {
    if (editorStateWasCloned) {
      if (editor._headless) {
        if (currentEditorState._selection !== null) {
          pendingEditorState._selection = currentEditorState._selection.clone();
        }
      } else {
        pendingEditorState._selection = internalCreateSelection(editor);
      }
    }
    const startingCompositionKey = editor._compositionKey;
    updateFn();
    skipTransforms = processNestedUpdates(editor, skipTransforms);
    applySelectionTransforms(pendingEditorState, editor);
    if (editor._dirtyType !== NO_DIRTY_NODES) {
      if (skipTransforms) {
        $normalizeAllDirtyTextNodes(pendingEditorState, editor);
      } else {
        $applyAllTransforms(pendingEditorState, editor);
      }
      processNestedUpdates(editor);
      $garbageCollectDetachedNodes(currentEditorState, pendingEditorState, editor._dirtyLeaves, editor._dirtyElements);
    }
    const endingCompositionKey = editor._compositionKey;
    if (startingCompositionKey !== endingCompositionKey) {
      pendingEditorState._flushSync = true;
    }
    const pendingSelection = pendingEditorState._selection;
    if ($isRangeSelection(pendingSelection)) {
      const pendingNodeMap = pendingEditorState._nodeMap;
      const anchorKey = pendingSelection.anchor.key;
      const focusKey = pendingSelection.focus.key;
      if (pendingNodeMap.get(anchorKey) === void 0 || pendingNodeMap.get(focusKey) === void 0) {
        {
          throw Error(`updateEditor: selection has been lost because the previously selected nodes have been removed and selection wasn't moved to another node. Ensure selection changes after removing/replacing a selected node.`);
        }
      }
    } else if ($isNodeSelection(pendingSelection)) {
      if (pendingSelection._nodes.size === 0) {
        pendingEditorState._selection = null;
      }
    }
  } catch (error) {
    if (error instanceof Error) {
      editor._onError(error);
    }
    editor._pendingEditorState = currentEditorState;
    editor._dirtyType = FULL_RECONCILE;
    editor._cloneNotNeeded.clear();
    editor._dirtyLeaves = /* @__PURE__ */ new Set();
    editor._dirtyElements.clear();
    commitPendingUpdates(editor);
    return;
  } finally {
    activeEditorState = previousActiveEditorState;
    isReadOnlyMode = previousReadOnlyMode;
    activeEditor = previousActiveEditor;
    editor._updating = previouslyUpdating;
    infiniteTransformCount = 0;
  }
  const shouldUpdate = editor._dirtyType !== NO_DIRTY_NODES || editorStateHasDirtySelection(pendingEditorState, editor);
  if (shouldUpdate) {
    if (pendingEditorState._flushSync) {
      pendingEditorState._flushSync = false;
      commitPendingUpdates(editor);
    } else if (editorStateWasCloned) {
      scheduleMicroTask(() => {
        commitPendingUpdates(editor);
      });
    }
  } else {
    pendingEditorState._flushSync = false;
    if (editorStateWasCloned) {
      updateTags.clear();
      editor._deferred = [];
      editor._pendingEditorState = null;
    }
  }
}
function updateEditor(editor, updateFn, options) {
  if (editor._updating) {
    editor._updates.push([updateFn, options]);
  } else {
    beginUpdate(editor, updateFn, options);
  }
}
var DecoratorNode = class extends LexicalNode {
  constructor(key) {
    super(key);
  }
  /**
   * The returned value is added to the LexicalEditor._decorators
   */
  decorate(editor, config) {
    {
      throw Error(`decorate: base method not extended`);
    }
  }
  isIsolated() {
    return false;
  }
  isInline() {
    return true;
  }
  isKeyboardSelectable() {
    return true;
  }
};
function $isDecoratorNode(node) {
  return node instanceof DecoratorNode;
}
var ElementNode = class extends LexicalNode {
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  constructor(key) {
    super(key);
    this.__first = null;
    this.__last = null;
    this.__size = 0;
    this.__format = 0;
    this.__indent = 0;
    this.__dir = null;
  }
  getFormat() {
    const self = this.getLatest();
    return self.__format;
  }
  getFormatType() {
    const format = this.getFormat();
    return ELEMENT_FORMAT_TO_TYPE[format] || "";
  }
  getIndent() {
    const self = this.getLatest();
    return self.__indent;
  }
  getChildren() {
    const children = [];
    let child = this.getFirstChild();
    while (child !== null) {
      children.push(child);
      child = child.getNextSibling();
    }
    return children;
  }
  getChildrenKeys() {
    const children = [];
    let child = this.getFirstChild();
    while (child !== null) {
      children.push(child.__key);
      child = child.getNextSibling();
    }
    return children;
  }
  getChildrenSize() {
    const self = this.getLatest();
    return self.__size;
  }
  isEmpty() {
    return this.getChildrenSize() === 0;
  }
  isDirty() {
    const editor = getActiveEditor();
    const dirtyElements = editor._dirtyElements;
    return dirtyElements !== null && dirtyElements.has(this.__key);
  }
  isLastChild() {
    const self = this.getLatest();
    const parentLastChild = this.getParentOrThrow().getLastChild();
    return parentLastChild !== null && parentLastChild.is(self);
  }
  getAllTextNodes() {
    const textNodes = [];
    let child = this.getFirstChild();
    while (child !== null) {
      if ($isTextNode(child)) {
        textNodes.push(child);
      }
      if ($isElementNode(child)) {
        const subChildrenNodes = child.getAllTextNodes();
        textNodes.push(...subChildrenNodes);
      }
      child = child.getNextSibling();
    }
    return textNodes;
  }
  getFirstDescendant() {
    let node = this.getFirstChild();
    while ($isElementNode(node)) {
      const child = node.getFirstChild();
      if (child === null) {
        break;
      }
      node = child;
    }
    return node;
  }
  getLastDescendant() {
    let node = this.getLastChild();
    while ($isElementNode(node)) {
      const child = node.getLastChild();
      if (child === null) {
        break;
      }
      node = child;
    }
    return node;
  }
  getDescendantByIndex(index) {
    const children = this.getChildren();
    const childrenLength = children.length;
    if (index >= childrenLength) {
      const resolvedNode2 = children[childrenLength - 1];
      return $isElementNode(resolvedNode2) && resolvedNode2.getLastDescendant() || resolvedNode2 || null;
    }
    const resolvedNode = children[index];
    return $isElementNode(resolvedNode) && resolvedNode.getFirstDescendant() || resolvedNode || null;
  }
  getFirstChild() {
    const self = this.getLatest();
    const firstKey = self.__first;
    return firstKey === null ? null : $getNodeByKey(firstKey);
  }
  getFirstChildOrThrow() {
    const firstChild = this.getFirstChild();
    if (firstChild === null) {
      {
        throw Error(`Expected node ${this.__key} to have a first child.`);
      }
    }
    return firstChild;
  }
  getLastChild() {
    const self = this.getLatest();
    const lastKey = self.__last;
    return lastKey === null ? null : $getNodeByKey(lastKey);
  }
  getLastChildOrThrow() {
    const lastChild = this.getLastChild();
    if (lastChild === null) {
      {
        throw Error(`Expected node ${this.__key} to have a last child.`);
      }
    }
    return lastChild;
  }
  getChildAtIndex(index) {
    const size = this.getChildrenSize();
    let node;
    let i2;
    if (index < size / 2) {
      node = this.getFirstChild();
      i2 = 0;
      while (node !== null && i2 <= index) {
        if (i2 === index) {
          return node;
        }
        node = node.getNextSibling();
        i2++;
      }
      return null;
    }
    node = this.getLastChild();
    i2 = size - 1;
    while (node !== null && i2 >= index) {
      if (i2 === index) {
        return node;
      }
      node = node.getPreviousSibling();
      i2--;
    }
    return null;
  }
  getTextContent() {
    let textContent = "";
    const children = this.getChildren();
    const childrenLength = children.length;
    for (let i2 = 0; i2 < childrenLength; i2++) {
      const child = children[i2];
      textContent += child.getTextContent();
      if ($isElementNode(child) && i2 !== childrenLength - 1 && !child.isInline()) {
        textContent += DOUBLE_LINE_BREAK;
      }
    }
    return textContent;
  }
  getTextContentSize() {
    let textContentSize = 0;
    const children = this.getChildren();
    const childrenLength = children.length;
    for (let i2 = 0; i2 < childrenLength; i2++) {
      const child = children[i2];
      textContentSize += child.getTextContentSize();
      if ($isElementNode(child) && i2 !== childrenLength - 1 && !child.isInline()) {
        textContentSize += DOUBLE_LINE_BREAK.length;
      }
    }
    return textContentSize;
  }
  getDirection() {
    const self = this.getLatest();
    return self.__dir;
  }
  hasFormat(type) {
    if (type !== "") {
      const formatFlag = ELEMENT_TYPE_TO_FORMAT[type];
      return (this.getFormat() & formatFlag) !== 0;
    }
    return false;
  }
  // Mutators
  select(_anchorOffset, _focusOffset) {
    errorOnReadOnly();
    const selection = $getSelection();
    let anchorOffset = _anchorOffset;
    let focusOffset = _focusOffset;
    const childrenCount = this.getChildrenSize();
    if (!this.canBeEmpty()) {
      if (_anchorOffset === 0 && _focusOffset === 0) {
        const firstChild = this.getFirstChild();
        if ($isTextNode(firstChild) || $isElementNode(firstChild)) {
          return firstChild.select(0, 0);
        }
      } else if ((_anchorOffset === void 0 || _anchorOffset === childrenCount) && (_focusOffset === void 0 || _focusOffset === childrenCount)) {
        const lastChild = this.getLastChild();
        if ($isTextNode(lastChild) || $isElementNode(lastChild)) {
          return lastChild.select();
        }
      }
    }
    if (anchorOffset === void 0) {
      anchorOffset = childrenCount;
    }
    if (focusOffset === void 0) {
      focusOffset = childrenCount;
    }
    const key = this.__key;
    if (!$isRangeSelection(selection)) {
      return internalMakeRangeSelection(key, anchorOffset, key, focusOffset, "element", "element");
    } else {
      selection.anchor.set(key, anchorOffset, "element");
      selection.focus.set(key, focusOffset, "element");
      selection.dirty = true;
    }
    return selection;
  }
  selectStart() {
    const firstNode = this.getFirstDescendant();
    return firstNode ? firstNode.selectStart() : this.select();
  }
  selectEnd() {
    const lastNode = this.getLastDescendant();
    return lastNode ? lastNode.selectEnd() : this.select();
  }
  clear() {
    const writableSelf = this.getWritable();
    const children = this.getChildren();
    children.forEach((child) => child.remove());
    return writableSelf;
  }
  append(...nodesToAppend) {
    return this.splice(this.getChildrenSize(), 0, nodesToAppend);
  }
  setDirection(direction) {
    const self = this.getWritable();
    self.__dir = direction;
    return self;
  }
  setFormat(type) {
    const self = this.getWritable();
    self.__format = type !== "" ? ELEMENT_TYPE_TO_FORMAT[type] : 0;
    return this;
  }
  setIndent(indentLevel) {
    const self = this.getWritable();
    self.__indent = indentLevel;
    return this;
  }
  splice(start, deleteCount, nodesToInsert) {
    const nodesToInsertLength = nodesToInsert.length;
    const oldSize = this.getChildrenSize();
    const writableSelf = this.getWritable();
    const writableSelfKey = writableSelf.__key;
    const nodesToInsertKeys = [];
    const nodesToRemoveKeys = [];
    const nodeAfterRange = this.getChildAtIndex(start + deleteCount);
    let nodeBeforeRange = null;
    let newSize = oldSize - deleteCount + nodesToInsertLength;
    if (start !== 0) {
      if (start === oldSize) {
        nodeBeforeRange = this.getLastChild();
      } else {
        const node = this.getChildAtIndex(start);
        if (node !== null) {
          nodeBeforeRange = node.getPreviousSibling();
        }
      }
    }
    if (deleteCount > 0) {
      let nodeToDelete = nodeBeforeRange === null ? this.getFirstChild() : nodeBeforeRange.getNextSibling();
      for (let i2 = 0; i2 < deleteCount; i2++) {
        if (nodeToDelete === null) {
          {
            throw Error(`splice: sibling not found`);
          }
        }
        const nextSibling = nodeToDelete.getNextSibling();
        const nodeKeyToDelete = nodeToDelete.__key;
        const writableNodeToDelete = nodeToDelete.getWritable();
        removeFromParent(writableNodeToDelete);
        nodesToRemoveKeys.push(nodeKeyToDelete);
        nodeToDelete = nextSibling;
      }
    }
    let prevNode = nodeBeforeRange;
    for (let i2 = 0; i2 < nodesToInsertLength; i2++) {
      const nodeToInsert = nodesToInsert[i2];
      if (prevNode !== null && nodeToInsert.is(prevNode)) {
        nodeBeforeRange = prevNode = prevNode.getPreviousSibling();
      }
      const writableNodeToInsert = nodeToInsert.getWritable();
      if (writableNodeToInsert.__parent === writableSelfKey) {
        newSize--;
      }
      removeFromParent(writableNodeToInsert);
      const nodeKeyToInsert = nodeToInsert.__key;
      if (prevNode === null) {
        writableSelf.__first = nodeKeyToInsert;
        writableNodeToInsert.__prev = null;
      } else {
        const writablePrevNode = prevNode.getWritable();
        writablePrevNode.__next = nodeKeyToInsert;
        writableNodeToInsert.__prev = writablePrevNode.__key;
      }
      if (nodeToInsert.__key === writableSelfKey) {
        {
          throw Error(`append: attempting to append self`);
        }
      }
      writableNodeToInsert.__parent = writableSelfKey;
      nodesToInsertKeys.push(nodeKeyToInsert);
      prevNode = nodeToInsert;
    }
    if (start + deleteCount === oldSize) {
      if (prevNode !== null) {
        const writablePrevNode = prevNode.getWritable();
        writablePrevNode.__next = null;
        writableSelf.__last = prevNode.__key;
      }
    } else if (nodeAfterRange !== null) {
      const writableNodeAfterRange = nodeAfterRange.getWritable();
      if (prevNode !== null) {
        const writablePrevNode = prevNode.getWritable();
        writableNodeAfterRange.__prev = prevNode.__key;
        writablePrevNode.__next = nodeAfterRange.__key;
      } else {
        writableNodeAfterRange.__prev = null;
      }
    }
    writableSelf.__size = newSize;
    if (nodesToRemoveKeys.length) {
      const selection = $getSelection();
      if ($isRangeSelection(selection)) {
        const nodesToRemoveKeySet = new Set(nodesToRemoveKeys);
        const nodesToInsertKeySet = new Set(nodesToInsertKeys);
        const {
          anchor,
          focus
        } = selection;
        if (isPointRemoved(anchor, nodesToRemoveKeySet, nodesToInsertKeySet)) {
          moveSelectionPointToSibling(anchor, anchor.getNode(), this, nodeBeforeRange, nodeAfterRange);
        }
        if (isPointRemoved(focus, nodesToRemoveKeySet, nodesToInsertKeySet)) {
          moveSelectionPointToSibling(focus, focus.getNode(), this, nodeBeforeRange, nodeAfterRange);
        }
        if (newSize === 0 && !this.canBeEmpty() && !$isRootOrShadowRoot(this)) {
          this.remove();
        }
      }
    }
    return writableSelf;
  }
  // JSON serialization
  exportJSON() {
    return {
      children: [],
      direction: this.getDirection(),
      format: this.getFormatType(),
      indent: this.getIndent(),
      type: "element",
      version: 1
    };
  }
  // These are intended to be extends for specific element heuristics.
  insertNewAfter(selection, restoreSelection) {
    return null;
  }
  canIndent() {
    return true;
  }
  /*
   * This method controls the behavior of a the node during backwards
   * deletion (i.e., backspace) when selection is at the beginning of
   * the node (offset 0)
   */
  collapseAtStart(selection) {
    return false;
  }
  excludeFromCopy(destination) {
    return false;
  }
  canReplaceWith(replacement) {
    return true;
  }
  canInsertAfter(node) {
    return true;
  }
  canBeEmpty() {
    return true;
  }
  canInsertTextBefore() {
    return true;
  }
  canInsertTextAfter() {
    return true;
  }
  isInline() {
    return false;
  }
  // A shadow root is a Node that behaves like RootNode. The shadow root (and RootNode) mark the
  // end of the hiercharchy, most implementations should treat it as there's nothing (upwards)
  // beyond this point. For example, node.getTopLevelElement(), when performed inside a TableCellNode
  // will return the immediate first child underneath TableCellNode instead of RootNode.
  isShadowRoot() {
    return false;
  }
  canMergeWith(node) {
    return false;
  }
  extractWithChild(child, selection, destination) {
    return false;
  }
};
function $isElementNode(node) {
  return node instanceof ElementNode;
}
function isPointRemoved(point, nodesToRemoveKeySet, nodesToInsertKeySet) {
  let node = point.getNode();
  while (node) {
    const nodeKey = node.__key;
    if (nodesToRemoveKeySet.has(nodeKey) && !nodesToInsertKeySet.has(nodeKey)) {
      return true;
    }
    node = node.getParent();
  }
  return false;
}
var RootNode = class _RootNode extends ElementNode {
  /** @internal */
  static getType() {
    return "root";
  }
  static clone() {
    return new _RootNode();
  }
  constructor() {
    super("root");
    this.__cachedText = null;
  }
  getTopLevelElementOrThrow() {
    {
      throw Error(`getTopLevelElementOrThrow: root nodes are not top level elements`);
    }
  }
  getTextContent() {
    const cachedText = this.__cachedText;
    if (isCurrentlyReadOnlyMode() || getActiveEditor()._dirtyType === NO_DIRTY_NODES) {
      if (cachedText !== null) {
        return cachedText;
      }
    }
    return super.getTextContent();
  }
  remove() {
    {
      throw Error(`remove: cannot be called on root nodes`);
    }
  }
  replace(node) {
    {
      throw Error(`replace: cannot be called on root nodes`);
    }
  }
  insertBefore(nodeToInsert) {
    {
      throw Error(`insertBefore: cannot be called on root nodes`);
    }
  }
  insertAfter(nodeToInsert) {
    {
      throw Error(`insertAfter: cannot be called on root nodes`);
    }
  }
  // View
  updateDOM(prevNode, dom) {
    return false;
  }
  // Mutate
  append(...nodesToAppend) {
    for (let i2 = 0; i2 < nodesToAppend.length; i2++) {
      const node = nodesToAppend[i2];
      if (!$isElementNode(node) && !$isDecoratorNode(node)) {
        {
          throw Error(`rootNode.append: Only element or decorator nodes can be appended to the root node`);
        }
      }
    }
    return super.append(...nodesToAppend);
  }
  static importJSON(serializedNode) {
    const node = $getRoot();
    node.setFormat(serializedNode.format);
    node.setIndent(serializedNode.indent);
    node.setDirection(serializedNode.direction);
    return node;
  }
  exportJSON() {
    return {
      children: [],
      direction: this.getDirection(),
      format: this.getFormatType(),
      indent: this.getIndent(),
      type: "root",
      version: 1
    };
  }
  collapseAtStart() {
    return true;
  }
};
function $createRootNode() {
  return new RootNode();
}
function $isRootNode(node) {
  return node instanceof RootNode;
}
function editorStateHasDirtySelection(editorState, editor) {
  const currentSelection = editor.getEditorState()._selection;
  const pendingSelection = editorState._selection;
  if (pendingSelection !== null) {
    if (pendingSelection.dirty || !pendingSelection.is(currentSelection)) {
      return true;
    }
  } else if (currentSelection !== null) {
    return true;
  }
  return false;
}
function cloneEditorState(current) {
  return new EditorState(new Map(current._nodeMap));
}
function createEmptyEditorState() {
  return new EditorState(/* @__PURE__ */ new Map([["root", $createRootNode()]]));
}
function exportNodeToJSON(node) {
  const serializedNode = node.exportJSON();
  const nodeClass = node.constructor;
  if (serializedNode.type !== nodeClass.getType()) {
    {
      throw Error(`LexicalNode: Node ${nodeClass.name} does not match the serialized type. Check if .exportJSON() is implemented and it is returning the correct type.`);
    }
  }
  if ($isElementNode(node)) {
    const serializedChildren = serializedNode.children;
    if (!Array.isArray(serializedChildren)) {
      {
        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);
      }
    }
    const children = node.getChildren();
    for (let i2 = 0; i2 < children.length; i2++) {
      const child = children[i2];
      const serializedChildNode = exportNodeToJSON(child);
      serializedChildren.push(serializedChildNode);
    }
  }
  return serializedNode;
}
var EditorState = class _EditorState {
  constructor(nodeMap, selection) {
    this._nodeMap = nodeMap;
    this._selection = selection || null;
    this._flushSync = false;
    this._readOnly = false;
  }
  isEmpty() {
    return this._nodeMap.size === 1 && this._selection === null;
  }
  read(callbackFn) {
    return readEditorState(this, callbackFn);
  }
  clone(selection) {
    const editorState = new _EditorState(this._nodeMap, selection === void 0 ? this._selection : selection);
    editorState._readOnly = true;
    return editorState;
  }
  toJSON() {
    return readEditorState(this, () => ({
      root: exportNodeToJSON($getRoot())
    }));
  }
};
var ParagraphNode = class _ParagraphNode extends ElementNode {
  static getType() {
    return "paragraph";
  }
  static clone(node) {
    return new _ParagraphNode(node.__key);
  }
  // View
  createDOM(config) {
    const dom = document.createElement("p");
    const classNames = getCachedClassNameArray(config.theme, "paragraph");
    if (classNames !== void 0) {
      const domClassList = dom.classList;
      domClassList.add(...classNames);
    }
    return dom;
  }
  updateDOM(prevNode, dom, config) {
    return false;
  }
  static importDOM() {
    return {
      p: (node) => ({
        conversion: convertParagraphElement,
        priority: 0
      })
    };
  }
  exportDOM(editor) {
    const {
      element
    } = super.exportDOM(editor);
    if (element && isHTMLElement(element)) {
      if (this.isEmpty()) {
        element.append(document.createElement("br"));
      }
      const formatType = this.getFormatType();
      element.style.textAlign = formatType;
      const direction = this.getDirection();
      if (direction) {
        element.dir = direction;
      }
      const indent = this.getIndent();
      if (indent > 0) {
        element.style.textIndent = `${indent * 20}px`;
      }
    }
    return {
      element
    };
  }
  static importJSON(serializedNode) {
    const node = $createParagraphNode();
    node.setFormat(serializedNode.format);
    node.setIndent(serializedNode.indent);
    node.setDirection(serializedNode.direction);
    return node;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      type: "paragraph",
      version: 1
    };
  }
  // Mutation
  insertNewAfter(_2, restoreSelection) {
    const newElement = $createParagraphNode();
    const direction = this.getDirection();
    newElement.setDirection(direction);
    this.insertAfter(newElement, restoreSelection);
    return newElement;
  }
  collapseAtStart() {
    const children = this.getChildren();
    if (children.length === 0 || $isTextNode(children[0]) && children[0].getTextContent().trim() === "") {
      const nextSibling = this.getNextSibling();
      if (nextSibling !== null) {
        this.selectNext();
        this.remove();
        return true;
      }
      const prevSibling = this.getPreviousSibling();
      if (prevSibling !== null) {
        this.selectPrevious();
        this.remove();
        return true;
      }
    }
    return false;
  }
};
function convertParagraphElement(element) {
  const node = $createParagraphNode();
  if (element.style) {
    node.setFormat(element.style.textAlign);
    const indent = parseInt(element.style.textIndent, 10) / 20;
    if (indent > 0) {
      node.setIndent(indent);
    }
  }
  return {
    node
  };
}
function $createParagraphNode() {
  return $applyNodeReplacement(new ParagraphNode());
}
function $isParagraphNode(node) {
  return node instanceof ParagraphNode;
}
var COMMAND_PRIORITY_EDITOR = 0;
var COMMAND_PRIORITY_LOW = 1;
var COMMAND_PRIORITY_NORMAL = 2;
var COMMAND_PRIORITY_HIGH = 3;
var COMMAND_PRIORITY_CRITICAL = 4;
function resetEditor(editor, prevRootElement, nextRootElement, pendingEditorState) {
  const keyNodeMap = editor._keyToDOMMap;
  keyNodeMap.clear();
  editor._editorState = createEmptyEditorState();
  editor._pendingEditorState = pendingEditorState;
  editor._compositionKey = null;
  editor._dirtyType = NO_DIRTY_NODES;
  editor._cloneNotNeeded.clear();
  editor._dirtyLeaves = /* @__PURE__ */ new Set();
  editor._dirtyElements.clear();
  editor._normalizedNodes = /* @__PURE__ */ new Set();
  editor._updateTags = /* @__PURE__ */ new Set();
  editor._updates = [];
  editor._blockCursorElement = null;
  const observer = editor._observer;
  if (observer !== null) {
    observer.disconnect();
    editor._observer = null;
  }
  if (prevRootElement !== null) {
    prevRootElement.textContent = "";
  }
  if (nextRootElement !== null) {
    nextRootElement.textContent = "";
    keyNodeMap.set("root", nextRootElement);
  }
}
function initializeConversionCache(nodes, additionalConversions) {
  const conversionCache = /* @__PURE__ */ new Map();
  const handledConversions = /* @__PURE__ */ new Set();
  const addConversionsToCache = (map) => {
    Object.keys(map).forEach((key) => {
      let currentCache = conversionCache.get(key);
      if (currentCache === void 0) {
        currentCache = [];
        conversionCache.set(key, currentCache);
      }
      currentCache.push(map[key]);
    });
  };
  nodes.forEach((node) => {
    const importDOM = node.klass.importDOM;
    if (importDOM == null || handledConversions.has(importDOM)) {
      return;
    }
    handledConversions.add(importDOM);
    const map = importDOM.call(node.klass);
    if (map !== null) {
      addConversionsToCache(map);
    }
  });
  if (additionalConversions) {
    addConversionsToCache(additionalConversions);
  }
  return conversionCache;
}
function createEditor(editorConfig) {
  const config = editorConfig || {};
  const activeEditor2 = internalGetActiveEditor();
  const theme = config.theme || {};
  const parentEditor = editorConfig === void 0 ? activeEditor2 : config.parentEditor || null;
  const disableEvents = config.disableEvents || false;
  const editorState = createEmptyEditorState();
  const namespace = config.namespace || (parentEditor !== null ? parentEditor._config.namespace : createUID());
  const initialEditorState = config.editorState;
  const nodes = [RootNode, TextNode, LineBreakNode, TabNode, ParagraphNode, ...config.nodes || []];
  const {
    onError,
    html
  } = config;
  const isEditable = config.editable !== void 0 ? config.editable : true;
  let registeredNodes;
  if (editorConfig === void 0 && activeEditor2 !== null) {
    registeredNodes = activeEditor2._nodes;
  } else {
    registeredNodes = /* @__PURE__ */ new Map();
    for (let i2 = 0; i2 < nodes.length; i2++) {
      let klass = nodes[i2];
      let replace = null;
      let replaceWithKlass = null;
      if (typeof klass !== "function") {
        const options = klass;
        klass = options.replace;
        replace = options.with;
        replaceWithKlass = options.withKlass || null;
      }
      {
        const name = klass.name;
        if (name !== "RootNode") {
          const proto = klass.prototype;
          ["getType", "clone"].forEach((method) => {
            if (!klass.hasOwnProperty(method)) {
              console.warn(`${name} must implement static "${method}" method`);
            }
          });
          if (
            // eslint-disable-next-line no-prototype-builtins
            !klass.hasOwnProperty("importDOM") && // eslint-disable-next-line no-prototype-builtins
            klass.hasOwnProperty("exportDOM")
          ) {
            console.warn(`${name} should implement "importDOM" if using a custom "exportDOM" method to ensure HTML serialization (important for copy & paste) works as expected`);
          }
          if (proto instanceof DecoratorNode) {
            if (!proto.hasOwnProperty("decorate")) {
              console.warn(`${proto.constructor.name} must implement "decorate" method`);
            }
          }
          if (
            // eslint-disable-next-line no-prototype-builtins
            !klass.hasOwnProperty("importJSON")
          ) {
            console.warn(`${name} should implement "importJSON" method to ensure JSON and default HTML serialization works as expected`);
          }
          if (
            // eslint-disable-next-line no-prototype-builtins
            !proto.hasOwnProperty("exportJSON")
          ) {
            console.warn(`${name} should implement "exportJSON" method to ensure JSON and default HTML serialization works as expected`);
          }
        }
      }
      const type = klass.getType();
      const transform = klass.transform();
      const transforms = /* @__PURE__ */ new Set();
      if (transform !== null) {
        transforms.add(transform);
      }
      registeredNodes.set(type, {
        exportDOM: html && html.export ? html.export.get(klass) : void 0,
        klass,
        replace,
        replaceWithKlass,
        transforms
      });
    }
  }
  const editor = new LexicalEditor(editorState, parentEditor, registeredNodes, {
    disableEvents,
    namespace,
    theme
  }, onError ? onError : console.error, initializeConversionCache(registeredNodes, html ? html.import : void 0), isEditable);
  if (initialEditorState !== void 0) {
    editor._pendingEditorState = initialEditorState;
    editor._dirtyType = FULL_RECONCILE;
  }
  return editor;
}
var LexicalEditor = class {
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  constructor(editorState, parentEditor, nodes, config, onError, htmlConversions, editable) {
    this._parentEditor = parentEditor;
    this._rootElement = null;
    this._editorState = editorState;
    this._pendingEditorState = null;
    this._compositionKey = null;
    this._deferred = [];
    this._keyToDOMMap = /* @__PURE__ */ new Map();
    this._updates = [];
    this._updating = false;
    this._listeners = {
      decorator: /* @__PURE__ */ new Set(),
      editable: /* @__PURE__ */ new Set(),
      mutation: /* @__PURE__ */ new Map(),
      root: /* @__PURE__ */ new Set(),
      textcontent: /* @__PURE__ */ new Set(),
      update: /* @__PURE__ */ new Set()
    };
    this._commands = /* @__PURE__ */ new Map();
    this._config = config;
    this._nodes = nodes;
    this._decorators = {};
    this._pendingDecorators = null;
    this._dirtyType = NO_DIRTY_NODES;
    this._cloneNotNeeded = /* @__PURE__ */ new Set();
    this._dirtyLeaves = /* @__PURE__ */ new Set();
    this._dirtyElements = /* @__PURE__ */ new Map();
    this._normalizedNodes = /* @__PURE__ */ new Set();
    this._updateTags = /* @__PURE__ */ new Set();
    this._observer = null;
    this._key = createUID();
    this._onError = onError;
    this._htmlConversions = htmlConversions;
    this._editable = editable;
    this._headless = parentEditor !== null && parentEditor._headless;
    this._window = null;
    this._blockCursorElement = null;
  }
  /**
   *
   * @returns true if the editor is currently in "composition" mode due to receiving input
   * through an IME, or 3P extension, for example. Returns false otherwise.
   */
  isComposing() {
    return this._compositionKey != null;
  }
  /**
   * Registers a listener for Editor update event. Will trigger the provided callback
   * each time the editor goes through an update (via {@link LexicalEditor.update}) until the
   * teardown function is called.
   *
   * @returns a teardown function that can be used to cleanup the listener.
   */
  registerUpdateListener(listener) {
    const listenerSetOrMap = this._listeners.update;
    listenerSetOrMap.add(listener);
    return () => {
      listenerSetOrMap.delete(listener);
    };
  }
  /**
   * Registers a listener for for when the editor changes between editable and non-editable states.
   * Will trigger the provided callback each time the editor transitions between these states until the
   * teardown function is called.
   *
   * @returns a teardown function that can be used to cleanup the listener.
   */
  registerEditableListener(listener) {
    const listenerSetOrMap = this._listeners.editable;
    listenerSetOrMap.add(listener);
    return () => {
      listenerSetOrMap.delete(listener);
    };
  }
  /**
   * Registers a listener for when the editor's decorator object changes. The decorator object contains
   * all DecoratorNode keys -> their decorated value. This is primarily used with external UI frameworks.
   *
   * Will trigger the provided callback each time the editor transitions between these states until the
   * teardown function is called.
   *
   * @returns a teardown function that can be used to cleanup the listener.
   */
  registerDecoratorListener(listener) {
    const listenerSetOrMap = this._listeners.decorator;
    listenerSetOrMap.add(listener);
    return () => {
      listenerSetOrMap.delete(listener);
    };
  }
  /**
   * Registers a listener for when Lexical commits an update to the DOM and the text content of
   * the editor changes from the previous state of the editor. If the text content is the
   * same between updates, no notifications to the listeners will happen.
   *
   * Will trigger the provided callback each time the editor transitions between these states until the
   * teardown function is called.
   *
   * @returns a teardown function that can be used to cleanup the listener.
   */
  registerTextContentListener(listener) {
    const listenerSetOrMap = this._listeners.textcontent;
    listenerSetOrMap.add(listener);
    return () => {
      listenerSetOrMap.delete(listener);
    };
  }
  /**
   * Registers a listener for when the editor's root DOM element (the content editable
   * Lexical attaches to) changes. This is primarily used to attach event listeners to the root
   *  element. The root listener function is executed directly upon registration and then on
   * any subsequent update.
   *
   * Will trigger the provided callback each time the editor transitions between these states until the
   * teardown function is called.
   *
   * @returns a teardown function that can be used to cleanup the listener.
   */
  registerRootListener(listener) {
    const listenerSetOrMap = this._listeners.root;
    listener(this._rootElement, null);
    listenerSetOrMap.add(listener);
    return () => {
      listener(null, this._rootElement);
      listenerSetOrMap.delete(listener);
    };
  }
  /**
   * Registers a listener that will trigger anytime the provided command
   * is dispatched, subject to priority. Listeners that run at a higher priority can "intercept"
   * commands and prevent them from propagating to other handlers by returning true.
   *
   * Listeners registered at the same priority level will run deterministically in the order of registration.
   *
   * @param command - the command that will trigger the callback.
   * @param listener - the function that will execute when the command is dispatched.
   * @param priority - the relative priority of the listener. 0 | 1 | 2 | 3 | 4
   * @returns a teardown function that can be used to cleanup the listener.
   */
  registerCommand(command, listener, priority) {
    if (priority === void 0) {
      {
        throw Error(`Listener for type "command" requires a "priority".`);
      }
    }
    const commandsMap = this._commands;
    if (!commandsMap.has(command)) {
      commandsMap.set(command, [/* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set()]);
    }
    const listenersInPriorityOrder = commandsMap.get(command);
    if (listenersInPriorityOrder === void 0) {
      {
        throw Error(`registerCommand: Command ${String(command)} not found in command map`);
      }
    }
    const listeners = listenersInPriorityOrder[priority];
    listeners.add(listener);
    return () => {
      listeners.delete(listener);
      if (listenersInPriorityOrder.every((listenersSet) => listenersSet.size === 0)) {
        commandsMap.delete(command);
      }
    };
  }
  /**
   * Registers a listener that will run when a Lexical node of the provided class is
   * mutated. The listener will receive a list of nodes along with the type of mutation
   * that was performed on each: created, destroyed, or updated.
   *
   * One common use case for this is to attach DOM event listeners to the underlying DOM nodes as Lexical nodes are created.
   * {@link LexicalEditor.getElementByKey} can be used for this.
   *
   * @param klass - The class of the node that you want to listen to mutations on.
   * @param listener - The logic you want to run when the node is mutated.
   * @returns a teardown function that can be used to cleanup the listener.
   */
  registerMutationListener(klass, listener) {
    const registeredNode = this._nodes.get(klass.getType());
    if (registeredNode === void 0) {
      {
        throw Error(`Node ${klass.name} has not been registered. Ensure node has been passed to createEditor.`);
      }
    }
    const mutations = this._listeners.mutation;
    mutations.set(listener, klass);
    return () => {
      mutations.delete(listener);
    };
  }
  /** @internal */
  registerNodeTransformToKlass(klass, listener) {
    const type = klass.getType();
    const registeredNode = this._nodes.get(type);
    if (registeredNode === void 0) {
      {
        throw Error(`Node ${klass.name} has not been registered. Ensure node has been passed to createEditor.`);
      }
    }
    const transforms = registeredNode.transforms;
    transforms.add(listener);
    return registeredNode;
  }
  /**
   * Registers a listener that will run when a Lexical node of the provided class is
   * marked dirty during an update. The listener will continue to run as long as the node
   * is marked dirty. There are no guarantees around the order of transform execution!
   *
   * Watch out for infinite loops. See [Node Transforms](https://lexical.dev/docs/concepts/transforms)
   * @param klass - The class of the node that you want to run transforms on.
   * @param listener - The logic you want to run when the node is updated.
   * @returns a teardown function that can be used to cleanup the listener.
   */
  registerNodeTransform(klass, listener) {
    const registeredNode = this.registerNodeTransformToKlass(klass, listener);
    const registeredNodes = [registeredNode];
    const replaceWithKlass = registeredNode.replaceWithKlass;
    if (replaceWithKlass != null) {
      const registeredReplaceWithNode = this.registerNodeTransformToKlass(replaceWithKlass, listener);
      registeredNodes.push(registeredReplaceWithNode);
    }
    markAllNodesAsDirty(this, klass.getType());
    return () => {
      registeredNodes.forEach((node) => node.transforms.delete(listener));
    };
  }
  /**
   * Used to assert that a certain node is registered, usually by plugins to ensure nodes that they
   * depend on have been registered.
   * @returns True if the editor has registered the provided node type, false otherwise.
   */
  hasNode(node) {
    return this._nodes.has(node.getType());
  }
  /**
   * Used to assert that certain nodes are registered, usually by plugins to ensure nodes that they
   * depend on have been registered.
   * @returns True if the editor has registered all of the provided node types, false otherwise.
   */
  hasNodes(nodes) {
    return nodes.every(this.hasNode.bind(this));
  }
  /**
   * Dispatches a command of the specified type with the specified payload.
   * This triggers all command listeners (set by {@link LexicalEditor.registerCommand})
   * for this type, passing them the provided payload.
   * @param type - the type of command listeners to trigger.
   * @param payload - the data to pass as an argument to the command listeners.
   */
  dispatchCommand(type, payload) {
    return dispatchCommand(this, type, payload);
  }
  /**
   * Gets a map of all decorators in the editor.
   * @returns A mapping of call decorator keys to their decorated content
   */
  getDecorators() {
    return this._decorators;
  }
  /**
   *
   * @returns the current root element of the editor. If you want to register
   * an event listener, do it via {@link LexicalEditor.registerRootListener}, since
   * this reference may not be stable.
   */
  getRootElement() {
    return this._rootElement;
  }
  /**
   * Gets the key of the editor
   * @returns The editor key
   */
  getKey() {
    return this._key;
  }
  /**
   * Imperatively set the root contenteditable element that Lexical listens
   * for events on.
   */
  setRootElement(nextRootElement) {
    const prevRootElement = this._rootElement;
    if (nextRootElement !== prevRootElement) {
      const classNames = getCachedClassNameArray(this._config.theme, "root");
      const pendingEditorState = this._pendingEditorState || this._editorState;
      this._rootElement = nextRootElement;
      resetEditor(this, prevRootElement, nextRootElement, pendingEditorState);
      if (prevRootElement !== null) {
        if (!this._config.disableEvents) {
          removeRootElementEvents(prevRootElement);
        }
        if (classNames != null) {
          prevRootElement.classList.remove(...classNames);
        }
      }
      if (nextRootElement !== null) {
        const windowObj = getDefaultView(nextRootElement);
        const style = nextRootElement.style;
        style.userSelect = "text";
        style.whiteSpace = "pre-wrap";
        style.wordBreak = "break-word";
        nextRootElement.setAttribute("data-lexical-editor", "true");
        this._window = windowObj;
        this._dirtyType = FULL_RECONCILE;
        initMutationObserver(this);
        this._updateTags.add("history-merge");
        commitPendingUpdates(this);
        if (!this._config.disableEvents) {
          addRootElementEvents(nextRootElement, this);
        }
        if (classNames != null) {
          nextRootElement.classList.add(...classNames);
        }
      } else {
        this._editorState = pendingEditorState;
        this._pendingEditorState = null;
        this._window = null;
      }
      triggerListeners("root", this, false, nextRootElement, prevRootElement);
    }
  }
  /**
   * Gets the underlying HTMLElement associated with the LexicalNode for the given key.
   * @returns the HTMLElement rendered by the LexicalNode associated with the key.
   * @param key - the key of the LexicalNode.
   */
  getElementByKey(key) {
    return this._keyToDOMMap.get(key) || null;
  }
  /**
   * Gets the active editor state.
   * @returns The editor state
   */
  getEditorState() {
    return this._editorState;
  }
  /**
   * Imperatively set the EditorState. Triggers reconciliation like an update.
   * @param editorState - the state to set the editor
   * @param options - options for the update.
   */
  setEditorState(editorState, options) {
    if (editorState.isEmpty()) {
      {
        throw Error(`setEditorState: the editor state is empty. Ensure the editor state's root node never becomes empty.`);
      }
    }
    flushRootMutations(this);
    const pendingEditorState = this._pendingEditorState;
    const tags = this._updateTags;
    const tag = options !== void 0 ? options.tag : null;
    if (pendingEditorState !== null && !pendingEditorState.isEmpty()) {
      if (tag != null) {
        tags.add(tag);
      }
      commitPendingUpdates(this);
    }
    this._pendingEditorState = editorState;
    this._dirtyType = FULL_RECONCILE;
    this._dirtyElements.set("root", false);
    this._compositionKey = null;
    if (tag != null) {
      tags.add(tag);
    }
    commitPendingUpdates(this);
  }
  /**
   * Parses a SerializedEditorState (usually produced by {@link EditorState.toJSON}) and returns
   * and EditorState object that can be, for example, passed to {@link LexicalEditor.setEditorState}. Typically,
   * deserliazation from JSON stored in a database uses this method.
   * @param maybeStringifiedEditorState
   * @param updateFn
   * @returns
   */
  parseEditorState(maybeStringifiedEditorState, updateFn) {
    const serializedEditorState = typeof maybeStringifiedEditorState === "string" ? JSON.parse(maybeStringifiedEditorState) : maybeStringifiedEditorState;
    return parseEditorState(serializedEditorState, this, updateFn);
  }
  /**
   * Executes an update to the editor state. The updateFn callback is the ONLY place
   * where Lexical editor state can be safely mutated.
   * @param updateFn - A function that has access to writable editor state.
   * @param options - A bag of options to control the behavior of the update.
   * @param options.onUpdate - A function to run once the update is complete.
   * Useful for synchronizing updates in some cases.
   * @param options.skipTransforms - Setting this to true will suppress all node
   * transforms for this update cycle.
   * @param options.tag - A tag to identify this update, in an update listener, for instance.
   * Some tags are reserved by the core and control update behavior in different ways.
   * @param options.discrete - If true, prevents this update from being batched, forcing it to
   * run synchronously.
   */
  update(updateFn, options) {
    updateEditor(this, updateFn, options);
  }
  /**
   * Focuses the editor
   * @param callbackFn - A function to run after the editor is focused.
   * @param options - A bag of options
   * @param options.defaultSelection - Where to move selection when the editor is
   * focused. Can be rootStart, rootEnd, or undefined. Defaults to rootEnd.
   */
  focus(callbackFn, options = {}) {
    const rootElement = this._rootElement;
    if (rootElement !== null) {
      rootElement.setAttribute("autocapitalize", "off");
      updateEditor(this, () => {
        const selection = $getSelection();
        const root = $getRoot();
        if (selection !== null) {
          selection.dirty = true;
        } else if (root.getChildrenSize() !== 0) {
          if (options.defaultSelection === "rootStart") {
            root.selectStart();
          } else {
            root.selectEnd();
          }
        }
      }, {
        onUpdate: () => {
          rootElement.removeAttribute("autocapitalize");
          if (callbackFn) {
            callbackFn();
          }
        },
        tag: "focus"
      });
      if (this._pendingEditorState === null) {
        rootElement.removeAttribute("autocapitalize");
      }
    }
  }
  /**
   * Removes focus from the editor.
   */
  blur() {
    const rootElement = this._rootElement;
    if (rootElement !== null) {
      rootElement.blur();
    }
    const domSelection = getDOMSelection(this._window);
    if (domSelection !== null) {
      domSelection.removeAllRanges();
    }
  }
  /**
   * Returns true if the editor is editable, false otherwise.
   * @returns True if the editor is editable, false otherwise.
   */
  isEditable() {
    return this._editable;
  }
  /**
   * Sets the editable property of the editor. When false, the
   * editor will not listen for user events on the underling contenteditable.
   * @param editable - the value to set the editable mode to.
   */
  setEditable(editable) {
    if (this._editable !== editable) {
      this._editable = editable;
      triggerListeners("editable", this, true, editable);
    }
  }
  /**
   * Returns a JSON-serializable javascript object NOT a JSON string.
   * You still must call JSON.stringify (or something else) to turn the
   * state into a string you can transfer over the wire and store in a database.
   *
   * See {@link LexicalNode.exportJSON}
   *
   * @returns A JSON-serializable javascript object
   */
  toJSON() {
    return {
      editorState: this._editorState.toJSON()
    };
  }
};

// ../node_modules/lexical/Lexical.prod.esm.js
var t = {};
var r = {};
var i = {};
var s = {};
var o = {};
var l = {};
var c = {};
var u = {};
var a = {};
var f = {};
var d = {};
var h = {};
var g = {};
var _ = {};
var p = {};
var y = {};
var m = {};
var x = {};
var v = {};
var T = {};
var S = {};
var k = {};
var C = {};
var b = {};
var N = {};
var w = {};
var M = {};
var W = {};
var z = {};
var $ = {};
var H = function(e) {
  const t2 = new URLSearchParams();
  t2.append("code", e);
  for (let e2 = 1; e2 < arguments.length; e2++)
    t2.append("v", arguments[e2]);
  throw Error(`Minified Lexical error #${e}; visit https://lexical.dev/docs/error?${t2} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`);
};
var j = "undefined" != typeof window && void 0 !== window.document && void 0 !== window.document.createElement;
var q = j && "documentMode" in document ? document.documentMode : null;
var Q = j && /Mac|iPod|iPhone|iPad/.test(navigator.platform);
var X = j && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
var Y = !(!j || !("InputEvent" in window) || q) && "getTargetRanges" in new window.InputEvent("input");
var Z = j && /Version\/[\d.]+.*Safari/.test(navigator.userAgent);
var G = j && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
var ee = j && /Android/.test(navigator.userAgent);
var te = j && /^(?=.*Chrome).*/i.test(navigator.userAgent);
var ne = j && ee && te;
var re = j && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !te;
var ie = 1;
var se = 3;
var oe = 0;
var le = 1;
var ce = 2;
var ue = 4;
var ae = 8;
var fe = 240 | (3 | ue | ae);
var de = 1;
var he = 2;
var ge = 3;
var _e = 4;
var pe = 5;
var ye = 6;
var me = Z || G || re ? " " : "​";
var xe = "\n\n";
var ve = X ? " " : me;
var Te = "֑-߿יִ-﷽ﹰ-ﻼ";
var Se = "A-Za-zÀ-ÖØ-öø-ʸ̀-֐ࠀ-῿‎Ⰰ-﬜︀-﹯﻽-￿";
var ke = new RegExp("^[^" + Se + "]*[" + Te + "]");
var Ce = new RegExp("^[^" + Te + "]*[" + Se + "]");
var be = { bold: 1, code: 16, highlight: 128, italic: 2, strikethrough: ue, subscript: 32, superscript: 64, underline: ae };
var Ne = { directionless: 1, unmergeable: 2 };
var we = { center: he, end: ye, justify: _e, left: de, right: ge, start: pe };
var Ee = { [he]: "center", [ye]: "end", [_e]: "justify", [de]: "left", [ge]: "right", [pe]: "start" };
var Pe = { normal: 0, segmented: 2, token: 1 };
var De = { 0: "normal", 2: "segmented", 1: "token" };
function Ie(...e) {
  const t2 = [];
  for (const n of e)
    if (n && "string" == typeof n)
      for (const [e2] of n.matchAll(/\S+/g))
        t2.push(e2);
  return t2;
}
var Oe = 100;
var Ae = false;
var Le = 0;
function Fe(e) {
  Le = e.timeStamp;
}
function Me(e, t2, n) {
  return t2.__lexicalLineBreak === e || void 0 !== e[`__lexicalKey_${n._key}`];
}
function We(e, t2, n) {
  const r2 = nn(n._window);
  let i2 = null, s2 = null;
  null !== r2 && r2.anchorNode === e && (i2 = r2.anchorOffset, s2 = r2.focusOffset);
  const o2 = e.nodeValue;
  null !== o2 && kt(t2, o2, i2, s2, false);
}
function ze(e, t2, n) {
  if (Xr(e)) {
    const t3 = e.anchor.getNode();
    if (t3.is(n) && e.format !== t3.getFormat())
      return false;
  }
  return t2.nodeType === se && n.isAttached();
}
function Be(e, t2, n) {
  Ae = true;
  const r2 = performance.now() - Le > Oe;
  try {
    Vi(e, () => {
      const i2 = fi() || function(e2) {
        return e2.getEditorState().read(() => {
          const e3 = fi();
          return null !== e3 ? e3.clone() : null;
        });
      }(e), s2 = /* @__PURE__ */ new Map(), o2 = e.getRootElement(), l2 = e._editorState, c2 = e._blockCursorElement;
      let u2 = false, a2 = "";
      for (let n2 = 0; n2 < t2.length; n2++) {
        const f3 = t2[n2], d2 = f3.type, h2 = f3.target;
        let g2 = at(h2, l2);
        if (!(null === g2 && h2 !== o2 || Hi(g2))) {
          if ("characterData" === d2)
            r2 && Br(g2) && ze(i2, h2, g2) && We(h2, g2, e);
          else if ("childList" === d2) {
            u2 = true;
            const t3 = f3.addedNodes;
            for (let n4 = 0; n4 < t3.length; n4++) {
              const r4 = t3[n4], i3 = ut(r4), s3 = r4.parentNode;
              if (null != s3 && r4 !== c2 && null === i3 && ("BR" !== r4.nodeName || !Me(r4, s3, e))) {
                if (X) {
                  const e2 = r4.innerText || r4.nodeValue;
                  e2 && (a2 += e2);
                }
                s3.removeChild(r4);
              }
            }
            const n3 = f3.removedNodes, r3 = n3.length;
            if (r3 > 0) {
              let t4 = 0;
              for (let i3 = 0; i3 < r3; i3++) {
                const r4 = n3[i3];
                ("BR" === r4.nodeName && Me(r4, h2, e) || c2 === r4) && (h2.appendChild(r4), t4++);
              }
              r3 !== t4 && (h2 === o2 && (g2 = gt(l2)), s2.set(h2, g2));
            }
          }
        }
      }
      if (s2.size > 0)
        for (const [t3, n2] of s2)
          if (qi(n2)) {
            const r3 = n2.getChildrenKeys();
            let i3 = t3.firstChild;
            for (let n3 = 0; n3 < r3.length; n3++) {
              const s3 = r3[n3], o3 = e.getElementByKey(s3);
              null !== o3 && (null == i3 ? (t3.appendChild(o3), i3 = o3) : i3 !== o3 && t3.replaceChild(o3, i3), i3 = i3.nextSibling);
            }
          } else
            Br(n2) && n2.markDirty();
      const f2 = n.takeRecords();
      if (f2.length > 0) {
        for (let t3 = 0; t3 < f2.length; t3++) {
          const n2 = f2[t3], r3 = n2.addedNodes, i3 = n2.target;
          for (let t4 = 0; t4 < r3.length; t4++) {
            const n3 = r3[t4], s3 = n3.parentNode;
            null == s3 || "BR" !== n3.nodeName || Me(n3, i3, e) || s3.removeChild(n3);
          }
        }
        n.takeRecords();
      }
      null !== i2 && (u2 && (i2.dirty = true, _t(i2)), X && zt(e) && i2.insertRawText(a2));
    });
  } finally {
    Ae = false;
  }
}
function Re(e) {
  const t2 = e._observer;
  if (null !== t2) {
    Be(e, t2.takeRecords(), t2);
  }
}
function Ke(e) {
  !function(e2) {
    0 === Le && Ht(e2).addEventListener("textInput", Fe, true);
  }(e), e._observer = new MutationObserver((t2, n) => {
    Be(e, t2, n);
  });
}
function Je(e, t2) {
  const n = e.__mode, r2 = e.__format, i2 = e.__style, s2 = t2.__mode, o2 = t2.__format, l2 = t2.__style;
  return !(null !== n && n !== s2 || null !== r2 && r2 !== o2 || null !== i2 && i2 !== l2);
}
function Ue(e, t2) {
  const n = e.mergeWithSibling(t2), r2 = Oi()._normalizedNodes;
  return r2.add(e.__key), r2.add(t2.__key), n;
}
function Ve(e) {
  let t2, n, r2 = e;
  if ("" !== r2.__text || !r2.isSimpleText() || r2.isUnmergeable()) {
    for (; null !== (t2 = r2.getPreviousSibling()) && Br(t2) && t2.isSimpleText() && !t2.isUnmergeable(); ) {
      if ("" !== t2.__text) {
        if (Je(t2, r2)) {
          r2 = Ue(t2, r2);
          break;
        }
        break;
      }
      t2.remove();
    }
    for (; null !== (n = r2.getNextSibling()) && Br(n) && n.isSimpleText() && !n.isUnmergeable(); ) {
      if ("" !== n.__text) {
        if (Je(r2, n)) {
          r2 = Ue(r2, n);
          break;
        }
        break;
      }
      n.remove();
    }
  } else
    r2.remove();
}
var je = 1;
var qe = "function" == typeof queueMicrotask ? queueMicrotask : (e) => {
  Promise.resolve().then(e);
};
function Qe(e) {
  const t2 = document.activeElement;
  if (null === t2)
    return false;
  const n = t2.nodeName;
  return Hi(at(e)) && ("INPUT" === n || "TEXTAREA" === n || "true" === t2.contentEditable && null == t2.__lexicalEditor);
}
function Xe(e, t2, n) {
  const r2 = e.getRootElement();
  try {
    return null !== r2 && r2.contains(t2) && r2.contains(n) && null !== t2 && !Qe(t2) && Ye(t2) === e;
  } catch (e2) {
    return false;
  }
}
function Ye(e) {
  let t2 = e;
  for (; null != t2; ) {
    const e2 = t2.__lexicalEditor;
    if (null != e2)
      return e2;
    t2 = Jt(t2);
  }
  return null;
}
function Ze(e) {
  return e.isToken() || e.isSegmented();
}
function Ge(e) {
  return e.nodeType === se;
}
function et(e) {
  let t2 = e;
  for (; null != t2; ) {
    if (Ge(t2))
      return t2;
    t2 = t2.firstChild;
  }
  return null;
}
function tt(e, t2, n) {
  const r2 = be[t2];
  if (null !== n && (e & r2) == (n & r2))
    return e;
  let i2 = e ^ r2;
  return "subscript" === t2 ? i2 &= ~be.superscript : "superscript" === t2 && (i2 &= ~be.subscript), i2;
}
function rt(e, t2) {
  if (null != t2)
    return void (e.__key = t2);
  Pi(), Di();
  const n = Oi(), r2 = Ii(), i2 = "" + je++;
  r2._nodeMap.set(i2, e), qi(e) ? n._dirtyElements.set(i2, true) : n._dirtyLeaves.add(i2), n._cloneNotNeeded.add(i2), n._dirtyType = le, e.__key = i2;
}
function it(e) {
  const t2 = e.getParent();
  if (null !== t2) {
    const n = e.getWritable(), r2 = t2.getWritable(), i2 = e.getPreviousSibling(), s2 = e.getNextSibling();
    if (null === i2)
      if (null !== s2) {
        const e2 = s2.getWritable();
        r2.__first = s2.__key, e2.__prev = null;
      } else
        r2.__first = null;
    else {
      const e2 = i2.getWritable();
      if (null !== s2) {
        const t3 = s2.getWritable();
        t3.__prev = e2.__key, e2.__next = t3.__key;
      } else
        e2.__next = null;
      n.__prev = null;
    }
    if (null === s2)
      if (null !== i2) {
        const e2 = i2.getWritable();
        r2.__last = i2.__key, e2.__next = null;
      } else
        r2.__last = null;
    else {
      const e2 = s2.getWritable();
      if (null !== i2) {
        const t3 = i2.getWritable();
        t3.__next = e2.__key, e2.__prev = t3.__key;
      } else
        e2.__prev = null;
      n.__next = null;
    }
    r2.__size--, n.__parent = null;
  }
}
function st(e) {
  Di();
  const t2 = e.getLatest(), n = t2.__parent, r2 = Ii(), i2 = Oi(), s2 = r2._nodeMap, o2 = i2._dirtyElements;
  null !== n && function(e2, t3, n2) {
    let r3 = e2;
    for (; null !== r3; ) {
      if (n2.has(r3))
        return;
      const e3 = t3.get(r3);
      if (void 0 === e3)
        break;
      n2.set(r3, false), r3 = e3.__parent;
    }
  }(n, s2, o2);
  const l2 = t2.__key;
  i2._dirtyType = le, qi(e) ? o2.set(l2, true) : i2._dirtyLeaves.add(l2);
}
function ot(e) {
  Pi();
  const t2 = Oi(), n = t2._compositionKey;
  if (e !== n) {
    if (t2._compositionKey = e, null !== n) {
      const e2 = ct(n);
      null !== e2 && e2.getWritable();
    }
    if (null !== e) {
      const t3 = ct(e);
      null !== t3 && t3.getWritable();
    }
  }
}
function lt() {
  if (Ei())
    return null;
  return Oi()._compositionKey;
}
function ct(e, t2) {
  const n = (t2 || Ii())._nodeMap.get(e);
  return void 0 === n ? null : n;
}
function ut(e, t2) {
  const n = e[`__lexicalKey_${Oi()._key}`];
  return void 0 !== n ? ct(n, t2) : null;
}
function at(e, t2) {
  let n = e;
  for (; null != n; ) {
    const e2 = ut(n, t2);
    if (null !== e2)
      return e2;
    n = Jt(n);
  }
  return null;
}
function ft(e) {
  const t2 = e._decorators, n = Object.assign({}, t2);
  return e._pendingDecorators = n, n;
}
function dt(e) {
  return e.read(() => ht().getTextContent());
}
function ht() {
  return gt(Ii());
}
function gt(e) {
  return e._nodeMap.get("root");
}
function _t(e) {
  Pi();
  const t2 = Ii();
  null !== e && (e.dirty = true, e.setCachedNodes(null)), t2._selection = e;
}
function pt(e) {
  const t2 = Oi(), n = function(e2, t3) {
    let n2 = e2;
    for (; null != n2; ) {
      const e3 = n2[`__lexicalKey_${t3._key}`];
      if (void 0 !== e3)
        return e3;
      n2 = Jt(n2);
    }
    return null;
  }(e, t2);
  if (null === n) {
    return e === t2.getRootElement() ? ct("root") : null;
  }
  return ct(n);
}
function yt(e, t2) {
  return t2 ? e.getTextContentSize() : 0;
}
function mt(e) {
  return /[\uD800-\uDBFF][\uDC00-\uDFFF]/g.test(e);
}
function xt(e) {
  const t2 = [];
  let n = e;
  for (; null !== n; )
    t2.push(n), n = n._parentEditor;
  return t2;
}
function Tt(e) {
  return e.nodeType === se ? e.nodeValue : null;
}
function St(e, t2, n) {
  const r2 = nn(t2._window);
  if (null === r2)
    return;
  const i2 = r2.anchorNode;
  let { anchorOffset: s2, focusOffset: o2 } = r2;
  if (null !== i2) {
    let t3 = Tt(i2);
    const r3 = at(i2);
    if (null !== t3 && Br(r3)) {
      if (t3 === me && n) {
        const e2 = n.length;
        t3 = n, s2 = e2, o2 = e2;
      }
      null !== t3 && kt(r3, t3, s2, o2, e);
    }
  }
}
function kt(e, t2, n, r2, i2) {
  let s2 = e;
  if (s2.isAttached() && (i2 || !s2.isDirty())) {
    const o2 = s2.isComposing();
    let l2 = t2;
    (o2 || i2) && t2[t2.length - 1] === me && (l2 = t2.slice(0, -1));
    const c2 = s2.getTextContent();
    if (i2 || l2 !== c2) {
      if ("" === l2) {
        if (ot(null), Z || G || re)
          s2.remove();
        else {
          const e2 = Oi();
          setTimeout(() => {
            e2.update(() => {
              s2.isAttached() && s2.remove();
            });
          }, 20);
        }
        return;
      }
      const t3 = s2.getParent(), i3 = di(), c3 = s2.getTextContentSize(), u2 = lt(), a2 = s2.getKey();
      if (s2.isToken() || null !== u2 && a2 === u2 && !o2 || Xr(i3) && (null !== t3 && !t3.canInsertTextBefore() && 0 === i3.anchor.offset || i3.anchor.key === e.__key && 0 === i3.anchor.offset && !s2.canInsertTextBefore() && !o2 || i3.focus.key === e.__key && i3.focus.offset === c3 && !s2.canInsertTextAfter() && !o2))
        return void s2.markDirty();
      const f2 = fi();
      if (!Xr(f2) || null === n || null === r2)
        return void s2.setTextContent(l2);
      if (f2.setTextNodeRange(s2, n, s2, r2), s2.isSegmented()) {
        const e2 = zr(s2.getTextContent());
        s2.replace(e2), s2 = e2;
      }
      s2.setTextContent(l2);
    }
  }
}
function Ct(e, t2) {
  if (t2.isSegmented())
    return true;
  if (!e.isCollapsed())
    return false;
  const n = e.anchor.offset, r2 = t2.getParentOrThrow(), i2 = t2.isToken();
  return 0 === n ? !t2.canInsertTextBefore() || !r2.canInsertTextBefore() || i2 || function(e2) {
    const t3 = e2.getPreviousSibling();
    return (Br(t3) || qi(t3) && t3.isInline()) && !t3.canInsertTextAfter();
  }(t2) : n === t2.getTextContentSize() && (!t2.canInsertTextAfter() || !r2.canInsertTextAfter() || i2);
}
function bt(e) {
  return 37 === e;
}
function Nt(e) {
  return 39 === e;
}
function wt(e, t2) {
  return Q ? e : t2;
}
function Et(e) {
  return 13 === e;
}
function Pt(e) {
  return 8 === e;
}
function Dt(e) {
  return 46 === e;
}
function It(e, t2, n) {
  return 65 === e && wt(t2, n);
}
function At(e, t2) {
  void 0 === e.__lexicalClassNameCache && (e.__lexicalClassNameCache = {});
  const n = e.__lexicalClassNameCache, r2 = n[t2];
  if (void 0 !== r2)
    return r2;
  const i2 = e[t2];
  if ("string" == typeof i2) {
    const e2 = Ie(i2);
    return n[t2] = e2, e2;
  }
  return i2;
}
function Lt(e, t2, n, r2, i2) {
  if (0 === n.size)
    return;
  const s2 = r2.__type, o2 = r2.__key, l2 = t2.get(s2);
  void 0 === l2 && H(33, s2);
  const c2 = l2.klass;
  let u2 = e.get(c2);
  void 0 === u2 && (u2 = /* @__PURE__ */ new Map(), e.set(c2, u2));
  const a2 = u2.get(o2), f2 = "destroyed" === a2 && "created" === i2;
  (void 0 === a2 || f2) && u2.set(o2, f2 ? "updated" : i2);
}
function Mt(e, t2, n) {
  const r2 = e.getParent();
  let i2 = n, s2 = e;
  return null !== r2 && (t2 && 0 === n ? (i2 = s2.getIndexWithinParent(), s2 = r2) : t2 || n !== s2.getChildrenSize() || (i2 = s2.getIndexWithinParent() + 1, s2 = r2)), s2.getChildAtIndex(t2 ? i2 - 1 : i2);
}
function Wt(e, t2) {
  const n = e.offset;
  if ("element" === e.type) {
    return Mt(e.getNode(), t2, n);
  }
  {
    const r2 = e.getNode();
    if (t2 && 0 === n || !t2 && n === r2.getTextContentSize()) {
      const e2 = t2 ? r2.getPreviousSibling() : r2.getNextSibling();
      return null === e2 ? Mt(r2.getParentOrThrow(), t2, r2.getIndexWithinParent() + (t2 ? 0 : 1)) : e2;
    }
  }
  return null;
}
function zt(e) {
  const t2 = Ht(e).event, n = t2 && t2.inputType;
  return "insertFromPaste" === n || "insertFromPasteAsQuotation" === n;
}
function Bt(e, t2, n) {
  return Ki(e, t2, n);
}
function Rt(e) {
  return !Yi(e) && !e.isLastChild() && !e.isInline();
}
function Kt(e, t2) {
  const n = e._keyToDOMMap.get(t2);
  return void 0 === n && H(75, t2), n;
}
function Jt(e) {
  const t2 = e.assignedSlot || e.parentElement;
  return null !== t2 && 11 === t2.nodeType ? t2.host : t2;
}
function $t(e, t2) {
  let n = e.getParent();
  for (; null !== n; ) {
    if (n.is(t2))
      return true;
    n = n.getParent();
  }
  return false;
}
function Ht(e) {
  const t2 = e._window;
  return null === t2 && H(78), t2;
}
function qt(e) {
  let t2 = e.getParentOrThrow();
  for (; null !== t2; ) {
    if (Qt(t2))
      return t2;
    t2 = t2.getParentOrThrow();
  }
  return t2;
}
function Qt(e) {
  return Yi(e) || qi(e) && e.isShadowRoot();
}
function Yt(e) {
  const t2 = Oi(), n = e.constructor.getType(), r2 = t2._nodes.get(n);
  void 0 === r2 && H(97);
  const i2 = r2.replace;
  if (null !== i2) {
    const t3 = i2(e);
    return t3 instanceof e.constructor || H(98), t3;
  }
  return e;
}
function Zt(e, t2) {
  !Yi(e.getParent()) || qi(t2) || Hi(t2) || H(99);
}
function Gt(e) {
  return (Hi(e) || qi(e) && !e.canBeEmpty()) && !e.isInline();
}
function en(e, t2, n) {
  n.style.removeProperty("caret-color"), t2._blockCursorElement = null;
  const r2 = e.parentElement;
  null !== r2 && r2.removeChild(e);
}
function tn(e, t2, n) {
  let r2 = e._blockCursorElement;
  if (Xr(n) && n.isCollapsed() && "element" === n.anchor.type && t2.contains(document.activeElement)) {
    const i2 = n.anchor, s2 = i2.getNode(), o2 = i2.offset;
    let l2 = false, c2 = null;
    if (o2 === s2.getChildrenSize()) {
      Gt(s2.getChildAtIndex(o2 - 1)) && (l2 = true);
    } else {
      const t3 = s2.getChildAtIndex(o2);
      if (Gt(t3)) {
        const n2 = t3.getPreviousSibling();
        (null === n2 || Gt(n2)) && (l2 = true, c2 = e.getElementByKey(t3.__key));
      }
    }
    if (l2) {
      const n2 = e.getElementByKey(s2.__key);
      return null === r2 && (e._blockCursorElement = r2 = function(e2) {
        const t3 = e2.theme, n3 = document.createElement("div");
        n3.contentEditable = "false", n3.setAttribute("data-lexical-cursor", "true");
        let r3 = t3.blockCursor;
        if (void 0 !== r3) {
          if ("string" == typeof r3) {
            const e3 = Ie(r3);
            r3 = t3.blockCursor = e3;
          }
          void 0 !== r3 && n3.classList.add(...r3);
        }
        return n3;
      }(e._config)), t2.style.caretColor = "transparent", void (null === c2 ? n2.appendChild(r2) : n2.insertBefore(r2, c2));
    }
  }
  null !== r2 && en(r2, e, t2);
}
function nn(e) {
  return j ? (e || window).getSelection() : null;
}
function on(e) {
  return 1 === e.nodeType;
}
function ln(e) {
  if (Hi(e) && !e.isInline())
    return true;
  if (!qi(e) || Qt(e))
    return false;
  const t2 = e.getFirstChild(), n = null === t2 || vr(t2) || Br(t2) || t2.isInline();
  return !e.isInline() && false !== e.canBeEmpty() && n;
}
function cn(e, t2) {
  let n = e;
  for (; null !== n && null !== n.getParent() && !t2(n); )
    n = n.getParentOrThrow();
  return t2(n) ? n : null;
}
function an(e, t2, n, r2, i2, s2) {
  let o2 = e.getFirstChild();
  for (; null !== o2; ) {
    const e2 = o2.__key;
    o2.__parent === t2 && (qi(o2) && an(o2, e2, n, r2, i2, s2), n.has(e2) || s2.delete(e2), i2.push(e2)), o2 = o2.getNextSibling();
  }
}
var fn;
var dn;
var hn;
var gn;
var _n;
var pn;
var yn;
var mn;
var xn;
var vn;
var Tn = "";
var Sn = "";
var kn = "";
var Cn = false;
var bn = false;
var Nn = null;
function wn(e, t2) {
  const n = yn.get(e);
  if (null !== t2) {
    const n2 = Vn(e);
    n2.parentNode === t2 && t2.removeChild(n2);
  }
  if (mn.has(e) || dn._keyToDOMMap.delete(e), qi(n)) {
    const e2 = Bn(n, yn);
    En(e2, 0, e2.length - 1, null);
  }
  void 0 !== n && Lt(vn, hn, gn, n, "destroyed");
}
function En(e, t2, n, r2) {
  let i2 = t2;
  for (; i2 <= n; ++i2) {
    const t3 = e[i2];
    void 0 !== t3 && wn(t3, r2);
  }
}
function Pn(e, t2) {
  e.setProperty("text-align", t2);
}
var Dn = "40px";
function In(e, t2) {
  const n = fn.theme.indent;
  if ("string" == typeof n) {
    const r3 = e.classList.contains(n);
    t2 > 0 && !r3 ? e.classList.add(n) : t2 < 1 && r3 && e.classList.remove(n);
  }
  const r2 = getComputedStyle(e).getPropertyValue("--lexical-indent-base-value") || Dn;
  e.style.setProperty("padding-inline-start", 0 === t2 ? "" : `calc(${t2} * ${r2})`);
}
function On(e, t2) {
  const n = e.style;
  0 === t2 ? Pn(n, "") : t2 === de ? Pn(n, "left") : t2 === he ? Pn(n, "center") : t2 === ge ? Pn(n, "right") : t2 === _e ? Pn(n, "justify") : t2 === pe ? Pn(n, "start") : t2 === ye && Pn(n, "end");
}
function An(e, t2, n) {
  const r2 = mn.get(e);
  void 0 === r2 && H(60);
  const i2 = r2.createDOM(fn, dn);
  if (function(e2, t3, n2) {
    const r3 = n2._keyToDOMMap;
    t3["__lexicalKey_" + n2._key] = e2, r3.set(e2, t3);
  }(e, i2, dn), Br(r2) ? i2.setAttribute("data-lexical-text", "true") : Hi(r2) && i2.setAttribute("data-lexical-decorator", "true"), qi(r2)) {
    const e2 = r2.__indent, t3 = r2.__size;
    if (0 !== e2 && In(i2, e2), 0 !== t3) {
      const e3 = t3 - 1;
      !function(e4, t4, n3, r3) {
        const i3 = Sn;
        Sn = "", Ln(e4, n3, 0, t4, r3, null), Wn(n3, r3), Sn = i3;
      }(Bn(r2, mn), e3, r2, i2);
    }
    const n2 = r2.__format;
    0 !== n2 && On(i2, n2), r2.isInline() || Mn(null, r2, i2), Rt(r2) && (Tn += xe, kn += xe);
  } else {
    const t3 = r2.getTextContent();
    if (Hi(r2)) {
      const t4 = r2.decorate(dn, fn);
      null !== t4 && Kn(e, t4), i2.contentEditable = "false";
    } else
      Br(r2) && (r2.isDirectionless() || (Sn += t3));
    Tn += t3, kn += t3;
  }
  if (null !== t2)
    if (null != n)
      t2.insertBefore(i2, n);
    else {
      const e2 = t2.__lexicalLineBreak;
      null != e2 ? t2.insertBefore(i2, e2) : t2.appendChild(i2);
    }
  return Lt(vn, hn, gn, r2, "created"), i2;
}
function Ln(e, t2, n, r2, i2, s2) {
  const o2 = Tn;
  Tn = "";
  let l2 = n;
  for (; l2 <= r2; ++l2)
    An(e[l2], i2, s2);
  Rt(t2) && (Tn += xe), i2.__lexicalTextContent = Tn, Tn = o2 + Tn;
}
function Fn(e, t2) {
  const n = t2.get(e);
  return vr(n) || Hi(n) && n.isInline();
}
function Mn(e, t2, n) {
  const r2 = null !== e && (0 === e.__size || Fn(e.__last, yn)), i2 = 0 === t2.__size || Fn(t2.__last, mn);
  if (r2) {
    if (!i2) {
      const e2 = n.__lexicalLineBreak;
      null != e2 && n.removeChild(e2), n.__lexicalLineBreak = null;
    }
  } else if (i2) {
    const e2 = document.createElement("br");
    n.__lexicalLineBreak = e2, n.appendChild(e2);
  }
}
function Wn(e, t2) {
  const n = t2.__lexicalDirTextContent, r2 = t2.__lexicalDir;
  if (n !== Sn || r2 !== Nn) {
    const n2 = "" === Sn, s2 = n2 ? Nn : (i2 = Sn, ke.test(i2) ? "rtl" : Ce.test(i2) ? "ltr" : null);
    if (s2 !== r2) {
      const i3 = t2.classList, o2 = fn.theme;
      let l2 = null !== r2 ? o2[r2] : void 0, c2 = null !== s2 ? o2[s2] : void 0;
      if (void 0 !== l2) {
        if ("string" == typeof l2) {
          const e2 = Ie(l2);
          l2 = o2[r2] = e2;
        }
        i3.remove(...l2);
      }
      if (null === s2 || n2 && "ltr" === s2)
        t2.removeAttribute("dir");
      else {
        if (void 0 !== c2) {
          if ("string" == typeof c2) {
            const e2 = Ie(c2);
            c2 = o2[s2] = e2;
          }
          void 0 !== c2 && i3.add(...c2);
        }
        t2.dir = s2;
      }
      if (!bn) {
        e.getWritable().__dir = s2;
      }
    }
    Nn = s2, t2.__lexicalDirTextContent = Sn, t2.__lexicalDir = s2;
  }
  var i2;
}
function zn(e, t2, n) {
  const r2 = Sn;
  Sn = "", function(e2, t3, n2) {
    const r3 = Tn, i2 = e2.__size, s2 = t3.__size;
    if (Tn = "", 1 === i2 && 1 === s2) {
      const r4 = e2.__first, i3 = t3.__first;
      if (r4 === i3)
        Rn(r4, n2);
      else {
        const e3 = Vn(r4), t4 = An(i3, null, null);
        n2.replaceChild(t4, e3), wn(r4, null);
      }
    } else {
      const r4 = Bn(e2, yn), o2 = Bn(t3, mn);
      if (0 === i2)
        0 !== s2 && Ln(o2, t3, 0, s2 - 1, n2, null);
      else if (0 === s2) {
        if (0 !== i2) {
          const e3 = null == n2.__lexicalLineBreak;
          En(r4, 0, i2 - 1, e3 ? null : n2), e3 && (n2.textContent = "");
        }
      } else
        !function(e3, t4, n3, r5, i3, s3) {
          const o3 = r5 - 1, l2 = i3 - 1;
          let c2, u2, a2 = (h2 = s3, h2.firstChild), f2 = 0, d2 = 0;
          var h2;
          for (; f2 <= o3 && d2 <= l2; ) {
            const e4 = t4[f2], r6 = n3[d2];
            if (e4 === r6)
              a2 = Jn(Rn(r6, s3)), f2++, d2++;
            else {
              void 0 === c2 && (c2 = new Set(t4)), void 0 === u2 && (u2 = new Set(n3));
              const i4 = u2.has(e4), o4 = c2.has(r6);
              if (i4)
                if (o4) {
                  const e5 = Kt(dn, r6);
                  e5 === a2 ? a2 = Jn(Rn(r6, s3)) : (null != a2 ? s3.insertBefore(e5, a2) : s3.appendChild(e5), Rn(r6, s3)), f2++, d2++;
                } else
                  An(r6, s3, a2), d2++;
              else
                a2 = Jn(Vn(e4)), wn(e4, s3), f2++;
            }
          }
          const g2 = f2 > o3, _2 = d2 > l2;
          if (g2 && !_2) {
            const t5 = n3[l2 + 1];
            Ln(n3, e3, d2, l2, s3, void 0 === t5 ? null : dn.getElementByKey(t5));
          } else
            _2 && !g2 && En(t4, f2, o3, s3);
        }(t3, r4, o2, i2, s2, n2);
    }
    Rt(t3) && (Tn += xe);
    n2.__lexicalTextContent = Tn, Tn = r3 + Tn;
  }(e, t2, n), Wn(t2, n), Sn = r2;
}
function Bn(e, t2) {
  const n = [];
  let r2 = e.__first;
  for (; null !== r2; ) {
    const e2 = t2.get(r2);
    void 0 === e2 && H(101), n.push(r2), r2 = e2.__next;
  }
  return n;
}
function Rn(e, t2) {
  const n = yn.get(e);
  let r2 = mn.get(e);
  void 0 !== n && void 0 !== r2 || H(61);
  const i2 = Cn || pn.has(e) || _n.has(e), s2 = Kt(dn, e);
  if (n === r2 && !i2) {
    if (qi(n)) {
      const e2 = s2.__lexicalTextContent;
      void 0 !== e2 && (Tn += e2, kn += e2);
      const t3 = s2.__lexicalDirTextContent;
      void 0 !== t3 && (Sn += t3);
    } else {
      const e2 = n.getTextContent();
      Br(n) && !n.isDirectionless() && (Sn += e2), kn += e2, Tn += e2;
    }
    return s2;
  }
  if (n !== r2 && i2 && Lt(vn, hn, gn, r2, "updated"), r2.updateDOM(n, s2, fn)) {
    const n2 = An(e, null, null);
    return null === t2 && H(62), t2.replaceChild(n2, s2), wn(e, null), n2;
  }
  if (qi(n) && qi(r2)) {
    const e2 = r2.__indent;
    e2 !== n.__indent && In(s2, e2);
    const t3 = r2.__format;
    t3 !== n.__format && On(s2, t3), i2 && (zn(n, r2, s2), Yi(r2) || r2.isInline() || Mn(n, r2, s2)), Rt(r2) && (Tn += xe, kn += xe);
  } else {
    const t3 = r2.getTextContent();
    if (Hi(r2)) {
      const t4 = r2.decorate(dn, fn);
      null !== t4 && Kn(e, t4);
    } else
      Br(r2) && !r2.isDirectionless() && (Sn += t3);
    Tn += t3, kn += t3;
  }
  if (!bn && Yi(r2) && r2.__cachedText !== kn) {
    const e2 = r2.getWritable();
    e2.__cachedText = kn, r2 = e2;
  }
  return s2;
}
function Kn(e, t2) {
  let n = dn._pendingDecorators;
  const r2 = dn._decorators;
  if (null === n) {
    if (r2[e] === t2)
      return;
    n = ft(dn);
  }
  n[e] = t2;
}
function Jn(e) {
  let t2 = e.nextSibling;
  return null !== t2 && t2 === dn._blockCursorElement && (t2 = t2.nextSibling), t2;
}
function Un(e, t2, n, r2, i2, s2) {
  Tn = "", kn = "", Sn = "", Cn = r2 === ce, Nn = null, dn = n, fn = n._config, hn = n._nodes, gn = dn._listeners.mutation, _n = i2, pn = s2, yn = e._nodeMap, mn = t2._nodeMap, bn = t2._readOnly, xn = new Map(n._keyToDOMMap);
  const o2 = /* @__PURE__ */ new Map();
  return vn = o2, Rn("root", null), dn = void 0, hn = void 0, _n = void 0, pn = void 0, yn = void 0, mn = void 0, fn = void 0, xn = void 0, vn = void 0, o2;
}
function Vn(e) {
  const t2 = xn.get(e);
  return void 0 === t2 && H(75, e), t2;
}
var $n = Object.freeze({});
var Hn = 30;
var jn = [["keydown", function(e, t2) {
  if (qn = e.timeStamp, Qn = e.keyCode, t2.isComposing())
    return;
  const { keyCode: n, shiftKey: r2, ctrlKey: o2, metaKey: l2, altKey: c2 } = e;
  if (Bt(t2, _, e))
    return;
  if (function(e2, t3, n2, r3) {
    return Nt(e2) && !t3 && !r3 && !n2;
  }(n, o2, c2, l2))
    Bt(t2, p, e);
  else if (function(e2, t3, n2, r3, i2) {
    return Nt(e2) && !r3 && !n2 && (t3 || i2);
  }(n, o2, r2, c2, l2))
    Bt(t2, y, e);
  else if (function(e2, t3, n2, r3) {
    return bt(e2) && !t3 && !r3 && !n2;
  }(n, o2, c2, l2))
    Bt(t2, m, e);
  else if (function(e2, t3, n2, r3, i2) {
    return bt(e2) && !r3 && !n2 && (t3 || i2);
  }(n, o2, r2, c2, l2))
    Bt(t2, x, e);
  else if (/* @__PURE__ */ function(e2, t3, n2) {
    return /* @__PURE__ */ function(e3) {
      return 38 === e3;
    }(e2) && !t3 && !n2;
  }(n, o2, l2))
    Bt(t2, v, e);
  else if (/* @__PURE__ */ function(e2, t3, n2) {
    return /* @__PURE__ */ function(e3) {
      return 40 === e3;
    }(e2) && !t3 && !n2;
  }(n, o2, l2))
    Bt(t2, T, e);
  else if (function(e2, t3) {
    return Et(e2) && t3;
  }(n, r2))
    tr = true, Bt(t2, S, e);
  else if (/* @__PURE__ */ function(e2) {
    return 32 === e2;
  }(n))
    Bt(t2, k, e);
  else if (/* @__PURE__ */ function(e2, t3) {
    return Q && t3 && 79 === e2;
  }(n, o2))
    e.preventDefault(), tr = true, Bt(t2, s, true);
  else if (function(e2, t3) {
    return Et(e2) && !t3;
  }(n, r2))
    tr = false, Bt(t2, S, e);
  else if (function(e2, t3, n2, r3) {
    return Q ? !t3 && !n2 && (Pt(e2) || 72 === e2 && r3) : !(r3 || t3 || n2) && Pt(e2);
  }(n, c2, l2, o2))
    Pt(n) ? Bt(t2, C, e) : (e.preventDefault(), Bt(t2, i, true));
  else if (/* @__PURE__ */ function(e2) {
    return 27 === e2;
  }(n))
    Bt(t2, b, e);
  else if (function(e2, t3, n2, r3, i2) {
    return Q ? !(n2 || r3 || i2) && (Dt(e2) || 68 === e2 && t3) : !(t3 || r3 || i2) && Dt(e2);
  }(n, o2, r2, c2, l2))
    Dt(n) ? Bt(t2, N, e) : (e.preventDefault(), Bt(t2, i, false));
  else if (function(e2, t3, n2) {
    return Pt(e2) && (Q ? t3 : n2);
  }(n, c2, o2))
    e.preventDefault(), Bt(t2, a, true);
  else if (function(e2, t3, n2) {
    return Dt(e2) && (Q ? t3 : n2);
  }(n, c2, o2))
    e.preventDefault(), Bt(t2, a, false);
  else if (function(e2, t3) {
    return Q && t3 && Pt(e2);
  }(n, l2))
    e.preventDefault(), Bt(t2, f, true);
  else if (function(e2, t3) {
    return Q && t3 && Dt(e2);
  }(n, l2))
    e.preventDefault(), Bt(t2, f, false);
  else if (function(e2, t3, n2, r3) {
    return 66 === e2 && !t3 && wt(n2, r3);
  }(n, c2, l2, o2))
    e.preventDefault(), Bt(t2, d, "bold");
  else if (function(e2, t3, n2, r3) {
    return 85 === e2 && !t3 && wt(n2, r3);
  }(n, c2, l2, o2))
    e.preventDefault(), Bt(t2, d, "underline");
  else if (function(e2, t3, n2, r3) {
    return 73 === e2 && !t3 && wt(n2, r3);
  }(n, c2, l2, o2))
    e.preventDefault(), Bt(t2, d, "italic");
  else if (/* @__PURE__ */ function(e2, t3, n2, r3) {
    return 9 === e2 && !t3 && !n2 && !r3;
  }(n, c2, o2, l2))
    Bt(t2, w, e);
  else if (function(e2, t3, n2, r3) {
    return 90 === e2 && !t3 && wt(n2, r3);
  }(n, r2, l2, o2))
    e.preventDefault(), Bt(t2, h, void 0);
  else if (/* @__PURE__ */ function(e2, t3, n2, r3) {
    return Q ? 90 === e2 && n2 && t3 : 89 === e2 && r3 || 90 === e2 && r3 && t3;
  }(n, r2, l2, o2))
    e.preventDefault(), Bt(t2, g, void 0);
  else {
    Zr(t2._editorState._selection) ? !/* @__PURE__ */ function(e2, t3, n2, r3) {
      return !t3 && 67 === e2 && (Q ? n2 : r3);
    }(n, r2, l2, o2) ? !/* @__PURE__ */ function(e2, t3, n2, r3) {
      return !t3 && 88 === e2 && (Q ? n2 : r3);
    }(n, r2, l2, o2) ? It(n, l2, o2) && (e.preventDefault(), Bt(t2, z, e)) : (e.preventDefault(), Bt(t2, W, e)) : (e.preventDefault(), Bt(t2, M, e)) : !X && It(n, l2, o2) && (e.preventDefault(), Bt(t2, z, e));
  }
  /* @__PURE__ */ (function(e2, t3, n2, r3) {
    return e2 || t3 || n2 || r3;
  })(o2, r2, c2, l2) && Bt(t2, $, e);
}], ["pointerdown", function(e, t2) {
  const n = e.target, r2 = e.pointerType;
  n instanceof Node && "touch" !== r2 && Vi(t2, () => {
    Hi(at(n)) || (er = true);
  });
}], ["compositionstart", function(e, t2) {
  Vi(t2, () => {
    const n = fi();
    if (Xr(n) && !t2.isComposing()) {
      const r2 = n.anchor, i2 = n.anchor.getNode();
      ot(r2.key), (e.timeStamp < qn + Hn || "element" === r2.type || !n.isCollapsed() || i2.getFormat() !== n.format || Br(i2) && i2.getStyle() !== n.style) && Bt(t2, l, ve);
    }
  });
}], ["compositionend", function(e, t2) {
  X ? nr = true : Vi(t2, () => {
    cr(t2, e.data);
  });
}], ["input", function(e, t2) {
  e.stopPropagation(), Vi(t2, () => {
    const n = fi(), r2 = e.data, i2 = lr(e);
    if (null != r2 && Xr(n) && ir(n, i2, r2, e.timeStamp, false)) {
      nr && (cr(t2, r2), nr = false);
      const i3 = n.anchor, s2 = i3.getNode(), o2 = nn(t2._window);
      if (null === o2)
        return;
      const c2 = i3.offset;
      Y && !n.isCollapsed() && Br(s2) && null !== o2.anchorNode && s2.getTextContent().slice(0, c2) + r2 + s2.getTextContent().slice(c2 + n.focus.offset) === Tt(o2.anchorNode) || Bt(t2, l, r2);
      const u2 = r2.length;
      X && u2 > 1 && "insertCompositionText" === e.inputType && !t2.isComposing() && (n.anchor.offset -= u2), Z || G || re || !t2.isComposing() || (qn = 0, ot(null));
    } else {
      St(false, t2, null !== r2 ? r2 : void 0), nr && (cr(t2, r2 || void 0), nr = false);
    }
    Pi(), Re(Oi());
  }), Yn = null;
}], ["click", function(e, t2) {
  Vi(t2, () => {
    const n = fi(), i2 = nn(t2._window), s2 = di();
    if (i2) {
      if (Xr(n)) {
        const t3 = n.anchor, r2 = t3.getNode();
        if ("element" === t3.type && 0 === t3.offset && n.isCollapsed() && !Yi(r2) && 1 === ht().getChildrenSize() && r2.getTopLevelElementOrThrow().isEmpty() && null !== s2 && n.is(s2))
          i2.removeAllRanges(), n.dirty = true;
        else if (3 === e.detail && !n.isCollapsed()) {
          r2 !== n.focus.getNode() && (qi(r2) ? r2.select(0) : r2.getParentOrThrow().select(0));
        }
      } else if ("touch" === e.pointerType) {
        const n2 = i2.anchorNode;
        if (null !== n2) {
          const r2 = n2.nodeType;
          if (r2 === ie || r2 === se) {
            _t(ai(s2, i2, t2, e));
          }
        }
      }
    }
    Bt(t2, r, e);
  });
}], ["cut", $n], ["copy", $n], ["dragstart", $n], ["dragover", $n], ["dragend", $n], ["paste", $n], ["focus", $n], ["blur", $n], ["drop", $n]];
Y && jn.push(["beforeinput", (e, t2) => function(e2, t3) {
  const n = e2.inputType, r2 = lr(e2);
  if ("deleteCompositionText" === n || X && zt(t3))
    return;
  if ("insertCompositionText" === n)
    return;
  Vi(t3, () => {
    const _2 = fi();
    if ("deleteContentBackward" === n) {
      if (null === _2) {
        const e3 = di();
        if (!Xr(e3))
          return;
        _t(e3.clone());
      }
      if (Xr(_2)) {
        const n2 = _2.anchor.key === _2.focus.key;
        if (p2 = e2.timeStamp, 229 === Qn && p2 < qn + Hn && t3.isComposing() && n2) {
          if (ot(null), qn = 0, setTimeout(() => {
            Vi(t3, () => {
              ot(null);
            });
          }, Hn), Xr(_2)) {
            const e3 = _2.anchor.getNode();
            e3.markDirty(), _2.format = e3.getFormat(), Br(e3) || H(142), _2.style = e3.getStyle();
          }
        } else {
          ot(null), e2.preventDefault();
          const r3 = _2.anchor.getNode().getTextContent(), s2 = 0 === _2.anchor.offset && _2.focus.offset === r3.length;
          ne && n2 && !s2 || Bt(t3, i, true);
        }
        return;
      }
    }
    var p2;
    if (!Xr(_2))
      return;
    const y2 = e2.data;
    null !== Yn && St(false, t3, Yn), _2.dirty && null === Yn || !_2.isCollapsed() || Yi(_2.anchor.getNode()) || null === r2 || _2.applyDOMRange(r2), Yn = null;
    const m2 = _2.anchor, x2 = _2.focus, v2 = m2.getNode(), T2 = x2.getNode();
    if ("insertText" !== n && "insertTranspose" !== n)
      switch (e2.preventDefault(), n) {
        case "insertFromYank":
        case "insertFromDrop":
        case "insertReplacementText":
          Bt(t3, l, e2);
          break;
        case "insertFromComposition":
          ot(null), Bt(t3, l, e2);
          break;
        case "insertLineBreak":
          ot(null), Bt(t3, s, false);
          break;
        case "insertParagraph":
          ot(null), tr && !G ? (tr = false, Bt(t3, s, false)) : Bt(t3, o, void 0);
          break;
        case "insertFromPaste":
        case "insertFromPasteAsQuotation":
          Bt(t3, c, e2);
          break;
        case "deleteByComposition":
          (function(e3, t4) {
            return e3 !== t4 || qi(e3) || qi(t4) || !e3.isToken() || !t4.isToken();
          })(v2, T2) && Bt(t3, u, e2);
          break;
        case "deleteByDrag":
        case "deleteByCut":
          Bt(t3, u, e2);
          break;
        case "deleteContent":
          Bt(t3, i, false);
          break;
        case "deleteWordBackward":
          Bt(t3, a, true);
          break;
        case "deleteWordForward":
          Bt(t3, a, false);
          break;
        case "deleteHardLineBackward":
        case "deleteSoftLineBackward":
          Bt(t3, f, true);
          break;
        case "deleteContentForward":
        case "deleteHardLineForward":
        case "deleteSoftLineForward":
          Bt(t3, f, false);
          break;
        case "formatStrikeThrough":
          Bt(t3, d, "strikethrough");
          break;
        case "formatBold":
          Bt(t3, d, "bold");
          break;
        case "formatItalic":
          Bt(t3, d, "italic");
          break;
        case "formatUnderline":
          Bt(t3, d, "underline");
          break;
        case "historyUndo":
          Bt(t3, h, void 0);
          break;
        case "historyRedo":
          Bt(t3, g, void 0);
      }
    else {
      if ("\n" === y2)
        e2.preventDefault(), Bt(t3, s, false);
      else if (y2 === xe)
        e2.preventDefault(), Bt(t3, o, void 0);
      else if (null == y2 && e2.dataTransfer) {
        const t4 = e2.dataTransfer.getData("text/plain");
        e2.preventDefault(), _2.insertRawText(t4);
      } else
        null != y2 && ir(_2, r2, y2, e2.timeStamp, true) ? (e2.preventDefault(), Bt(t3, l, y2)) : Yn = y2;
      Xn = e2.timeStamp;
    }
  });
}(e, t2)]);
var qn = 0;
var Qn = 0;
var Xn = 0;
var Yn = null;
var Gn = false;
var er = false;
var tr = false;
var nr = false;
var rr = [0, "", 0, "root", 0];
function ir(e, t2, n, r2, i2) {
  const s2 = e.anchor, o2 = e.focus, l2 = s2.getNode(), c2 = Oi(), u2 = nn(c2._window), a2 = null !== u2 ? u2.anchorNode : null, f2 = s2.key, d2 = c2.getElementByKey(f2), h2 = n.length;
  return f2 !== o2.key || !Br(l2) || (!i2 && (!Y || Xn < r2 + 50) || l2.isDirty() && h2 < 2 || mt(n)) && s2.offset !== o2.offset && !l2.isComposing() || Ze(l2) || l2.isDirty() && h2 > 1 || (i2 || !Y) && null !== d2 && !l2.isComposing() && a2 !== et(d2) || null !== u2 && null !== t2 && (!t2.collapsed || t2.startContainer !== u2.anchorNode || t2.startOffset !== u2.anchorOffset) || l2.getFormat() !== e.format || l2.getStyle() !== e.style || Ct(e, l2);
}
function lr(e) {
  if (!e.getTargetRanges)
    return null;
  const t2 = e.getTargetRanges();
  return 0 === t2.length ? null : t2[0];
}
function cr(e, t2) {
  const n = e._compositionKey;
  if (ot(null), null !== n && null != t2) {
    if ("" === t2) {
      const t3 = ct(n), r2 = et(e.getElementByKey(n));
      return void (null !== r2 && null !== r2.nodeValue && Br(t3) && kt(t3, r2.nodeValue, null, null, true));
    }
    if ("\n" === t2[t2.length - 1]) {
      const t3 = fi();
      if (Xr(t3)) {
        const n2 = t3.focus;
        return t3.anchor.set(n2.key, n2.offset, n2.type), void Bt(e, S, null);
      }
    }
  }
  St(true, e, t2);
}
function _r(e, t2, n) {
  Pi();
  const r2 = e.__key, i2 = e.getParent();
  if (null === i2)
    return;
  const s2 = function(e2) {
    const t3 = fi();
    if (!Xr(t3) || !qi(e2))
      return t3;
    const { anchor: n2, focus: r3 } = t3, i3 = n2.getNode(), s3 = r3.getNode();
    return $t(i3, e2) && n2.set(e2.__key, 0, "element"), $t(s3, e2) && r3.set(e2.__key, 0, "element"), t3;
  }(e);
  let o2 = false;
  if (Xr(s2) && t2) {
    const t3 = s2.anchor, n2 = s2.focus;
    t3.key === r2 && (_i(t3, e, i2, e.getPreviousSibling(), e.getNextSibling()), o2 = true), n2.key === r2 && (_i(n2, e, i2, e.getPreviousSibling(), e.getNextSibling()), o2 = true);
  } else
    Zr(s2) && t2 && e.isSelected() && e.selectPrevious();
  if (Xr(s2) && t2 && !o2) {
    const t3 = e.getIndexWithinParent();
    it(e), hi(s2, i2, t3, -1);
  } else
    it(e);
  n || Qt(i2) || i2.canBeEmpty() || !i2.isEmpty() || _r(i2, t2), t2 && Yi(i2) && i2.isEmpty() && i2.selectEnd();
}
var pr = class {
  static getType() {
    H(64, this.name);
  }
  static clone(e) {
    H(65, this.name);
  }
  constructor(e) {
    this.__type = this.constructor.getType(), this.__parent = null, this.__prev = null, this.__next = null, rt(this, e);
  }
  getType() {
    return this.__type;
  }
  isInline() {
    H(137, this.constructor.name);
  }
  isAttached() {
    let e = this.__key;
    for (; null !== e; ) {
      if ("root" === e)
        return true;
      const t2 = ct(e);
      if (null === t2)
        break;
      e = t2.__parent;
    }
    return false;
  }
  isSelected(e) {
    const t2 = e || fi();
    if (null == t2)
      return false;
    const n = t2.getNodes().some((e2) => e2.__key === this.__key);
    return (Br(this) || !Xr(t2) || "element" !== t2.anchor.type || "element" !== t2.focus.type || t2.anchor.key !== t2.focus.key || t2.anchor.offset !== t2.focus.offset) && n;
  }
  getKey() {
    return this.__key;
  }
  getIndexWithinParent() {
    const e = this.getParent();
    if (null === e)
      return -1;
    let t2 = e.getFirstChild(), n = 0;
    for (; null !== t2; ) {
      if (this.is(t2))
        return n;
      n++, t2 = t2.getNextSibling();
    }
    return -1;
  }
  getParent() {
    const e = this.getLatest().__parent;
    return null === e ? null : ct(e);
  }
  getParentOrThrow() {
    const e = this.getParent();
    return null === e && H(66, this.__key), e;
  }
  getTopLevelElement() {
    let e = this;
    for (; null !== e; ) {
      const t2 = e.getParent();
      if (Qt(t2))
        return qi(e) || H(138), e;
      e = t2;
    }
    return null;
  }
  getTopLevelElementOrThrow() {
    const e = this.getTopLevelElement();
    return null === e && H(67, this.__key), e;
  }
  getParents() {
    const e = [];
    let t2 = this.getParent();
    for (; null !== t2; )
      e.push(t2), t2 = t2.getParent();
    return e;
  }
  getParentKeys() {
    const e = [];
    let t2 = this.getParent();
    for (; null !== t2; )
      e.push(t2.__key), t2 = t2.getParent();
    return e;
  }
  getPreviousSibling() {
    const e = this.getLatest().__prev;
    return null === e ? null : ct(e);
  }
  getPreviousSiblings() {
    const e = [], t2 = this.getParent();
    if (null === t2)
      return e;
    let n = t2.getFirstChild();
    for (; null !== n && !n.is(this); )
      e.push(n), n = n.getNextSibling();
    return e;
  }
  getNextSibling() {
    const e = this.getLatest().__next;
    return null === e ? null : ct(e);
  }
  getNextSiblings() {
    const e = [];
    let t2 = this.getNextSibling();
    for (; null !== t2; )
      e.push(t2), t2 = t2.getNextSibling();
    return e;
  }
  getCommonAncestor(e) {
    const t2 = this.getParents(), n = e.getParents();
    qi(this) && t2.unshift(this), qi(e) && n.unshift(e);
    const r2 = t2.length, i2 = n.length;
    if (0 === r2 || 0 === i2 || t2[r2 - 1] !== n[i2 - 1])
      return null;
    const s2 = new Set(n);
    for (let e2 = 0; e2 < r2; e2++) {
      const n2 = t2[e2];
      if (s2.has(n2))
        return n2;
    }
    return null;
  }
  is(e) {
    return null != e && this.__key === e.__key;
  }
  isBefore(e) {
    if (this === e)
      return false;
    if (e.isParentOf(this))
      return true;
    if (this.isParentOf(e))
      return false;
    const t2 = this.getCommonAncestor(e);
    let n = 0, r2 = 0, i2 = this;
    for (; ; ) {
      const e2 = i2.getParentOrThrow();
      if (e2 === t2) {
        n = i2.getIndexWithinParent();
        break;
      }
      i2 = e2;
    }
    for (i2 = e; ; ) {
      const e2 = i2.getParentOrThrow();
      if (e2 === t2) {
        r2 = i2.getIndexWithinParent();
        break;
      }
      i2 = e2;
    }
    return n < r2;
  }
  isParentOf(e) {
    const t2 = this.__key;
    if (t2 === e.__key)
      return false;
    let n = e;
    for (; null !== n; ) {
      if (n.__key === t2)
        return true;
      n = n.getParent();
    }
    return false;
  }
  getNodesBetween(e) {
    const t2 = this.isBefore(e), n = [], r2 = /* @__PURE__ */ new Set();
    let i2 = this;
    for (; null !== i2; ) {
      const s2 = i2.__key;
      if (r2.has(s2) || (r2.add(s2), n.push(i2)), i2 === e)
        break;
      const o2 = qi(i2) ? t2 ? i2.getFirstChild() : i2.getLastChild() : null;
      if (null !== o2) {
        i2 = o2;
        continue;
      }
      const l2 = t2 ? i2.getNextSibling() : i2.getPreviousSibling();
      if (null !== l2) {
        i2 = l2;
        continue;
      }
      const c2 = i2.getParentOrThrow();
      if (r2.has(c2.__key) || n.push(c2), c2 === e)
        break;
      let u2 = null, a2 = c2;
      do {
        if (null === a2 && H(68), u2 = t2 ? a2.getNextSibling() : a2.getPreviousSibling(), a2 = a2.getParent(), null === a2)
          break;
        null !== u2 || r2.has(a2.__key) || n.push(a2);
      } while (null === u2);
      i2 = u2;
    }
    return t2 || n.reverse(), n;
  }
  isDirty() {
    const e = Oi()._dirtyLeaves;
    return null !== e && e.has(this.__key);
  }
  getLatest() {
    const e = ct(this.__key);
    return null === e && H(113), e;
  }
  getWritable() {
    Pi();
    const e = Ii(), t2 = Oi(), n = e._nodeMap, r2 = this.__key, i2 = this.getLatest(), s2 = i2.__parent, o2 = t2._cloneNotNeeded, l2 = fi();
    if (null !== l2 && l2.setCachedNodes(null), o2.has(r2))
      return st(i2), i2;
    const c2 = i2.constructor.clone(i2);
    return c2.__parent = s2, c2.__next = i2.__next, c2.__prev = i2.__prev, qi(i2) && qi(c2) ? (c2.__first = i2.__first, c2.__last = i2.__last, c2.__size = i2.__size, c2.__indent = i2.__indent, c2.__format = i2.__format, c2.__dir = i2.__dir) : Br(i2) && Br(c2) && (c2.__format = i2.__format, c2.__style = i2.__style, c2.__mode = i2.__mode, c2.__detail = i2.__detail), o2.add(r2), c2.__key = r2, st(c2), n.set(r2, c2), c2;
  }
  getTextContent() {
    return "";
  }
  getTextContentSize() {
    return this.getTextContent().length;
  }
  createDOM(e, t2) {
    H(70);
  }
  updateDOM(e, t2, n) {
    H(71);
  }
  exportDOM(e) {
    return { element: this.createDOM(e._config, e) };
  }
  exportJSON() {
    H(72);
  }
  static importJSON(e) {
    H(18, this.name);
  }
  static transform() {
    return null;
  }
  remove(e) {
    _r(this, true, e);
  }
  replace(e, t2) {
    Pi();
    let n = fi();
    null !== n && (n = n.clone()), Zt(this, e);
    const r2 = this.getLatest(), i2 = this.__key, s2 = e.__key, o2 = e.getWritable(), l2 = this.getParentOrThrow().getWritable(), c2 = l2.__size;
    it(o2);
    const u2 = r2.getPreviousSibling(), a2 = r2.getNextSibling(), f2 = r2.__prev, d2 = r2.__next, h2 = r2.__parent;
    if (_r(r2, false, true), null === u2)
      l2.__first = s2;
    else {
      u2.getWritable().__next = s2;
    }
    if (o2.__prev = f2, null === a2)
      l2.__last = s2;
    else {
      a2.getWritable().__prev = s2;
    }
    if (o2.__next = d2, o2.__parent = h2, l2.__size = c2, t2 && (qi(this) && qi(o2) || H(139), this.getChildren().forEach((e2) => {
      o2.append(e2);
    })), Xr(n)) {
      _t(n);
      const e2 = n.anchor, t3 = n.focus;
      e2.key === i2 && Hr(e2, o2), t3.key === i2 && Hr(t3, o2);
    }
    return lt() === i2 && ot(s2), o2;
  }
  insertAfter(e, t2 = true) {
    Pi(), Zt(this, e);
    const n = this.getWritable(), r2 = e.getWritable(), i2 = r2.getParent(), s2 = fi();
    let o2 = false, l2 = false;
    if (null !== i2) {
      const t3 = e.getIndexWithinParent();
      if (it(r2), Xr(s2)) {
        const e2 = i2.__key, n2 = s2.anchor, r3 = s2.focus;
        o2 = "element" === n2.type && n2.key === e2 && n2.offset === t3 + 1, l2 = "element" === r3.type && r3.key === e2 && r3.offset === t3 + 1;
      }
    }
    const c2 = this.getNextSibling(), u2 = this.getParentOrThrow().getWritable(), a2 = r2.__key, f2 = n.__next;
    if (null === c2)
      u2.__last = a2;
    else {
      c2.getWritable().__prev = a2;
    }
    if (u2.__size++, n.__next = a2, r2.__next = f2, r2.__prev = n.__key, r2.__parent = n.__parent, t2 && Xr(s2)) {
      const e2 = this.getIndexWithinParent();
      hi(s2, u2, e2 + 1);
      const t3 = u2.__key;
      o2 && s2.anchor.set(t3, e2 + 2, "element"), l2 && s2.focus.set(t3, e2 + 2, "element");
    }
    return e;
  }
  insertBefore(e, t2 = true) {
    Pi(), Zt(this, e);
    const n = this.getWritable(), r2 = e.getWritable(), i2 = r2.__key;
    it(r2);
    const s2 = this.getPreviousSibling(), o2 = this.getParentOrThrow().getWritable(), l2 = n.__prev, c2 = this.getIndexWithinParent();
    if (null === s2)
      o2.__first = i2;
    else {
      s2.getWritable().__next = i2;
    }
    o2.__size++, n.__prev = i2, r2.__prev = l2, r2.__next = n.__key, r2.__parent = n.__parent;
    const u2 = fi();
    if (t2 && Xr(u2)) {
      hi(u2, this.getParentOrThrow(), c2);
    }
    return e;
  }
  isParentRequired() {
    return false;
  }
  createParentElementNode() {
    return rs();
  }
  selectStart() {
    return this.selectPrevious();
  }
  selectEnd() {
    return this.selectNext(0, 0);
  }
  selectPrevious(e, t2) {
    Pi();
    const n = this.getPreviousSibling(), r2 = this.getParentOrThrow();
    if (null === n)
      return r2.select(0, 0);
    if (qi(n))
      return n.select();
    if (!Br(n)) {
      const e2 = n.getIndexWithinParent() + 1;
      return r2.select(e2, e2);
    }
    return n.select(e, t2);
  }
  selectNext(e, t2) {
    Pi();
    const n = this.getNextSibling(), r2 = this.getParentOrThrow();
    if (null === n)
      return r2.select();
    if (qi(n))
      return n.select(0, 0);
    if (!Br(n)) {
      const e2 = n.getIndexWithinParent();
      return r2.select(e2, e2);
    }
    return n.select(e, t2);
  }
  markDirty() {
    this.getWritable();
  }
};
var yr = class _yr extends pr {
  static getType() {
    return "linebreak";
  }
  static clone(e) {
    return new _yr(e.__key);
  }
  constructor(e) {
    super(e);
  }
  getTextContent() {
    return "\n";
  }
  createDOM() {
    return document.createElement("br");
  }
  updateDOM() {
    return false;
  }
  static importDOM() {
    return { br: (e) => function(e2) {
      const t2 = e2.parentElement;
      if (null !== t2) {
        const n = t2.firstChild;
        if (n === e2 || n.nextSibling === e2 && Tr(n)) {
          const n2 = t2.lastChild;
          if (n2 === e2 || n2.previousSibling === e2 && Tr(n2))
            return true;
        }
      }
      return false;
    }(e) ? null : { conversion: mr, priority: 0 } };
  }
  static importJSON(e) {
    return xr();
  }
  exportJSON() {
    return { type: "linebreak", version: 1 };
  }
};
function mr(e) {
  return { node: xr() };
}
function xr() {
  return Yt(new yr());
}
function vr(e) {
  return e instanceof yr;
}
function Tr(e) {
  return e.nodeType === se && /^( |\t|\r?\n)+$/.test(e.textContent || "");
}
function Sr(e, t2) {
  return 16 & t2 ? "code" : 128 & t2 ? "mark" : 32 & t2 ? "sub" : 64 & t2 ? "sup" : null;
}
function kr(e, t2) {
  return 1 & t2 ? "strong" : 2 & t2 ? "em" : "span";
}
function Cr(e, t2, n, r2, i2) {
  const s2 = r2.classList;
  let o2 = At(i2, "base");
  void 0 !== o2 && s2.add(...o2), o2 = At(i2, "underlineStrikethrough");
  let l2 = false;
  const c2 = t2 & ae && t2 & ue;
  void 0 !== o2 && (n & ae && n & ue ? (l2 = true, c2 || s2.add(...o2)) : c2 && s2.remove(...o2));
  for (const e2 in be) {
    const r3 = be[e2];
    if (o2 = At(i2, e2), void 0 !== o2)
      if (n & r3) {
        if (l2 && ("underline" === e2 || "strikethrough" === e2)) {
          t2 & r3 && s2.remove(...o2);
          continue;
        }
        (0 == (t2 & r3) || c2 && "underline" === e2 || "strikethrough" === e2) && s2.add(...o2);
      } else
        t2 & r3 && s2.remove(...o2);
  }
}
function br(e, t2, n) {
  const r2 = t2.firstChild, i2 = n.isComposing(), s2 = e + (i2 ? me : "");
  if (null == r2)
    t2.textContent = s2;
  else {
    const e2 = r2.nodeValue;
    if (e2 !== s2)
      if (i2 || X) {
        const [t3, n2, i3] = function(e3, t4) {
          const n3 = e3.length, r3 = t4.length;
          let i4 = 0, s3 = 0;
          for (; i4 < n3 && i4 < r3 && e3[i4] === t4[i4]; )
            i4++;
          for (; s3 + i4 < n3 && s3 + i4 < r3 && e3[n3 - s3 - 1] === t4[r3 - s3 - 1]; )
            s3++;
          return [i4, n3 - i4 - s3, t4.slice(i4, r3 - s3)];
        }(e2, s2);
        0 !== n2 && r2.deleteData(t3, n2), r2.insertData(t3, i3);
      } else
        r2.nodeValue = s2;
  }
}
function Nr(e, t2, n, r2, i2, s2) {
  br(i2, e, t2);
  const o2 = s2.theme.text;
  void 0 !== o2 && Cr(0, 0, r2, e, o2);
}
function wr(e, t2) {
  const n = document.createElement(t2);
  return n.appendChild(e), n;
}
var Er = class _Er extends pr {
  static getType() {
    return "text";
  }
  static clone(e) {
    return new _Er(e.__text, e.__key);
  }
  constructor(e, t2) {
    super(t2), this.__text = e, this.__format = 0, this.__style = "", this.__mode = 0, this.__detail = 0;
  }
  getFormat() {
    return this.getLatest().__format;
  }
  getDetail() {
    return this.getLatest().__detail;
  }
  getMode() {
    const e = this.getLatest();
    return De[e.__mode];
  }
  getStyle() {
    return this.getLatest().__style;
  }
  isToken() {
    return 1 === this.getLatest().__mode;
  }
  isComposing() {
    return this.__key === lt();
  }
  isSegmented() {
    return 2 === this.getLatest().__mode;
  }
  isDirectionless() {
    return 0 != (1 & this.getLatest().__detail);
  }
  isUnmergeable() {
    return 0 != (2 & this.getLatest().__detail);
  }
  hasFormat(e) {
    const t2 = be[e];
    return 0 != (this.getFormat() & t2);
  }
  isSimpleText() {
    return "text" === this.__type && 0 === this.__mode;
  }
  getTextContent() {
    return this.getLatest().__text;
  }
  getFormatFlags(e, t2) {
    return tt(this.getLatest().__format, e, t2);
  }
  canHaveFormat() {
    return true;
  }
  createDOM(e, t2) {
    const n = this.__format, r2 = Sr(0, n), i2 = kr(0, n), s2 = null === r2 ? i2 : r2, o2 = document.createElement(s2);
    let l2 = o2;
    this.hasFormat("code") && o2.setAttribute("spellcheck", "false"), null !== r2 && (l2 = document.createElement(i2), o2.appendChild(l2));
    Nr(l2, this, 0, n, this.__text, e);
    const c2 = this.__style;
    return "" !== c2 && (o2.style.cssText = c2), o2;
  }
  updateDOM(e, t2, n) {
    const r2 = this.__text, i2 = e.__format, s2 = this.__format, o2 = Sr(0, i2), l2 = Sr(0, s2), c2 = kr(0, i2), u2 = kr(0, s2);
    if ((null === o2 ? c2 : o2) !== (null === l2 ? u2 : l2))
      return true;
    if (o2 === l2 && c2 !== u2) {
      const e2 = t2.firstChild;
      null == e2 && H(48);
      const i3 = document.createElement(u2);
      return Nr(i3, this, 0, s2, r2, n), t2.replaceChild(i3, e2), false;
    }
    let a2 = t2;
    null !== l2 && null !== o2 && (a2 = t2.firstChild, null == a2 && H(49)), br(r2, a2, this);
    const f2 = n.theme.text;
    void 0 !== f2 && i2 !== s2 && Cr(0, i2, s2, a2, f2);
    const d2 = e.__style, h2 = this.__style;
    return d2 !== h2 && (t2.style.cssText = h2), false;
  }
  static importDOM() {
    return { "#text": () => ({ conversion: Ar, priority: 0 }), b: () => ({ conversion: Dr, priority: 0 }), code: () => ({ conversion: Wr, priority: 0 }), em: () => ({ conversion: Wr, priority: 0 }), i: () => ({ conversion: Wr, priority: 0 }), s: () => ({ conversion: Wr, priority: 0 }), span: () => ({ conversion: Pr, priority: 0 }), strong: () => ({ conversion: Wr, priority: 0 }), sub: () => ({ conversion: Wr, priority: 0 }), sup: () => ({ conversion: Wr, priority: 0 }), u: () => ({ conversion: Wr, priority: 0 }) };
  }
  static importJSON(e) {
    const t2 = zr(e.text);
    return t2.setFormat(e.format), t2.setDetail(e.detail), t2.setMode(e.mode), t2.setStyle(e.style), t2;
  }
  exportDOM(e) {
    let { element: t2 } = super.exportDOM(e);
    return null !== t2 && on(t2) || H(132), t2.style.whiteSpace = "pre-wrap", this.hasFormat("bold") && (t2 = wr(t2, "b")), this.hasFormat("italic") && (t2 = wr(t2, "i")), this.hasFormat("strikethrough") && (t2 = wr(t2, "s")), this.hasFormat("underline") && (t2 = wr(t2, "u")), { element: t2 };
  }
  exportJSON() {
    return { detail: this.getDetail(), format: this.getFormat(), mode: this.getMode(), style: this.getStyle(), text: this.getTextContent(), type: "text", version: 1 };
  }
  selectionTransform(e, t2) {
  }
  setFormat(e) {
    const t2 = this.getWritable();
    return t2.__format = "string" == typeof e ? be[e] : e, t2;
  }
  setDetail(e) {
    const t2 = this.getWritable();
    return t2.__detail = "string" == typeof e ? Ne[e] : e, t2;
  }
  setStyle(e) {
    const t2 = this.getWritable();
    return t2.__style = e, t2;
  }
  toggleFormat(e) {
    const t2 = tt(this.getFormat(), e, null);
    return this.setFormat(t2);
  }
  toggleDirectionless() {
    const e = this.getWritable();
    return e.__detail ^= 1, e;
  }
  toggleUnmergeable() {
    const e = this.getWritable();
    return e.__detail ^= 2, e;
  }
  setMode(e) {
    const t2 = Pe[e];
    if (this.__mode === t2)
      return this;
    const n = this.getWritable();
    return n.__mode = t2, n;
  }
  setTextContent(e) {
    if (this.__text === e)
      return this;
    const t2 = this.getWritable();
    return t2.__text = e, t2;
  }
  select(e, t2) {
    Pi();
    let n = e, r2 = t2;
    const i2 = fi(), s2 = this.getTextContent(), o2 = this.__key;
    if ("string" == typeof s2) {
      const e2 = s2.length;
      void 0 === n && (n = e2), void 0 === r2 && (r2 = e2);
    } else
      n = 0, r2 = 0;
    if (!Xr(i2))
      return li(o2, n, o2, r2, "text", "text");
    {
      const e2 = lt();
      e2 !== i2.anchor.key && e2 !== i2.focus.key || ot(o2), i2.setTextNodeRange(this, n, this, r2);
    }
    return i2;
  }
  selectStart() {
    return this.select(0, 0);
  }
  selectEnd() {
    const e = this.getTextContentSize();
    return this.select(e, e);
  }
  spliceText(e, t2, n, r2) {
    const i2 = this.getWritable(), s2 = i2.__text, o2 = n.length;
    let l2 = e;
    l2 < 0 && (l2 = o2 + l2, l2 < 0 && (l2 = 0));
    const c2 = fi();
    if (r2 && Xr(c2)) {
      const t3 = e + o2;
      c2.setTextNodeRange(i2, t3, i2, t3);
    }
    const u2 = s2.slice(0, l2) + n + s2.slice(l2 + t2);
    return i2.__text = u2, i2;
  }
  canInsertTextBefore() {
    return true;
  }
  canInsertTextAfter() {
    return true;
  }
  splitText(...e) {
    Pi();
    const t2 = this.getLatest(), n = t2.getTextContent(), r2 = t2.__key, i2 = lt(), s2 = new Set(e), o2 = [], l2 = n.length;
    let c2 = "";
    for (let e2 = 0; e2 < l2; e2++)
      "" !== c2 && s2.has(e2) && (o2.push(c2), c2 = ""), c2 += n[e2];
    "" !== c2 && o2.push(c2);
    const u2 = o2.length;
    if (0 === u2)
      return [];
    if (o2[0] === n)
      return [t2];
    const a2 = o2[0], f2 = t2.getParentOrThrow();
    let d2;
    const h2 = t2.getFormat(), g2 = t2.getStyle(), _2 = t2.__detail;
    let p2 = false;
    t2.isSegmented() ? (d2 = zr(a2), d2.__format = h2, d2.__style = g2, d2.__detail = _2, p2 = true) : (d2 = t2.getWritable(), d2.__text = a2);
    const y2 = fi(), m2 = [d2];
    let x2 = a2.length;
    for (let e2 = 1; e2 < u2; e2++) {
      const t3 = o2[e2], n2 = t3.length, s3 = zr(t3).getWritable();
      s3.__format = h2, s3.__style = g2, s3.__detail = _2;
      const l3 = s3.__key, c3 = x2 + n2;
      if (Xr(y2)) {
        const e3 = y2.anchor, t4 = y2.focus;
        e3.key === r2 && "text" === e3.type && e3.offset > x2 && e3.offset <= c3 && (e3.key = l3, e3.offset -= x2, y2.dirty = true), t4.key === r2 && "text" === t4.type && t4.offset > x2 && t4.offset <= c3 && (t4.key = l3, t4.offset -= x2, y2.dirty = true);
      }
      i2 === r2 && ot(l3), x2 = c3, m2.push(s3);
    }
    !function(e2) {
      const t3 = e2.getPreviousSibling(), n2 = e2.getNextSibling();
      null !== t3 && st(t3), null !== n2 && st(n2);
    }(this);
    const v2 = f2.getWritable(), T2 = this.getIndexWithinParent();
    return p2 ? (v2.splice(T2, 0, m2), this.remove()) : v2.splice(T2, 1, m2), Xr(y2) && hi(y2, f2, T2, u2 - 1), m2;
  }
  mergeWithSibling(e) {
    const t2 = e === this.getPreviousSibling();
    t2 || e === this.getNextSibling() || H(50);
    const n = this.__key, r2 = e.__key, i2 = this.__text, s2 = i2.length;
    lt() === r2 && ot(n);
    const o2 = fi();
    if (Xr(o2)) {
      const i3 = o2.anchor, l3 = o2.focus;
      null !== i3 && i3.key === r2 && (pi(i3, t2, n, e, s2), o2.dirty = true), null !== l3 && l3.key === r2 && (pi(l3, t2, n, e, s2), o2.dirty = true);
    }
    const l2 = e.__text, c2 = t2 ? l2 + i2 : i2 + l2;
    this.setTextContent(c2);
    const u2 = this.getWritable();
    return e.remove(), u2;
  }
  isTextEntity() {
    return false;
  }
};
function Pr(e) {
  const t2 = e, n = "700" === t2.style.fontWeight, r2 = "line-through" === t2.style.textDecoration, i2 = "italic" === t2.style.fontStyle, s2 = "underline" === t2.style.textDecoration, o2 = t2.style.verticalAlign;
  return { forChild: (e2) => Br(e2) ? (n && e2.toggleFormat("bold"), r2 && e2.toggleFormat("strikethrough"), i2 && e2.toggleFormat("italic"), s2 && e2.toggleFormat("underline"), "sub" === o2 && e2.toggleFormat("subscript"), "super" === o2 && e2.toggleFormat("superscript"), e2) : e2, node: null };
}
function Dr(e) {
  const t2 = "normal" === e.style.fontWeight;
  return { forChild: (e2) => (Br(e2) && !t2 && e2.toggleFormat("bold"), e2), node: null };
}
var Ir = /* @__PURE__ */ new WeakMap();
function Or(e) {
  return "PRE" === e.nodeName || e.nodeType === ie && void 0 !== e.style && void 0 !== e.style.whiteSpace && e.style.whiteSpace.startsWith("pre");
}
function Ar(e) {
  const t2 = e;
  null === e.parentElement && H(129);
  let n = t2.textContent || "";
  if (null !== function(e2) {
    let t3, n2 = e2.parentNode;
    const r2 = [e2];
    for (; null !== n2 && void 0 === (t3 = Ir.get(n2)) && !Or(n2); )
      r2.push(n2), n2 = n2.parentNode;
    const i2 = void 0 === t3 ? n2 : t3;
    for (let e3 = 0; e3 < r2.length; e3++)
      Ir.set(r2[e3], i2);
    return i2;
  }(t2)) {
    const e2 = n.split(/(\r?\n|\t)/), t3 = [], r2 = e2.length;
    for (let n2 = 0; n2 < r2; n2++) {
      const r3 = e2[n2];
      "\n" === r3 || "\r\n" === r3 ? t3.push(xr()) : "	" === r3 ? t3.push(Kr()) : "" !== r3 && t3.push(zr(r3));
    }
    return { node: t3 };
  }
  if (n = n.replace(/\r/g, "").replace(/[ \t\n]+/g, " "), "" === n)
    return { node: null };
  if (" " === n[0]) {
    let e2 = t2, r2 = true;
    for (; null !== e2 && null !== (e2 = Fr(e2, false)); ) {
      const t3 = e2.textContent || "";
      if (t3.length > 0) {
        /[ \t\n]$/.test(t3) && (n = n.slice(1)), r2 = false;
        break;
      }
    }
    r2 && (n = n.slice(1));
  }
  if (" " === n[n.length - 1]) {
    let e2 = t2, r2 = true;
    for (; null !== e2 && null !== (e2 = Fr(e2, true)); ) {
      if ((e2.textContent || "").replace(/^( |\t|\r?\n)+/, "").length > 0) {
        r2 = false;
        break;
      }
    }
    r2 && (n = n.slice(0, n.length - 1));
  }
  return "" === n ? { node: null } : { node: zr(n) };
}
var Lr = new RegExp(/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/, "i");
function Fr(e, t2) {
  let n = e;
  for (; ; ) {
    let e2;
    for (; null === (e2 = t2 ? n.nextSibling : n.previousSibling); ) {
      const e3 = n.parentElement;
      if (null === e3)
        return null;
      n = e3;
    }
    if (n = e2, n.nodeType === ie) {
      const e3 = n.style.display;
      if ("" === e3 && null === n.nodeName.match(Lr) || "" !== e3 && !e3.startsWith("inline"))
        return null;
    }
    let r2 = n;
    for (; null !== (r2 = t2 ? n.firstChild : n.lastChild); )
      n = r2;
    if (n.nodeType === se)
      return n;
    if ("BR" === n.nodeName)
      return null;
  }
}
var Mr = { code: "code", em: "italic", i: "italic", s: "strikethrough", strong: "bold", sub: "subscript", sup: "superscript", u: "underline" };
function Wr(e) {
  const t2 = Mr[e.nodeName.toLowerCase()];
  return void 0 === t2 ? { node: null } : { forChild: (e2) => (Br(e2) && !e2.hasFormat(t2) && e2.toggleFormat(t2), e2), node: null };
}
function zr(e = "") {
  return Yt(new Er(e));
}
function Br(e) {
  return e instanceof Er;
}
var Rr = class _Rr extends Er {
  static getType() {
    return "tab";
  }
  static clone(e) {
    const t2 = new _Rr(e.__key);
    return t2.__text = e.__text, t2.__format = e.__format, t2.__style = e.__style, t2;
  }
  constructor(e) {
    super("	", e), this.__detail = 2;
  }
  static importDOM() {
    return null;
  }
  static importJSON(e) {
    const t2 = Kr();
    return t2.setFormat(e.format), t2.setStyle(e.style), t2;
  }
  exportJSON() {
    return { ...super.exportJSON(), type: "tab", version: 1 };
  }
  setTextContent(e) {
    H(126);
  }
  setDetail(e) {
    H(127);
  }
  setMode(e) {
    H(128);
  }
  canInsertTextBefore() {
    return false;
  }
  canInsertTextAfter() {
    return false;
  }
};
function Kr() {
  return Yt(new Rr());
}
function Jr(e) {
  return e instanceof Rr;
}
var Ur = class {
  constructor(e, t2, n) {
    this._selection = null, this.key = e, this.offset = t2, this.type = n;
  }
  is(e) {
    return this.key === e.key && this.offset === e.offset && this.type === e.type;
  }
  isBefore(e) {
    let t2 = this.getNode(), n = e.getNode();
    const r2 = this.offset, i2 = e.offset;
    if (qi(t2)) {
      const e2 = t2.getDescendantByIndex(r2);
      t2 = null != e2 ? e2 : t2;
    }
    if (qi(n)) {
      const e2 = n.getDescendantByIndex(i2);
      n = null != e2 ? e2 : n;
    }
    return t2 === n ? r2 < i2 : t2.isBefore(n);
  }
  getNode() {
    const e = ct(this.key);
    return null === e && H(20), e;
  }
  set(e, t2, n) {
    const r2 = this._selection, i2 = this.key;
    this.key = e, this.offset = t2, this.type = n, Ei() || (lt() === i2 && ot(e), null !== r2 && (r2.setCachedNodes(null), r2.dirty = true));
  }
};
function Vr(e, t2, n) {
  return new Ur(e, t2, n);
}
function $r(e, t2) {
  let n = t2.__key, r2 = e.offset, i2 = "element";
  if (Br(t2)) {
    i2 = "text";
    const e2 = t2.getTextContentSize();
    r2 > e2 && (r2 = e2);
  } else if (!qi(t2)) {
    const e2 = t2.getNextSibling();
    if (Br(e2))
      n = e2.__key, r2 = 0, i2 = "text";
    else {
      const e3 = t2.getParent();
      e3 && (n = e3.__key, r2 = t2.getIndexWithinParent() + 1);
    }
  }
  e.set(n, r2, i2);
}
function Hr(e, t2) {
  if (qi(t2)) {
    const n = t2.getLastDescendant();
    qi(n) || Br(n) ? $r(e, n) : $r(e, t2);
  } else
    $r(e, t2);
}
function jr(e, t2, n, r2) {
  const i2 = e.getNode(), s2 = i2.getChildAtIndex(e.offset), o2 = zr(), l2 = Yi(i2) ? rs().append(o2) : o2;
  o2.setFormat(n), o2.setStyle(r2), null === s2 ? i2.append(l2) : s2.insertBefore(l2), e.is(t2) && t2.set(o2.__key, 0, "text"), e.set(o2.__key, 0, "text");
}
function qr(e, t2, n, r2) {
  e.key = t2, e.offset = n, e.type = r2;
}
var Qr = class _Qr {
  constructor(e) {
    this._cachedNodes = null, this._nodes = e, this.dirty = false;
  }
  getCachedNodes() {
    return this._cachedNodes;
  }
  setCachedNodes(e) {
    this._cachedNodes = e;
  }
  is(e) {
    if (!Zr(e))
      return false;
    const t2 = this._nodes, n = e._nodes;
    return t2.size === n.size && Array.from(t2).every((e2) => n.has(e2));
  }
  isCollapsed() {
    return false;
  }
  isBackward() {
    return false;
  }
  getStartEndPoints() {
    return null;
  }
  add(e) {
    this.dirty = true, this._nodes.add(e), this._cachedNodes = null;
  }
  delete(e) {
    this.dirty = true, this._nodes.delete(e), this._cachedNodes = null;
  }
  clear() {
    this.dirty = true, this._nodes.clear(), this._cachedNodes = null;
  }
  has(e) {
    return this._nodes.has(e);
  }
  clone() {
    return new _Qr(new Set(this._nodes));
  }
  extract() {
    return this.getNodes();
  }
  insertRawText(e) {
  }
  insertText() {
  }
  insertNodes(e) {
    const t2 = this.getNodes(), n = t2.length, r2 = t2[n - 1];
    let i2;
    if (Br(r2))
      i2 = r2.select();
    else {
      const e2 = r2.getIndexWithinParent() + 1;
      i2 = r2.getParentOrThrow().select(e2, e2);
    }
    i2.insertNodes(e);
    for (let e2 = 0; e2 < n; e2++)
      t2[e2].remove();
  }
  getNodes() {
    const e = this._cachedNodes;
    if (null !== e)
      return e;
    const t2 = this._nodes, n = [];
    for (const e2 of t2) {
      const t3 = ct(e2);
      null !== t3 && n.push(t3);
    }
    return Ei() || (this._cachedNodes = n), n;
  }
  getTextContent() {
    const e = this.getNodes();
    let t2 = "";
    for (let n = 0; n < e.length; n++)
      t2 += e[n].getTextContent();
    return t2;
  }
};
function Xr(e) {
  return e instanceof Yr;
}
var Yr = class _Yr {
  constructor(e, t2, n, r2) {
    this.anchor = e, this.focus = t2, e._selection = this, t2._selection = this, this._cachedNodes = null, this.format = n, this.style = r2, this.dirty = false;
  }
  getCachedNodes() {
    return this._cachedNodes;
  }
  setCachedNodes(e) {
    this._cachedNodes = e;
  }
  is(e) {
    return !!Xr(e) && (this.anchor.is(e.anchor) && this.focus.is(e.focus) && this.format === e.format && this.style === e.style);
  }
  isCollapsed() {
    return this.anchor.is(this.focus);
  }
  getNodes() {
    const e = this._cachedNodes;
    if (null !== e)
      return e;
    const t2 = this.anchor, n = this.focus, r2 = t2.isBefore(n), i2 = r2 ? t2 : n, s2 = r2 ? n : t2;
    let o2 = i2.getNode(), l2 = s2.getNode();
    const c2 = i2.offset, u2 = s2.offset;
    if (qi(o2)) {
      const e2 = o2.getDescendantByIndex(c2);
      o2 = null != e2 ? e2 : o2;
    }
    if (qi(l2)) {
      let e2 = l2.getDescendantByIndex(u2);
      null !== e2 && e2 !== o2 && l2.getChildAtIndex(u2) === e2 && (e2 = e2.getPreviousSibling()), l2 = null != e2 ? e2 : l2;
    }
    let a2;
    return a2 = o2.is(l2) ? qi(o2) && o2.getChildrenSize() > 0 ? [] : [o2] : o2.getNodesBetween(l2), Ei() || (this._cachedNodes = a2), a2;
  }
  setTextNodeRange(e, t2, n, r2) {
    qr(this.anchor, e.__key, t2, "text"), qr(this.focus, n.__key, r2, "text"), this._cachedNodes = null, this.dirty = true;
  }
  getTextContent() {
    const e = this.getNodes();
    if (0 === e.length)
      return "";
    const t2 = e[0], n = e[e.length - 1], r2 = this.anchor, i2 = this.focus, s2 = r2.isBefore(i2), [o2, l2] = ei(this);
    let c2 = "", u2 = true;
    for (let a2 = 0; a2 < e.length; a2++) {
      const f2 = e[a2];
      if (qi(f2) && !f2.isInline())
        u2 || (c2 += "\n"), u2 = !f2.isEmpty();
      else if (u2 = false, Br(f2)) {
        let e2 = f2.getTextContent();
        f2 === t2 ? f2 === n ? "element" === r2.type && "element" === i2.type && i2.offset !== r2.offset || (e2 = o2 < l2 ? e2.slice(o2, l2) : e2.slice(l2, o2)) : e2 = s2 ? e2.slice(o2) : e2.slice(l2) : f2 === n && (e2 = s2 ? e2.slice(0, l2) : e2.slice(0, o2)), c2 += e2;
      } else
        !Hi(f2) && !vr(f2) || f2 === n && this.isCollapsed() || (c2 += f2.getTextContent());
    }
    return c2;
  }
  applyDOMRange(e) {
    const t2 = Oi(), n = t2.getEditorState()._selection, r2 = si(e.startContainer, e.startOffset, e.endContainer, e.endOffset, t2, n);
    if (null === r2)
      return;
    const [i2, s2] = r2;
    qr(this.anchor, i2.key, i2.offset, i2.type), qr(this.focus, s2.key, s2.offset, s2.type), this._cachedNodes = null;
  }
  clone() {
    const e = this.anchor, t2 = this.focus;
    return new _Yr(Vr(e.key, e.offset, e.type), Vr(t2.key, t2.offset, t2.type), this.format, this.style);
  }
  toggleFormat(e) {
    this.format = tt(this.format, e, null), this.dirty = true;
  }
  setStyle(e) {
    this.style = e, this.dirty = true;
  }
  hasFormat(e) {
    const t2 = be[e];
    return 0 != (this.format & t2);
  }
  insertRawText(e) {
    const t2 = e.split(/(\r?\n|\t)/), n = [], r2 = t2.length;
    for (let e2 = 0; e2 < r2; e2++) {
      const r3 = t2[e2];
      "\n" === r3 || "\r\n" === r3 ? n.push(xr()) : "	" === r3 ? n.push(Kr()) : n.push(zr(r3));
    }
    this.insertNodes(n);
  }
  insertText(e) {
    const t2 = this.anchor, n = this.focus, r2 = this.isCollapsed() || t2.isBefore(n), i2 = this.format, s2 = this.style;
    r2 && "element" === t2.type ? jr(t2, n, i2, s2) : r2 || "element" !== n.type || jr(n, t2, i2, s2);
    const o2 = this.getNodes(), l2 = o2.length, c2 = r2 ? n : t2, u2 = (r2 ? t2 : n).offset, a2 = c2.offset;
    let f2 = o2[0];
    Br(f2) || H(26);
    const d2 = f2.getTextContent().length, h2 = f2.getParentOrThrow();
    let g2 = o2[l2 - 1];
    if (this.isCollapsed() && u2 === d2 && (f2.isSegmented() || f2.isToken() || !f2.canInsertTextAfter() || !h2.canInsertTextAfter() && null === f2.getNextSibling())) {
      let t3 = f2.getNextSibling();
      if (Br(t3) && t3.canInsertTextBefore() && !Ze(t3) || (t3 = zr(), t3.setFormat(i2), h2.canInsertTextAfter() ? f2.insertAfter(t3) : h2.insertAfter(t3)), t3.select(0, 0), f2 = t3, "" !== e)
        return void this.insertText(e);
    } else if (this.isCollapsed() && 0 === u2 && (f2.isSegmented() || f2.isToken() || !f2.canInsertTextBefore() || !h2.canInsertTextBefore() && null === f2.getPreviousSibling())) {
      let t3 = f2.getPreviousSibling();
      if (Br(t3) && !Ze(t3) || (t3 = zr(), t3.setFormat(i2), h2.canInsertTextBefore() ? f2.insertBefore(t3) : h2.insertBefore(t3)), t3.select(), f2 = t3, "" !== e)
        return void this.insertText(e);
    } else if (f2.isSegmented() && u2 !== d2) {
      const e2 = zr(f2.getTextContent());
      e2.setFormat(i2), f2.replace(e2), f2 = e2;
    } else if (!this.isCollapsed() && "" !== e) {
      const t3 = g2.getParent();
      if (!h2.canInsertTextBefore() || !h2.canInsertTextAfter() || qi(t3) && (!t3.canInsertTextBefore() || !t3.canInsertTextAfter()))
        return this.insertText(""), ii(this.anchor, this.focus, null), void this.insertText(e);
    }
    if (1 === l2) {
      if (f2.isToken()) {
        const t4 = zr(e);
        return t4.select(), void f2.replace(t4);
      }
      const t3 = f2.getFormat(), n2 = f2.getStyle();
      if (u2 !== a2 || t3 === i2 && n2 === s2) {
        if (Jr(f2)) {
          const t4 = zr(e);
          return t4.setFormat(i2), t4.setStyle(s2), t4.select(), void f2.replace(t4);
        }
      } else {
        if ("" !== f2.getTextContent()) {
          const t4 = zr(e);
          if (t4.setFormat(i2), t4.setStyle(s2), t4.select(), 0 === u2)
            f2.insertBefore(t4, false);
          else {
            const [e2] = f2.splitText(u2);
            e2.insertAfter(t4, false);
          }
          return void (t4.isComposing() && "text" === this.anchor.type && (this.anchor.offset -= e.length));
        }
        f2.setFormat(i2), f2.setStyle(s2);
      }
      const r3 = a2 - u2;
      f2 = f2.spliceText(u2, r3, e, true), "" === f2.getTextContent() ? f2.remove() : "text" === this.anchor.type && (f2.isComposing() ? this.anchor.offset -= e.length : (this.format = t3, this.style = n2));
    } else {
      const t3 = /* @__PURE__ */ new Set([...f2.getParentKeys(), ...g2.getParentKeys()]), n2 = qi(f2) ? f2 : f2.getParentOrThrow();
      let r3 = qi(g2) ? g2 : g2.getParentOrThrow(), i3 = g2;
      if (!n2.is(r3) && r3.isInline())
        do {
          i3 = r3, r3 = r3.getParentOrThrow();
        } while (r3.isInline());
      if ("text" === c2.type && (0 !== a2 || "" === g2.getTextContent()) || "element" === c2.type && g2.getIndexWithinParent() < a2)
        if (Br(g2) && !g2.isToken() && a2 !== g2.getTextContentSize()) {
          if (g2.isSegmented()) {
            const e2 = zr(g2.getTextContent());
            g2.replace(e2), g2 = e2;
          }
          Yi(c2.getNode()) || "text" !== c2.type || (g2 = g2.spliceText(0, a2, "")), t3.add(g2.__key);
        } else {
          const e2 = g2.getParentOrThrow();
          e2.canBeEmpty() || 1 !== e2.getChildrenSize() ? g2.remove() : e2.remove();
        }
      else
        t3.add(g2.__key);
      const s3 = r3.getChildren(), h3 = new Set(o2), _2 = n2.is(r3), p2 = n2.isInline() && null === f2.getNextSibling() ? n2 : f2;
      for (let e2 = s3.length - 1; e2 >= 0; e2--) {
        const t4 = s3[e2];
        if (t4.is(f2) || qi(t4) && t4.isParentOf(f2))
          break;
        t4.isAttached() && (!h3.has(t4) || t4.is(i3) ? _2 || p2.insertAfter(t4, false) : t4.remove());
      }
      if (!_2) {
        let e2 = r3, n3 = null;
        for (; null !== e2; ) {
          const r4 = e2.getChildren(), i4 = r4.length;
          (0 === i4 || r4[i4 - 1].is(n3)) && (t3.delete(e2.__key), n3 = e2), e2 = e2.getParent();
        }
      }
      if (f2.isToken())
        if (u2 === d2)
          f2.select();
        else {
          const t4 = zr(e);
          t4.select(), f2.replace(t4);
        }
      else
        f2 = f2.spliceText(u2, d2 - u2, e, true), "" === f2.getTextContent() ? f2.remove() : f2.isComposing() && "text" === this.anchor.type && (this.anchor.offset -= e.length);
      for (let e2 = 1; e2 < l2; e2++) {
        const n3 = o2[e2], r4 = n3.__key;
        t3.has(r4) || n3.remove();
      }
    }
  }
  removeText() {
    this.insertText("");
  }
  formatText(e) {
    if (this.isCollapsed())
      return this.toggleFormat(e), void ot(null);
    const t2 = this.getNodes(), n = [];
    for (const e2 of t2)
      Br(e2) && n.push(e2);
    const r2 = n.length;
    if (0 === r2)
      return this.toggleFormat(e), void ot(null);
    const i2 = this.anchor, s2 = this.focus, o2 = this.isBackward(), l2 = o2 ? s2 : i2, c2 = o2 ? i2 : s2;
    let u2 = 0, a2 = n[0], f2 = "element" === l2.type ? 0 : l2.offset;
    if ("text" === l2.type && f2 === a2.getTextContentSize() && (u2 = 1, a2 = n[1], f2 = 0), null == a2)
      return;
    const d2 = a2.getFormatFlags(e, null), h2 = r2 - 1;
    let g2 = n[h2];
    const _2 = "text" === c2.type ? c2.offset : g2.getTextContentSize();
    if (a2.is(g2)) {
      if (f2 === _2)
        return;
      if (0 === f2 && _2 === a2.getTextContentSize())
        a2.setFormat(d2);
      else {
        const e2 = a2.splitText(f2, _2), t3 = 0 === f2 ? e2[0] : e2[1];
        t3.setFormat(d2), "text" === l2.type && l2.set(t3.__key, 0, "text"), "text" === c2.type && c2.set(t3.__key, _2 - f2, "text");
      }
      return void (this.format = d2);
    }
    0 !== f2 && ([, a2] = a2.splitText(f2), f2 = 0), a2.setFormat(d2);
    const p2 = g2.getFormatFlags(e, d2);
    _2 > 0 && (_2 !== g2.getTextContentSize() && ([g2] = g2.splitText(_2)), g2.setFormat(p2));
    for (let t3 = u2 + 1; t3 < h2; t3++) {
      const r3 = n[t3];
      if (!r3.isToken()) {
        const t4 = r3.getFormatFlags(e, p2);
        r3.setFormat(t4);
      }
    }
    "text" === l2.type && l2.set(a2.__key, f2, "text"), "text" === c2.type && c2.set(g2.__key, _2, "text"), this.format = d2 | p2;
  }
  insertNodes(e) {
    if (0 === e.length)
      return;
    if ("root" === this.anchor.key) {
      this.insertParagraph();
      const t3 = fi();
      return Xr(t3) || H(134), t3.insertNodes(e);
    }
    const t2 = cn((this.isBackward() ? this.focus : this.anchor).getNode(), ln), n = e[e.length - 1];
    if ("__language" in t2 && qi(t2)) {
      if ("__language" in e[0])
        this.insertText(e[0].getTextContent());
      else {
        const r3 = vi(this);
        t2.splice(r3, 0, e), n.selectEnd();
      }
      return;
    }
    if (!e.some((e2) => (qi(e2) || Hi(e2)) && !e2.isInline())) {
      qi(t2) || H(135);
      const r3 = vi(this);
      return t2.splice(r3, 0, e), void n.selectEnd();
    }
    const r2 = function(e2) {
      const t3 = rs();
      let n2 = null;
      for (let r3 = 0; r3 < e2.length; r3++) {
        const i3 = e2[r3], s3 = vr(i3);
        if (s3 || Hi(i3) && i3.isInline() || qi(i3) && i3.isInline() || Br(i3) || i3.isParentRequired()) {
          if (null === n2 && (n2 = i3.createParentElementNode(), t3.append(n2), s3))
            continue;
          null !== n2 && n2.append(i3);
        } else
          t3.append(i3), n2 = null;
      }
      return t3;
    }(e), i2 = r2.getLastDescendant(), s2 = r2.getChildren(), o2 = (e2) => "__value" in e2 && "__checked" in e2, l2 = !qi(t2) || !t2.isEmpty() ? this.insertParagraph() : null, c2 = s2[s2.length - 1];
    let u2 = s2[0];
    var a2;
    qi(a2 = u2) && ln(a2) && !a2.isEmpty() && qi(t2) && (!t2.isEmpty() || o2(t2)) && (qi(t2) || H(135), t2.append(...u2.getChildren()), u2 = s2[1]), u2 && function(e2, t3, n2) {
      const r3 = n2 || t3.getParentOrThrow().getLastChild();
      let i3 = t3;
      const s3 = [t3];
      for (; i3 !== r3; )
        i3.getNextSibling() || H(140), i3 = i3.getNextSibling(), s3.push(i3);
      let o3 = e2;
      for (const e3 of s3)
        o3 = o3.insertAfter(e3);
    }(t2, u2);
    const f2 = cn(i2, ln);
    l2 && qi(f2) && (o2(l2) || ln(c2)) && (f2.append(...l2.getChildren()), l2.remove()), qi(t2) && t2.isEmpty() && t2.remove(), i2.selectEnd();
    const d2 = qi(t2) ? t2.getLastChild() : null;
    vr(d2) && f2 !== t2 && d2.remove();
  }
  insertParagraph() {
    if ("root" === this.anchor.key) {
      const e2 = rs();
      return ht().splice(this.anchor.offset, 0, [e2]), e2.select(), e2;
    }
    const e = vi(this), t2 = cn(this.anchor.getNode(), ln);
    qi(t2) || H(136);
    const n = t2.getChildAtIndex(e), r2 = n ? [n, ...n.getNextSiblings()] : [], i2 = t2.insertNewAfter(this, false);
    return i2 ? (i2.append(...r2), i2.selectStart(), i2) : null;
  }
  insertLineBreak(e) {
    const t2 = xr();
    if (this.insertNodes([t2]), e) {
      const e2 = t2.getParentOrThrow(), n = t2.getIndexWithinParent();
      e2.select(n, n);
    }
  }
  extract() {
    const e = this.getNodes(), t2 = e.length, n = t2 - 1, r2 = this.anchor, i2 = this.focus;
    let s2 = e[0], o2 = e[n];
    const [l2, c2] = ei(this);
    if (0 === t2)
      return [];
    if (1 === t2) {
      if (Br(s2) && !this.isCollapsed()) {
        const e2 = l2 > c2 ? c2 : l2, t3 = l2 > c2 ? l2 : c2, n2 = s2.splitText(e2, t3), r3 = 0 === e2 ? n2[0] : n2[1];
        return null != r3 ? [r3] : [];
      }
      return [s2];
    }
    const u2 = r2.isBefore(i2);
    if (Br(s2)) {
      const t3 = u2 ? l2 : c2;
      t3 === s2.getTextContentSize() ? e.shift() : 0 !== t3 && ([, s2] = s2.splitText(t3), e[0] = s2);
    }
    if (Br(o2)) {
      const t3 = o2.getTextContent().length, r3 = u2 ? c2 : l2;
      0 === r3 ? e.pop() : r3 !== t3 && ([o2] = o2.splitText(r3), e[n] = o2);
    }
    return e;
  }
  modify(e, t2, n) {
    const r2 = this.focus, i2 = this.anchor, s2 = "move" === e, o2 = Wt(r2, t2);
    if (Hi(o2) && !o2.isIsolated()) {
      if (s2 && o2.isKeyboardSelectable()) {
        const e3 = ui();
        return e3.add(o2.__key), void _t(e3);
      }
      const e2 = t2 ? o2.getPreviousSibling() : o2.getNextSibling();
      if (Br(e2)) {
        const n2 = e2.__key, o3 = t2 ? e2.getTextContent().length : 0;
        return r2.set(n2, o3, "text"), void (s2 && i2.set(n2, o3, "text"));
      }
      {
        const n2 = o2.getParentOrThrow();
        let l3, c3;
        return qi(e2) ? (c3 = e2.__key, l3 = t2 ? e2.getChildrenSize() : 0) : (l3 = o2.getIndexWithinParent(), c3 = n2.__key, t2 || l3++), r2.set(c3, l3, "element"), void (s2 && i2.set(c3, l3, "element"));
      }
    }
    const l2 = Oi(), c2 = nn(l2._window);
    if (!c2)
      return;
    const u2 = l2._blockCursorElement, a2 = l2._rootElement;
    if (null === a2 || null === u2 || !qi(o2) || o2.isInline() || o2.canBeEmpty() || en(u2, l2, a2), function(e2, t3, n2, r3) {
      e2.modify(t3, n2, r3);
    }(c2, e, t2 ? "backward" : "forward", n), c2.rangeCount > 0) {
      const e2 = c2.getRangeAt(0), n2 = this.anchor.getNode(), r3 = Yi(n2) ? n2 : qt(n2);
      if (this.applyDOMRange(e2), this.dirty = true, !s2) {
        const n3 = this.getNodes(), i3 = [];
        let s3 = false;
        for (let e3 = 0; e3 < n3.length; e3++) {
          const t3 = n3[e3];
          $t(t3, r3) ? i3.push(t3) : s3 = true;
        }
        if (s3 && i3.length > 0)
          if (t2) {
            const e3 = i3[0];
            qi(e3) ? e3.selectStart() : e3.getParentOrThrow().selectStart();
          } else {
            const e3 = i3[i3.length - 1];
            qi(e3) ? e3.selectEnd() : e3.getParentOrThrow().selectEnd();
          }
        c2.anchorNode === e2.startContainer && c2.anchorOffset === e2.startOffset || function(e3) {
          const t3 = e3.focus, n4 = e3.anchor, r4 = n4.key, i4 = n4.offset, s4 = n4.type;
          qr(n4, t3.key, t3.offset, t3.type), qr(t3, r4, i4, s4), e3._cachedNodes = null;
        }(this);
      }
    }
  }
  forwardDeletion(e, t2, n) {
    if (!n && ("element" === e.type && qi(t2) && e.offset === t2.getChildrenSize() || "text" === e.type && e.offset === t2.getTextContentSize())) {
      const e2 = t2.getParent(), n2 = t2.getNextSibling() || (null === e2 ? null : e2.getNextSibling());
      if (qi(n2) && n2.isShadowRoot())
        return true;
    }
    return false;
  }
  deleteCharacter(e) {
    const n = this.isCollapsed();
    if (this.isCollapsed()) {
      const n2 = this.anchor;
      let r2 = n2.getNode();
      if (this.forwardDeletion(n2, r2, e))
        return;
      const i2 = this.focus, s2 = Wt(i2, e);
      if (Hi(s2) && !s2.isIsolated()) {
        if (s2.isKeyboardSelectable() && qi(r2) && 0 === r2.getChildrenSize()) {
          r2.remove();
          const e2 = ui();
          e2.add(s2.__key), _t(e2);
        } else {
          s2.remove();
          Oi().dispatchCommand(t, void 0);
        }
        return;
      }
      if (!e && qi(s2) && qi(r2) && r2.isEmpty())
        return r2.remove(), void s2.selectStart();
      if (this.modify("extend", e, "character"), this.isCollapsed()) {
        if (e && 0 === n2.offset) {
          if (("element" === n2.type ? n2.getNode() : n2.getNode().getParentOrThrow()).collapseAtStart(this))
            return;
        }
      } else {
        const t2 = "text" === i2.type ? i2.getNode() : null;
        if (r2 = "text" === n2.type ? n2.getNode() : null, null !== t2 && t2.isSegmented()) {
          const n3 = i2.offset, s3 = t2.getTextContentSize();
          if (t2.is(r2) || e && n3 !== s3 || !e && 0 !== n3)
            return void ti(t2, e, n3);
        } else if (null !== r2 && r2.isSegmented()) {
          const i3 = n2.offset, s3 = r2.getTextContentSize();
          if (r2.is(t2) || e && 0 !== i3 || !e && i3 !== s3)
            return void ti(r2, e, i3);
        }
        !function(e2, t3) {
          const n3 = e2.anchor, r3 = e2.focus, i3 = n3.getNode(), s3 = r3.getNode();
          if (i3 === s3 && "text" === n3.type && "text" === r3.type) {
            const e3 = n3.offset, s4 = r3.offset, o2 = e3 < s4, l2 = o2 ? e3 : s4, c2 = o2 ? s4 : e3, u2 = c2 - 1;
            if (l2 !== u2) {
              mt(i3.getTextContent().slice(l2, c2)) || (t3 ? r3.offset = u2 : n3.offset = u2);
            }
          }
        }(this, e);
      }
    }
    if (this.removeText(), e && !n && this.isCollapsed() && "element" === this.anchor.type && 0 === this.anchor.offset) {
      const e2 = this.anchor.getNode();
      e2.isEmpty() && Yi(e2.getParent()) && 0 === e2.getIndexWithinParent() && e2.collapseAtStart(this);
    }
  }
  deleteLine(e) {
    if (this.isCollapsed()) {
      "text" === this.anchor.type && this.modify("extend", e, "lineboundary");
      0 === (e ? this.focus : this.anchor).offset && this.modify("extend", e, "character");
    }
    this.removeText();
  }
  deleteWord(e) {
    if (this.isCollapsed()) {
      const t2 = this.anchor, n = t2.getNode();
      if (this.forwardDeletion(t2, n, e))
        return;
      this.modify("extend", e, "word");
    }
    this.removeText();
  }
  isBackward() {
    return this.focus.isBefore(this.anchor);
  }
  getStartEndPoints() {
    return [this.anchor, this.focus];
  }
};
function Zr(e) {
  return e instanceof Qr;
}
function Gr(e) {
  const t2 = e.offset;
  if ("text" === e.type)
    return t2;
  const n = e.getNode();
  return t2 === n.getChildrenSize() ? n.getTextContent().length : 0;
}
function ei(e) {
  const t2 = e.getStartEndPoints();
  if (null === t2)
    return [0, 0];
  const [n, r2] = t2;
  return "element" === n.type && "element" === r2.type && n.key === r2.key && n.offset === r2.offset ? [0, 0] : [Gr(n), Gr(r2)];
}
function ti(e, t2, n) {
  const r2 = e, i2 = r2.getTextContent().split(/(?=\s)/g), s2 = i2.length;
  let o2 = 0, l2 = 0;
  for (let e2 = 0; e2 < s2; e2++) {
    const r3 = e2 === s2 - 1;
    if (l2 = o2, o2 += i2[e2].length, t2 && o2 === n || o2 > n || r3) {
      i2.splice(e2, 1), r3 && (l2 = void 0);
      break;
    }
  }
  const c2 = i2.join("").trim();
  "" === c2 ? r2.remove() : (r2.setTextContent(c2), r2.select(l2, l2));
}
function ni(e, t2, n, r2) {
  let i2, s2 = t2;
  if (e.nodeType === ie) {
    let o2 = false;
    const l2 = e.childNodes, c2 = l2.length;
    s2 === c2 && (o2 = true, s2 = c2 - 1);
    let u2 = l2[s2], a2 = false;
    if (u2 === r2._blockCursorElement ? (u2 = l2[s2 + 1], a2 = true) : null !== r2._blockCursorElement && s2--, i2 = pt(u2), Br(i2))
      s2 = yt(i2, o2);
    else {
      let r3 = pt(e);
      if (null === r3)
        return null;
      if (qi(r3)) {
        let e2 = r3.getChildAtIndex(s2);
        if (qi(e2) && function(e3, t3, n2) {
          const r4 = e3.getParent();
          return null === n2 || null === r4 || !r4.canBeEmpty() || r4 !== n2.getNode();
        }(e2, 0, n)) {
          const t3 = o2 ? e2.getLastDescendant() : e2.getFirstDescendant();
          null === t3 ? (r3 = e2, s2 = 0) : (e2 = t3, r3 = qi(e2) ? e2 : e2.getParentOrThrow());
        }
        Br(e2) ? (i2 = e2, r3 = null, s2 = yt(e2, o2)) : e2 !== r3 && o2 && !a2 && s2++;
      } else {
        const n2 = r3.getIndexWithinParent();
        s2 = 0 === t2 && Hi(r3) && pt(e) === r3 ? n2 : n2 + 1, r3 = r3.getParentOrThrow();
      }
      if (qi(r3))
        return Vr(r3.__key, s2, "element");
    }
  } else
    i2 = pt(e);
  return Br(i2) ? Vr(i2.__key, s2, "text") : null;
}
function ri(e, t2, n) {
  const r2 = e.offset, i2 = e.getNode();
  if (0 === r2) {
    const r3 = i2.getPreviousSibling(), s2 = i2.getParent();
    if (t2) {
      if ((n || !t2) && null === r3 && qi(s2) && s2.isInline()) {
        const t3 = s2.getPreviousSibling();
        Br(t3) && (e.key = t3.__key, e.offset = t3.getTextContent().length);
      }
    } else
      qi(r3) && !n && r3.isInline() ? (e.key = r3.__key, e.offset = r3.getChildrenSize(), e.type = "element") : Br(r3) && (e.key = r3.__key, e.offset = r3.getTextContent().length);
  } else if (r2 === i2.getTextContent().length) {
    const r3 = i2.getNextSibling(), s2 = i2.getParent();
    if (t2 && qi(r3) && r3.isInline())
      e.key = r3.__key, e.offset = 0, e.type = "element";
    else if ((n || t2) && null === r3 && qi(s2) && s2.isInline() && !s2.canInsertTextAfter()) {
      const t3 = s2.getNextSibling();
      Br(t3) && (e.key = t3.__key, e.offset = 0);
    }
  }
}
function ii(e, t2, n) {
  if ("text" === e.type && "text" === t2.type) {
    const r2 = e.isBefore(t2), i2 = e.is(t2);
    ri(e, r2, i2), ri(t2, !r2, i2), i2 && (t2.key = e.key, t2.offset = e.offset, t2.type = e.type);
    const s2 = Oi();
    if (s2.isComposing() && s2._compositionKey !== e.key && Xr(n)) {
      const r3 = n.anchor, i3 = n.focus;
      qr(e, r3.key, r3.offset, r3.type), qr(t2, i3.key, i3.offset, i3.type);
    }
  }
}
function si(e, t2, n, r2, i2, s2) {
  if (null === e || null === n || !Xe(i2, e, n))
    return null;
  const o2 = ni(e, t2, Xr(s2) ? s2.anchor : null, i2);
  if (null === o2)
    return null;
  const l2 = ni(n, r2, Xr(s2) ? s2.focus : null, i2);
  if (null === l2)
    return null;
  if ("element" === o2.type && "element" === l2.type) {
    const t3 = pt(e), r3 = pt(n);
    if (Hi(t3) && Hi(r3))
      return null;
  }
  return ii(o2, l2, s2), [o2, l2];
}
function li(e, t2, n, r2, i2, s2) {
  const o2 = Ii(), l2 = new Yr(Vr(e, t2, i2), Vr(n, r2, s2), 0, "");
  return l2.dirty = true, o2._selection = l2, l2;
}
function ui() {
  return new Qr(/* @__PURE__ */ new Set());
}
function ai(e, t2, n, r2) {
  const i2 = n._window;
  if (null === i2)
    return null;
  const s2 = r2 || i2.event, o2 = s2 ? s2.type : void 0, l2 = "selectionchange" === o2, c2 = !Ae && (l2 || "beforeinput" === o2 || "compositionstart" === o2 || "compositionend" === o2 || "click" === o2 && s2 && 3 === s2.detail || "drop" === o2 || void 0 === o2);
  let u2, a2, f2, d2;
  if (Xr(e) && !c2)
    return e.clone();
  if (null === t2)
    return null;
  if (u2 = t2.anchorNode, a2 = t2.focusNode, f2 = t2.anchorOffset, d2 = t2.focusOffset, l2 && Xr(e) && !Xe(n, u2, a2))
    return e.clone();
  const h2 = si(u2, f2, a2, d2, n, e);
  if (null === h2)
    return null;
  const [g2, _2] = h2;
  return new Yr(g2, _2, Xr(e) ? e.format : 0, Xr(e) ? e.style : "");
}
function fi() {
  return Ii()._selection;
}
function di() {
  return Oi()._editorState._selection;
}
function hi(e, t2, n, r2 = 1) {
  const i2 = e.anchor, s2 = e.focus, o2 = i2.getNode(), l2 = s2.getNode();
  if (!t2.is(o2) && !t2.is(l2))
    return;
  const c2 = t2.__key;
  if (e.isCollapsed()) {
    const t3 = i2.offset;
    if (n <= t3 && r2 > 0 || n < t3 && r2 < 0) {
      const n2 = Math.max(0, t3 + r2);
      i2.set(c2, n2, "element"), s2.set(c2, n2, "element"), gi(e);
    }
  } else {
    const o3 = e.isBackward(), l3 = o3 ? s2 : i2, u2 = l3.getNode(), a2 = o3 ? i2 : s2, f2 = a2.getNode();
    if (t2.is(u2)) {
      const e2 = l3.offset;
      (n <= e2 && r2 > 0 || n < e2 && r2 < 0) && l3.set(c2, Math.max(0, e2 + r2), "element");
    }
    if (t2.is(f2)) {
      const e2 = a2.offset;
      (n <= e2 && r2 > 0 || n < e2 && r2 < 0) && a2.set(c2, Math.max(0, e2 + r2), "element");
    }
  }
  gi(e);
}
function gi(e) {
  const t2 = e.anchor, n = t2.offset, r2 = e.focus, i2 = r2.offset, s2 = t2.getNode(), o2 = r2.getNode();
  if (e.isCollapsed()) {
    if (!qi(s2))
      return;
    const e2 = s2.getChildrenSize(), i3 = n >= e2, o3 = i3 ? s2.getChildAtIndex(e2 - 1) : s2.getChildAtIndex(n);
    if (Br(o3)) {
      let e3 = 0;
      i3 && (e3 = o3.getTextContentSize()), t2.set(o3.__key, e3, "text"), r2.set(o3.__key, e3, "text");
    }
  } else {
    if (qi(s2)) {
      const e2 = s2.getChildrenSize(), r3 = n >= e2, i3 = r3 ? s2.getChildAtIndex(e2 - 1) : s2.getChildAtIndex(n);
      if (Br(i3)) {
        let e3 = 0;
        r3 && (e3 = i3.getTextContentSize()), t2.set(i3.__key, e3, "text");
      }
    }
    if (qi(o2)) {
      const e2 = o2.getChildrenSize(), t3 = i2 >= e2, n2 = t3 ? o2.getChildAtIndex(e2 - 1) : o2.getChildAtIndex(i2);
      if (Br(n2)) {
        let e3 = 0;
        t3 && (e3 = n2.getTextContentSize()), r2.set(n2.__key, e3, "text");
      }
    }
  }
}
function _i(e, t2, n, r2, i2) {
  let s2 = null, o2 = 0, l2 = null;
  null !== r2 ? (s2 = r2.__key, Br(r2) ? (o2 = r2.getTextContentSize(), l2 = "text") : qi(r2) && (o2 = r2.getChildrenSize(), l2 = "element")) : null !== i2 && (s2 = i2.__key, Br(i2) ? l2 = "text" : qi(i2) && (l2 = "element")), null !== s2 && null !== l2 ? e.set(s2, o2, l2) : (o2 = t2.getIndexWithinParent(), -1 === o2 && (o2 = n.getChildrenSize()), e.set(n.__key, o2, "element"));
}
function pi(e, t2, n, r2, i2) {
  "text" === e.type ? (e.key = n, t2 || (e.offset += i2)) : e.offset > r2.getIndexWithinParent() && (e.offset -= 1);
}
function yi(e, t2, n, r2, i2, s2, o2) {
  const l2 = r2.anchorNode, c2 = r2.focusNode, u2 = r2.anchorOffset, a2 = r2.focusOffset, f2 = document.activeElement;
  if (i2.has("collaboration") && f2 !== s2 || null !== f2 && Qe(f2))
    return;
  if (!Xr(t2))
    return void (null !== e && Xe(n, l2, c2) && r2.removeAllRanges());
  const d2 = t2.anchor, h2 = t2.focus, g2 = d2.key, _2 = h2.key, p2 = Kt(n, g2), y2 = Kt(n, _2), m2 = d2.offset, x2 = h2.offset, v2 = t2.format, T2 = t2.style, S2 = t2.isCollapsed();
  let k2 = p2, C2 = y2, b2 = false;
  if ("text" === d2.type) {
    k2 = et(p2);
    const e2 = d2.getNode();
    b2 = e2.getFormat() !== v2 || e2.getStyle() !== T2;
  } else
    Xr(e) && "text" === e.anchor.type && (b2 = true);
  var N2, w2, E, P, D;
  if (("text" === h2.type && (C2 = et(y2)), null !== k2 && null !== C2) && (S2 && (null === e || b2 || Xr(e) && (e.format !== v2 || e.style !== T2)) && (N2 = v2, w2 = T2, E = m2, P = g2, D = performance.now(), rr = [N2, w2, E, P, D]), u2 !== m2 || a2 !== x2 || l2 !== k2 || c2 !== C2 || "Range" === r2.type && S2 || (null !== f2 && s2.contains(f2) || s2.focus({ preventScroll: true }), "element" === d2.type))) {
    try {
      r2.setBaseAndExtent(k2, m2, C2, x2);
    } catch (e2) {
    }
    if (!i2.has("skip-scroll-into-view") && t2.isCollapsed() && null !== s2 && s2 === document.activeElement) {
      const e2 = t2 instanceof Yr && "element" === t2.anchor.type ? k2.childNodes[m2] || null : r2.rangeCount > 0 ? r2.getRangeAt(0) : null;
      if (null !== e2) {
        let t3;
        if (e2 instanceof Text) {
          const n2 = document.createRange();
          n2.selectNode(e2), t3 = n2.getBoundingClientRect();
        } else
          t3 = e2.getBoundingClientRect();
        !function(e3, t4, n2) {
          const r3 = n2.ownerDocument, i3 = r3.defaultView;
          if (null === i3)
            return;
          let { top: s3, bottom: o3 } = t4, l3 = 0, c3 = 0, u3 = n2;
          for (; null !== u3; ) {
            const t5 = u3 === r3.body;
            if (t5)
              l3 = 0, c3 = Ht(e3).innerHeight;
            else {
              const e4 = u3.getBoundingClientRect();
              l3 = e4.top, c3 = e4.bottom;
            }
            let n3 = 0;
            if (s3 < l3 ? n3 = -(l3 - s3) : o3 > c3 && (n3 = o3 - c3), 0 !== n3)
              if (t5)
                i3.scrollBy(0, n3);
              else {
                const e4 = u3.scrollTop;
                u3.scrollTop += n3;
                const t6 = u3.scrollTop - e4;
                s3 -= t6, o3 -= t6;
              }
            if (t5)
              break;
            u3 = Jt(u3);
          }
        }(n, t3, s2);
      }
    }
    Gn = true;
  }
}
function vi(e) {
  e.isCollapsed() || e.removeText();
  const t2 = e.anchor;
  let n = t2.getNode(), r2 = t2.offset;
  for (; !ln(n); )
    [n, r2] = Ti(n, r2);
  return r2;
}
function Ti(e, t2) {
  const n = e.getParent();
  if (!n) {
    const e2 = rs();
    return ht().append(e2), e2.select(), [ht(), 0];
  }
  if (Br(e)) {
    const r3 = e.splitText(t2);
    if (0 === r3.length)
      return [n, e.getIndexWithinParent()];
    const i2 = 0 === t2 ? 0 : 1;
    return [n, r3[0].getIndexWithinParent() + i2];
  }
  if (!qi(e) || 0 === t2)
    return [n, e.getIndexWithinParent()];
  const r2 = e.getChildAtIndex(t2);
  if (r2) {
    const n2 = new Yr(Vr(e.__key, t2, "element"), Vr(e.__key, t2, "element"), 0, ""), i2 = e.insertNewAfter(n2);
    i2 && i2.append(r2, ...r2.getNextSiblings());
  }
  return [n, e.getIndexWithinParent() + 1];
}
var Si = null;
var ki = null;
var Ci = false;
var bi = false;
var Ni = 0;
var wi = { characterData: true, childList: true, subtree: true };
function Ei() {
  return Ci || null !== Si && Si._readOnly;
}
function Pi() {
  Ci && H(13);
}
function Di() {
  Ni > 99 && H(14);
}
function Ii() {
  return null === Si && H(15), Si;
}
function Oi() {
  return null === ki && H(16), ki;
}
function Li(e, t2, n) {
  const r2 = t2.__type, i2 = function(e2, t3) {
    const n2 = e2._nodes.get(t3);
    return void 0 === n2 && H(30, t3), n2;
  }(e, r2);
  let s2 = n.get(r2);
  void 0 === s2 && (s2 = Array.from(i2.transforms), n.set(r2, s2));
  const o2 = s2.length;
  for (let e2 = 0; e2 < o2 && (s2[e2](t2), t2.isAttached()); e2++)
    ;
}
function Fi(e, t2) {
  return void 0 !== e && e.__key !== t2 && e.isAttached();
}
function zi(e, t2) {
  const n = Si, r2 = Ci, i2 = ki;
  Si = e, Ci = true, ki = null;
  try {
    return t2();
  } finally {
    Si = n, Ci = r2, ki = i2;
  }
}
function Bi(e, n) {
  const r2 = e._pendingEditorState, i2 = e._rootElement, s2 = e._headless || null === i2;
  if (null === r2)
    return;
  const o2 = e._editorState, l2 = o2._selection, c2 = r2._selection, u2 = e._dirtyType !== oe, a2 = Si, f2 = Ci, d2 = ki, h2 = e._updating, g2 = e._observer;
  let _2 = null;
  if (e._pendingEditorState = null, e._editorState = r2, !s2 && u2 && null !== g2) {
    ki = e, Si = r2, Ci = false, e._updating = true;
    try {
      const t2 = e._dirtyType, n2 = e._dirtyElements, i3 = e._dirtyLeaves;
      g2.disconnect(), _2 = Un(o2, r2, e, t2, n2, i3);
    } catch (t2) {
      if (t2 instanceof Error && e._onError(t2), bi)
        throw t2;
      return as(e, null, i2, r2), Ke(e), e._dirtyType = ce, bi = true, Bi(e, o2), void (bi = false);
    } finally {
      g2.observe(i2, wi), e._updating = h2, Si = a2, Ci = f2, ki = d2;
    }
  }
  r2._readOnly || (r2._readOnly = true);
  const p2 = e._dirtyLeaves, y2 = e._dirtyElements, m2 = e._normalizedNodes, x2 = e._updateTags, v2 = e._deferred;
  u2 && (e._dirtyType = oe, e._cloneNotNeeded.clear(), e._dirtyLeaves = /* @__PURE__ */ new Set(), e._dirtyElements = /* @__PURE__ */ new Map(), e._normalizedNodes = /* @__PURE__ */ new Set(), e._updateTags = /* @__PURE__ */ new Set()), function(e2, t2) {
    const n2 = e2._decorators;
    let r3 = e2._pendingDecorators || n2;
    const i3 = t2._nodeMap;
    let s3;
    for (s3 in r3)
      i3.has(s3) || (r3 === n2 && (r3 = ft(e2)), delete r3[s3]);
  }(e, r2);
  const T2 = s2 ? null : nn(e._window);
  if (e._editable && null !== T2 && (u2 || null === c2 || c2.dirty)) {
    ki = e, Si = r2;
    try {
      if (null !== g2 && g2.disconnect(), u2 || null === c2 || c2.dirty) {
        const t2 = e._blockCursorElement;
        null !== t2 && en(t2, e, i2), yi(l2, c2, e, T2, x2, i2);
      }
      tn(e, i2, c2), null !== g2 && g2.observe(i2, wi);
    } finally {
      ki = d2, Si = a2;
    }
  }
  null !== _2 && function(e2, t2, n2, r3, i3) {
    const s3 = Array.from(e2._listeners.mutation), o3 = s3.length;
    for (let e3 = 0; e3 < o3; e3++) {
      const [o4, l3] = s3[e3], c3 = t2.get(l3);
      void 0 !== c3 && o4(c3, { dirtyLeaves: r3, prevEditorState: i3, updateTags: n2 });
    }
  }(e, _2, x2, p2, o2), Xr(c2) || null === c2 || null !== l2 && l2.is(c2) || e.dispatchCommand(t, void 0);
  const S2 = e._pendingDecorators;
  null !== S2 && (e._decorators = S2, e._pendingDecorators = null, Ri("decorator", e, true, S2)), function(e2, t2, n2) {
    const r3 = dt(t2), i3 = dt(n2);
    r3 !== i3 && Ri("textcontent", e2, true, i3);
  }(e, n || o2, r2), Ri("update", e, true, { dirtyElements: y2, dirtyLeaves: p2, editorState: r2, normalizedNodes: m2, prevEditorState: n || o2, tags: x2 }), function(e2, t2) {
    if (e2._deferred = [], 0 !== t2.length) {
      const n2 = e2._updating;
      e2._updating = true;
      try {
        for (let e3 = 0; e3 < t2.length; e3++)
          t2[e3]();
      } finally {
        e2._updating = n2;
      }
    }
  }(e, v2), function(e2) {
    const t2 = e2._updates;
    if (0 !== t2.length) {
      const n2 = t2.shift();
      if (n2) {
        const [t3, r3] = n2;
        Ui(e2, t3, r3);
      }
    }
  }(e);
}
function Ri(e, t2, n, ...r2) {
  const i2 = t2._updating;
  t2._updating = n;
  try {
    const n2 = Array.from(t2._listeners[e]);
    for (let e2 = 0; e2 < n2.length; e2++)
      n2[e2].apply(null, r2);
  } finally {
    t2._updating = i2;
  }
}
function Ki(e, t2, n) {
  if (false === e._updating || ki !== e) {
    let r3 = false;
    return e.update(() => {
      r3 = Ki(e, t2, n);
    }), r3;
  }
  const r2 = xt(e);
  for (let i2 = 4; i2 >= 0; i2--)
    for (let s2 = 0; s2 < r2.length; s2++) {
      const o2 = r2[s2]._commands.get(t2);
      if (void 0 !== o2) {
        const t3 = o2[i2];
        if (void 0 !== t3) {
          const r3 = Array.from(t3), i3 = r3.length;
          for (let t4 = 0; t4 < i3; t4++)
            if (true === r3[t4](n, e))
              return true;
        }
      }
    }
  return false;
}
function Ji(e, t2) {
  const n = e._updates;
  let r2 = t2 || false;
  for (; 0 !== n.length; ) {
    const t3 = n.shift();
    if (t3) {
      const [n2, i2] = t3;
      let s2, o2;
      void 0 !== i2 && (s2 = i2.onUpdate, o2 = i2.tag, i2.skipTransforms && (r2 = true), s2 && e._deferred.push(s2), o2 && e._updateTags.add(o2)), n2();
    }
  }
  return r2;
}
function Ui(e, t2, n) {
  const r2 = e._updateTags;
  let i2, s2, o2 = false, l2 = false;
  void 0 !== n && (i2 = n.onUpdate, s2 = n.tag, null != s2 && r2.add(s2), o2 = n.skipTransforms || false, l2 = n.discrete || false), i2 && e._deferred.push(i2);
  const c2 = e._editorState;
  let u2 = e._pendingEditorState, a2 = false;
  (null === u2 || u2._readOnly) && (u2 = e._pendingEditorState = new es(new Map((u2 || c2)._nodeMap)), a2 = true), u2._flushSync = l2;
  const f2 = Si, d2 = Ci, h2 = ki, g2 = e._updating;
  Si = u2, Ci = false, e._updating = true, ki = e;
  try {
    a2 && (e._headless ? null !== c2._selection && (u2._selection = c2._selection.clone()) : u2._selection = function(e2) {
      const t3 = e2.getEditorState()._selection, n3 = nn(e2._window);
      return Xr(t3) || null == t3 ? ai(t3, n3, e2, null) : t3.clone();
    }(e));
    const n2 = e._compositionKey;
    t2(), o2 = Ji(e, o2), function(e2, t3) {
      const n3 = t3.getEditorState()._selection, r4 = e2._selection;
      if (Xr(r4)) {
        const e3 = r4.anchor, t4 = r4.focus;
        let i3;
        if ("text" === e3.type && (i3 = e3.getNode(), i3.selectionTransform(n3, r4)), "text" === t4.type) {
          const e4 = t4.getNode();
          i3 !== e4 && e4.selectionTransform(n3, r4);
        }
      }
    }(u2, e), e._dirtyType !== oe && (o2 ? function(e2, t3) {
      const n3 = t3._dirtyLeaves, r4 = e2._nodeMap;
      for (const e3 of n3) {
        const t4 = r4.get(e3);
        Br(t4) && t4.isAttached() && t4.isSimpleText() && !t4.isUnmergeable() && Ve(t4);
      }
    }(u2, e) : function(e2, t3) {
      const n3 = t3._dirtyLeaves, r4 = t3._dirtyElements, i3 = e2._nodeMap, s3 = lt(), o3 = /* @__PURE__ */ new Map();
      let l3 = n3, c3 = l3.size, u3 = r4, a3 = u3.size;
      for (; c3 > 0 || a3 > 0; ) {
        if (c3 > 0) {
          t3._dirtyLeaves = /* @__PURE__ */ new Set();
          for (const e3 of l3) {
            const r5 = i3.get(e3);
            Br(r5) && r5.isAttached() && r5.isSimpleText() && !r5.isUnmergeable() && Ve(r5), void 0 !== r5 && Fi(r5, s3) && Li(t3, r5, o3), n3.add(e3);
          }
          if (l3 = t3._dirtyLeaves, c3 = l3.size, c3 > 0) {
            Ni++;
            continue;
          }
        }
        t3._dirtyLeaves = /* @__PURE__ */ new Set(), t3._dirtyElements = /* @__PURE__ */ new Map();
        for (const e3 of u3) {
          const n4 = e3[0], l4 = e3[1];
          if ("root" !== n4 && !l4)
            continue;
          const c4 = i3.get(n4);
          void 0 !== c4 && Fi(c4, s3) && Li(t3, c4, o3), r4.set(n4, l4);
        }
        l3 = t3._dirtyLeaves, c3 = l3.size, u3 = t3._dirtyElements, a3 = u3.size, Ni++;
      }
      t3._dirtyLeaves = n3, t3._dirtyElements = r4;
    }(u2, e), Ji(e), function(e2, t3, n3, r4) {
      const i3 = e2._nodeMap, s3 = t3._nodeMap, o3 = [];
      for (const [e3] of r4) {
        const t4 = s3.get(e3);
        void 0 !== t4 && (t4.isAttached() || (qi(t4) && an(t4, e3, i3, s3, o3, r4), i3.has(e3) || r4.delete(e3), o3.push(e3)));
      }
      for (const e3 of o3)
        s3.delete(e3);
      for (const e3 of n3) {
        const t4 = s3.get(e3);
        void 0 === t4 || t4.isAttached() || (i3.has(e3) || n3.delete(e3), s3.delete(e3));
      }
    }(c2, u2, e._dirtyLeaves, e._dirtyElements));
    n2 !== e._compositionKey && (u2._flushSync = true);
    const r3 = u2._selection;
    if (Xr(r3)) {
      const e2 = u2._nodeMap, t3 = r3.anchor.key, n3 = r3.focus.key;
      void 0 !== e2.get(t3) && void 0 !== e2.get(n3) || H(19);
    } else
      Zr(r3) && 0 === r3._nodes.size && (u2._selection = null);
  } catch (t3) {
    return t3 instanceof Error && e._onError(t3), e._pendingEditorState = c2, e._dirtyType = ce, e._cloneNotNeeded.clear(), e._dirtyLeaves = /* @__PURE__ */ new Set(), e._dirtyElements.clear(), void Bi(e);
  } finally {
    Si = f2, Ci = d2, ki = h2, e._updating = g2, Ni = 0;
  }
  const _2 = e._dirtyType !== oe || function(e2, t3) {
    const n2 = t3.getEditorState()._selection, r3 = e2._selection;
    if (null !== r3) {
      if (r3.dirty || !r3.is(n2))
        return true;
    } else if (null !== n2)
      return true;
    return false;
  }(u2, e);
  _2 ? u2._flushSync ? (u2._flushSync = false, Bi(e)) : a2 && qe(() => {
    Bi(e);
  }) : (u2._flushSync = false, a2 && (r2.clear(), e._deferred = [], e._pendingEditorState = null));
}
function Vi(e, t2, n) {
  e._updating ? e._updates.push([t2, n]) : Ui(e, t2, n);
}
var $i = class extends pr {
  constructor(e) {
    super(e);
  }
  decorate(e, t2) {
    H(47);
  }
  isIsolated() {
    return false;
  }
  isInline() {
    return true;
  }
  isKeyboardSelectable() {
    return true;
  }
};
function Hi(e) {
  return e instanceof $i;
}
var ji = class extends pr {
  constructor(e) {
    super(e), this.__first = null, this.__last = null, this.__size = 0, this.__format = 0, this.__indent = 0, this.__dir = null;
  }
  getFormat() {
    return this.getLatest().__format;
  }
  getFormatType() {
    const e = this.getFormat();
    return Ee[e] || "";
  }
  getIndent() {
    return this.getLatest().__indent;
  }
  getChildren() {
    const e = [];
    let t2 = this.getFirstChild();
    for (; null !== t2; )
      e.push(t2), t2 = t2.getNextSibling();
    return e;
  }
  getChildrenKeys() {
    const e = [];
    let t2 = this.getFirstChild();
    for (; null !== t2; )
      e.push(t2.__key), t2 = t2.getNextSibling();
    return e;
  }
  getChildrenSize() {
    return this.getLatest().__size;
  }
  isEmpty() {
    return 0 === this.getChildrenSize();
  }
  isDirty() {
    const e = Oi()._dirtyElements;
    return null !== e && e.has(this.__key);
  }
  isLastChild() {
    const e = this.getLatest(), t2 = this.getParentOrThrow().getLastChild();
    return null !== t2 && t2.is(e);
  }
  getAllTextNodes() {
    const e = [];
    let t2 = this.getFirstChild();
    for (; null !== t2; ) {
      if (Br(t2) && e.push(t2), qi(t2)) {
        const n = t2.getAllTextNodes();
        e.push(...n);
      }
      t2 = t2.getNextSibling();
    }
    return e;
  }
  getFirstDescendant() {
    let e = this.getFirstChild();
    for (; qi(e); ) {
      const t2 = e.getFirstChild();
      if (null === t2)
        break;
      e = t2;
    }
    return e;
  }
  getLastDescendant() {
    let e = this.getLastChild();
    for (; qi(e); ) {
      const t2 = e.getLastChild();
      if (null === t2)
        break;
      e = t2;
    }
    return e;
  }
  getDescendantByIndex(e) {
    const t2 = this.getChildren(), n = t2.length;
    if (e >= n) {
      const e2 = t2[n - 1];
      return qi(e2) && e2.getLastDescendant() || e2 || null;
    }
    const r2 = t2[e];
    return qi(r2) && r2.getFirstDescendant() || r2 || null;
  }
  getFirstChild() {
    const e = this.getLatest().__first;
    return null === e ? null : ct(e);
  }
  getFirstChildOrThrow() {
    const e = this.getFirstChild();
    return null === e && H(45, this.__key), e;
  }
  getLastChild() {
    const e = this.getLatest().__last;
    return null === e ? null : ct(e);
  }
  getLastChildOrThrow() {
    const e = this.getLastChild();
    return null === e && H(96, this.__key), e;
  }
  getChildAtIndex(e) {
    const t2 = this.getChildrenSize();
    let n, r2;
    if (e < t2 / 2) {
      for (n = this.getFirstChild(), r2 = 0; null !== n && r2 <= e; ) {
        if (r2 === e)
          return n;
        n = n.getNextSibling(), r2++;
      }
      return null;
    }
    for (n = this.getLastChild(), r2 = t2 - 1; null !== n && r2 >= e; ) {
      if (r2 === e)
        return n;
      n = n.getPreviousSibling(), r2--;
    }
    return null;
  }
  getTextContent() {
    let e = "";
    const t2 = this.getChildren(), n = t2.length;
    for (let r2 = 0; r2 < n; r2++) {
      const i2 = t2[r2];
      e += i2.getTextContent(), qi(i2) && r2 !== n - 1 && !i2.isInline() && (e += xe);
    }
    return e;
  }
  getTextContentSize() {
    let e = 0;
    const t2 = this.getChildren(), n = t2.length;
    for (let r2 = 0; r2 < n; r2++) {
      const i2 = t2[r2];
      e += i2.getTextContentSize(), qi(i2) && r2 !== n - 1 && !i2.isInline() && (e += xe.length);
    }
    return e;
  }
  getDirection() {
    return this.getLatest().__dir;
  }
  hasFormat(e) {
    if ("" !== e) {
      const t2 = we[e];
      return 0 != (this.getFormat() & t2);
    }
    return false;
  }
  select(e, t2) {
    Pi();
    const n = fi();
    let r2 = e, i2 = t2;
    const s2 = this.getChildrenSize();
    if (!this.canBeEmpty()) {
      if (0 === e && 0 === t2) {
        const e2 = this.getFirstChild();
        if (Br(e2) || qi(e2))
          return e2.select(0, 0);
      } else if (!(void 0 !== e && e !== s2 || void 0 !== t2 && t2 !== s2)) {
        const e2 = this.getLastChild();
        if (Br(e2) || qi(e2))
          return e2.select();
      }
    }
    void 0 === r2 && (r2 = s2), void 0 === i2 && (i2 = s2);
    const o2 = this.__key;
    return Xr(n) ? (n.anchor.set(o2, r2, "element"), n.focus.set(o2, i2, "element"), n.dirty = true, n) : li(o2, r2, o2, i2, "element", "element");
  }
  selectStart() {
    const e = this.getFirstDescendant();
    return e ? e.selectStart() : this.select();
  }
  selectEnd() {
    const e = this.getLastDescendant();
    return e ? e.selectEnd() : this.select();
  }
  clear() {
    const e = this.getWritable();
    return this.getChildren().forEach((e2) => e2.remove()), e;
  }
  append(...e) {
    return this.splice(this.getChildrenSize(), 0, e);
  }
  setDirection(e) {
    const t2 = this.getWritable();
    return t2.__dir = e, t2;
  }
  setFormat(e) {
    return this.getWritable().__format = "" !== e ? we[e] : 0, this;
  }
  setIndent(e) {
    return this.getWritable().__indent = e, this;
  }
  splice(e, t2, n) {
    const r2 = n.length, i2 = this.getChildrenSize(), s2 = this.getWritable(), o2 = s2.__key, l2 = [], c2 = [], u2 = this.getChildAtIndex(e + t2);
    let a2 = null, f2 = i2 - t2 + r2;
    if (0 !== e)
      if (e === i2)
        a2 = this.getLastChild();
      else {
        const t3 = this.getChildAtIndex(e);
        null !== t3 && (a2 = t3.getPreviousSibling());
      }
    if (t2 > 0) {
      let e2 = null === a2 ? this.getFirstChild() : a2.getNextSibling();
      for (let n2 = 0; n2 < t2; n2++) {
        null === e2 && H(100);
        const t3 = e2.getNextSibling(), n3 = e2.__key;
        it(e2.getWritable()), c2.push(n3), e2 = t3;
      }
    }
    let d2 = a2;
    for (let e2 = 0; e2 < r2; e2++) {
      const t3 = n[e2];
      null !== d2 && t3.is(d2) && (a2 = d2 = d2.getPreviousSibling());
      const r3 = t3.getWritable();
      r3.__parent === o2 && f2--, it(r3);
      const i3 = t3.__key;
      if (null === d2)
        s2.__first = i3, r3.__prev = null;
      else {
        const e3 = d2.getWritable();
        e3.__next = i3, r3.__prev = e3.__key;
      }
      t3.__key === o2 && H(76), r3.__parent = o2, l2.push(i3), d2 = t3;
    }
    if (e + t2 === i2) {
      if (null !== d2) {
        d2.getWritable().__next = null, s2.__last = d2.__key;
      }
    } else if (null !== u2) {
      const e2 = u2.getWritable();
      if (null !== d2) {
        const t3 = d2.getWritable();
        e2.__prev = d2.__key, t3.__next = u2.__key;
      } else
        e2.__prev = null;
    }
    if (s2.__size = f2, c2.length) {
      const e2 = fi();
      if (Xr(e2)) {
        const t3 = new Set(c2), n2 = new Set(l2), { anchor: r3, focus: i3 } = e2;
        Qi(r3, t3, n2) && _i(r3, r3.getNode(), this, a2, u2), Qi(i3, t3, n2) && _i(i3, i3.getNode(), this, a2, u2), 0 !== f2 || this.canBeEmpty() || Qt(this) || this.remove();
      }
    }
    return s2;
  }
  exportJSON() {
    return { children: [], direction: this.getDirection(), format: this.getFormatType(), indent: this.getIndent(), type: "element", version: 1 };
  }
  insertNewAfter(e, t2) {
    return null;
  }
  canIndent() {
    return true;
  }
  collapseAtStart(e) {
    return false;
  }
  excludeFromCopy(e) {
    return false;
  }
  canReplaceWith(e) {
    return true;
  }
  canInsertAfter(e) {
    return true;
  }
  canBeEmpty() {
    return true;
  }
  canInsertTextBefore() {
    return true;
  }
  canInsertTextAfter() {
    return true;
  }
  isInline() {
    return false;
  }
  isShadowRoot() {
    return false;
  }
  canMergeWith(e) {
    return false;
  }
  extractWithChild(e, t2, n) {
    return false;
  }
};
function qi(e) {
  return e instanceof ji;
}
function Qi(e, t2, n) {
  let r2 = e.getNode();
  for (; r2; ) {
    const e2 = r2.__key;
    if (t2.has(e2) && !n.has(e2))
      return true;
    r2 = r2.getParent();
  }
  return false;
}
var Xi = class _Xi extends ji {
  static getType() {
    return "root";
  }
  static clone() {
    return new _Xi();
  }
  constructor() {
    super("root"), this.__cachedText = null;
  }
  getTopLevelElementOrThrow() {
    H(51);
  }
  getTextContent() {
    const e = this.__cachedText;
    return !Ei() && Oi()._dirtyType !== oe || null === e ? super.getTextContent() : e;
  }
  remove() {
    H(52);
  }
  replace(e) {
    H(53);
  }
  insertBefore(e) {
    H(54);
  }
  insertAfter(e) {
    H(55);
  }
  updateDOM(e, t2) {
    return false;
  }
  append(...e) {
    for (let t2 = 0; t2 < e.length; t2++) {
      const n = e[t2];
      qi(n) || Hi(n) || H(56);
    }
    return super.append(...e);
  }
  static importJSON(e) {
    const t2 = ht();
    return t2.setFormat(e.format), t2.setIndent(e.indent), t2.setDirection(e.direction), t2;
  }
  exportJSON() {
    return { children: [], direction: this.getDirection(), format: this.getFormatType(), indent: this.getIndent(), type: "root", version: 1 };
  }
  collapseAtStart() {
    return true;
  }
};
function Yi(e) {
  return e instanceof Xi;
}
function Zi() {
  return new es(/* @__PURE__ */ new Map([["root", new Xi()]]));
}
function Gi(e) {
  const t2 = e.exportJSON(), n = e.constructor;
  if (t2.type !== n.getType() && H(130, n.name), qi(e)) {
    const r2 = t2.children;
    Array.isArray(r2) || H(59, n.name);
    const i2 = e.getChildren();
    for (let e2 = 0; e2 < i2.length; e2++) {
      const t3 = Gi(i2[e2]);
      r2.push(t3);
    }
  }
  return t2;
}
var es = class _es {
  constructor(e, t2) {
    this._nodeMap = e, this._selection = t2 || null, this._flushSync = false, this._readOnly = false;
  }
  isEmpty() {
    return 1 === this._nodeMap.size && null === this._selection;
  }
  read(e) {
    return zi(this, e);
  }
  clone(e) {
    const t2 = new _es(this._nodeMap, void 0 === e ? this._selection : e);
    return t2._readOnly = true, t2;
  }
  toJSON() {
    return zi(this, () => ({ root: Gi(ht()) }));
  }
};
var ts = class _ts extends ji {
  static getType() {
    return "paragraph";
  }
  static clone(e) {
    return new _ts(e.__key);
  }
  createDOM(e) {
    const t2 = document.createElement("p"), n = At(e.theme, "paragraph");
    if (void 0 !== n) {
      t2.classList.add(...n);
    }
    return t2;
  }
  updateDOM(e, t2, n) {
    return false;
  }
  static importDOM() {
    return { p: (e) => ({ conversion: ns, priority: 0 }) };
  }
  exportDOM(e) {
    const { element: t2 } = super.exportDOM(e);
    if (t2 && on(t2)) {
      this.isEmpty() && t2.append(document.createElement("br"));
      const e2 = this.getFormatType();
      t2.style.textAlign = e2;
      const n = this.getDirection();
      n && (t2.dir = n);
      const r2 = this.getIndent();
      r2 > 0 && (t2.style.textIndent = 20 * r2 + "px");
    }
    return { element: t2 };
  }
  static importJSON(e) {
    const t2 = rs();
    return t2.setFormat(e.format), t2.setIndent(e.indent), t2.setDirection(e.direction), t2;
  }
  exportJSON() {
    return { ...super.exportJSON(), type: "paragraph", version: 1 };
  }
  insertNewAfter(e, t2) {
    const n = rs(), r2 = this.getDirection();
    return n.setDirection(r2), this.insertAfter(n, t2), n;
  }
  collapseAtStart() {
    const e = this.getChildren();
    if (0 === e.length || Br(e[0]) && "" === e[0].getTextContent().trim()) {
      if (null !== this.getNextSibling())
        return this.selectNext(), this.remove(), true;
      if (null !== this.getPreviousSibling())
        return this.selectPrevious(), this.remove(), true;
    }
    return false;
  }
};
function ns(e) {
  const t2 = rs();
  if (e.style) {
    t2.setFormat(e.style.textAlign);
    const n = parseInt(e.style.textIndent, 10) / 20;
    n > 0 && t2.setIndent(n);
  }
  return { node: t2 };
}
function rs() {
  return Yt(new ts());
}
function as(e, t2, n, r2) {
  const i2 = e._keyToDOMMap;
  i2.clear(), e._editorState = Zi(), e._pendingEditorState = r2, e._compositionKey = null, e._dirtyType = oe, e._cloneNotNeeded.clear(), e._dirtyLeaves = /* @__PURE__ */ new Set(), e._dirtyElements.clear(), e._normalizedNodes = /* @__PURE__ */ new Set(), e._updateTags = /* @__PURE__ */ new Set(), e._updates = [], e._blockCursorElement = null;
  const s2 = e._observer;
  null !== s2 && (s2.disconnect(), e._observer = null), null !== t2 && (t2.textContent = ""), null !== n && (n.textContent = "", i2.set("root", n));
}

// ../node_modules/lexical/Lexical.esm.js
var mod = true ? Lexical_dev_esm_exports : Lexical_prod_esm_exports;
var $addUpdateTag2 = mod.$addUpdateTag;
var $applyNodeReplacement2 = mod.$applyNodeReplacement;
var $copyNode2 = mod.$copyNode;
var $createLineBreakNode2 = mod.$createLineBreakNode;
var $createNodeSelection2 = mod.$createNodeSelection;
var $createParagraphNode2 = mod.$createParagraphNode;
var $createPoint2 = mod.$createPoint;
var $createRangeSelection2 = mod.$createRangeSelection;
var $createTabNode2 = mod.$createTabNode;
var $createTextNode2 = mod.$createTextNode;
var $getAdjacentNode2 = mod.$getAdjacentNode;
var $getCharacterOffsets2 = mod.$getCharacterOffsets;
var $getEditor2 = mod.$getEditor;
var $getNearestNodeFromDOMNode2 = mod.$getNearestNodeFromDOMNode;
var $getNearestRootOrShadowRoot2 = mod.$getNearestRootOrShadowRoot;
var $getNodeByKey2 = mod.$getNodeByKey;
var $getPreviousSelection2 = mod.$getPreviousSelection;
var $getRoot2 = mod.$getRoot;
var $getSelection2 = mod.$getSelection;
var $getTextContent2 = mod.$getTextContent;
var $hasAncestor2 = mod.$hasAncestor;
var $hasUpdateTag2 = mod.$hasUpdateTag;
var $insertNodes2 = mod.$insertNodes;
var $isBlockElementNode2 = mod.$isBlockElementNode;
var $isDecoratorNode2 = mod.$isDecoratorNode;
var $isElementNode2 = mod.$isElementNode;
var $isInlineElementOrDecoratorNode2 = mod.$isInlineElementOrDecoratorNode;
var $isLeafNode2 = mod.$isLeafNode;
var $isLineBreakNode2 = mod.$isLineBreakNode;
var $isNodeSelection2 = mod.$isNodeSelection;
var $isParagraphNode2 = mod.$isParagraphNode;
var $isRangeSelection2 = mod.$isRangeSelection;
var $isRootNode2 = mod.$isRootNode;
var $isRootOrShadowRoot2 = mod.$isRootOrShadowRoot;
var $isTabNode2 = mod.$isTabNode;
var $isTextNode2 = mod.$isTextNode;
var $nodesOfType2 = mod.$nodesOfType;
var $normalizeSelection__EXPERIMENTAL = mod.$normalizeSelection__EXPERIMENTAL;
var $parseSerializedNode2 = mod.$parseSerializedNode;
var $selectAll2 = mod.$selectAll;
var $setCompositionKey2 = mod.$setCompositionKey;
var $setSelection2 = mod.$setSelection;
var $splitNode2 = mod.$splitNode;
var BLUR_COMMAND2 = mod.BLUR_COMMAND;
var CAN_REDO_COMMAND2 = mod.CAN_REDO_COMMAND;
var CAN_UNDO_COMMAND2 = mod.CAN_UNDO_COMMAND;
var CLEAR_EDITOR_COMMAND2 = mod.CLEAR_EDITOR_COMMAND;
var CLEAR_HISTORY_COMMAND2 = mod.CLEAR_HISTORY_COMMAND;
var CLICK_COMMAND2 = mod.CLICK_COMMAND;
var COMMAND_PRIORITY_CRITICAL2 = mod.COMMAND_PRIORITY_CRITICAL;
var COMMAND_PRIORITY_EDITOR2 = mod.COMMAND_PRIORITY_EDITOR;
var COMMAND_PRIORITY_HIGH2 = mod.COMMAND_PRIORITY_HIGH;
var COMMAND_PRIORITY_LOW2 = mod.COMMAND_PRIORITY_LOW;
var COMMAND_PRIORITY_NORMAL2 = mod.COMMAND_PRIORITY_NORMAL;
var CONTROLLED_TEXT_INSERTION_COMMAND2 = mod.CONTROLLED_TEXT_INSERTION_COMMAND;
var COPY_COMMAND2 = mod.COPY_COMMAND;
var CUT_COMMAND2 = mod.CUT_COMMAND;
var DELETE_CHARACTER_COMMAND2 = mod.DELETE_CHARACTER_COMMAND;
var DELETE_LINE_COMMAND2 = mod.DELETE_LINE_COMMAND;
var DELETE_WORD_COMMAND2 = mod.DELETE_WORD_COMMAND;
var DRAGEND_COMMAND2 = mod.DRAGEND_COMMAND;
var DRAGOVER_COMMAND2 = mod.DRAGOVER_COMMAND;
var DRAGSTART_COMMAND2 = mod.DRAGSTART_COMMAND;
var DROP_COMMAND2 = mod.DROP_COMMAND;
var DecoratorNode2 = mod.DecoratorNode;
var ElementNode2 = mod.ElementNode;
var FOCUS_COMMAND2 = mod.FOCUS_COMMAND;
var FORMAT_ELEMENT_COMMAND2 = mod.FORMAT_ELEMENT_COMMAND;
var FORMAT_TEXT_COMMAND2 = mod.FORMAT_TEXT_COMMAND;
var INDENT_CONTENT_COMMAND2 = mod.INDENT_CONTENT_COMMAND;
var INSERT_LINE_BREAK_COMMAND2 = mod.INSERT_LINE_BREAK_COMMAND;
var INSERT_PARAGRAPH_COMMAND2 = mod.INSERT_PARAGRAPH_COMMAND;
var INSERT_TAB_COMMAND2 = mod.INSERT_TAB_COMMAND;
var KEY_ARROW_DOWN_COMMAND2 = mod.KEY_ARROW_DOWN_COMMAND;
var KEY_ARROW_LEFT_COMMAND2 = mod.KEY_ARROW_LEFT_COMMAND;
var KEY_ARROW_RIGHT_COMMAND2 = mod.KEY_ARROW_RIGHT_COMMAND;
var KEY_ARROW_UP_COMMAND2 = mod.KEY_ARROW_UP_COMMAND;
var KEY_BACKSPACE_COMMAND2 = mod.KEY_BACKSPACE_COMMAND;
var KEY_DELETE_COMMAND2 = mod.KEY_DELETE_COMMAND;
var KEY_DOWN_COMMAND2 = mod.KEY_DOWN_COMMAND;
var KEY_ENTER_COMMAND2 = mod.KEY_ENTER_COMMAND;
var KEY_ESCAPE_COMMAND2 = mod.KEY_ESCAPE_COMMAND;
var KEY_MODIFIER_COMMAND2 = mod.KEY_MODIFIER_COMMAND;
var KEY_SPACE_COMMAND2 = mod.KEY_SPACE_COMMAND;
var KEY_TAB_COMMAND2 = mod.KEY_TAB_COMMAND;
var LineBreakNode2 = mod.LineBreakNode;
var MOVE_TO_END2 = mod.MOVE_TO_END;
var MOVE_TO_START2 = mod.MOVE_TO_START;
var OUTDENT_CONTENT_COMMAND2 = mod.OUTDENT_CONTENT_COMMAND;
var PASTE_COMMAND2 = mod.PASTE_COMMAND;
var ParagraphNode2 = mod.ParagraphNode;
var REDO_COMMAND2 = mod.REDO_COMMAND;
var REMOVE_TEXT_COMMAND2 = mod.REMOVE_TEXT_COMMAND;
var RootNode2 = mod.RootNode;
var SELECTION_CHANGE_COMMAND2 = mod.SELECTION_CHANGE_COMMAND;
var SELECTION_INSERT_CLIPBOARD_NODES_COMMAND2 = mod.SELECTION_INSERT_CLIPBOARD_NODES_COMMAND;
var SELECT_ALL_COMMAND2 = mod.SELECT_ALL_COMMAND;
var TabNode2 = mod.TabNode;
var TextNode2 = mod.TextNode;
var UNDO_COMMAND2 = mod.UNDO_COMMAND;
var createCommand2 = mod.createCommand;
var createEditor2 = mod.createEditor;
var getNearestEditorFromDOMNode2 = mod.getNearestEditorFromDOMNode;
var isCurrentlyReadOnlyMode2 = mod.isCurrentlyReadOnlyMode;
var isHTMLAnchorElement2 = mod.isHTMLAnchorElement;
var isHTMLElement2 = mod.isHTMLElement;
var isSelectionCapturedInDecoratorInput2 = mod.isSelectionCapturedInDecoratorInput;
var isSelectionWithinEditor2 = mod.isSelectionWithinEditor;

export {
  $createParagraphNode2 as $createParagraphNode,
  $createTabNode2 as $createTabNode,
  $createTextNode2 as $createTextNode,
  $getAdjacentNode2 as $getAdjacentNode,
  $getCharacterOffsets2 as $getCharacterOffsets,
  $getNodeByKey2 as $getNodeByKey,
  $getPreviousSelection2 as $getPreviousSelection,
  $getRoot2 as $getRoot,
  $getSelection2 as $getSelection,
  $hasAncestor2 as $hasAncestor,
  $isDecoratorNode2 as $isDecoratorNode,
  $isElementNode2 as $isElementNode,
  $isLeafNode2 as $isLeafNode,
  $isLineBreakNode2 as $isLineBreakNode,
  $isParagraphNode2 as $isParagraphNode,
  $isRangeSelection2 as $isRangeSelection,
  $isRootNode2 as $isRootNode,
  $isRootOrShadowRoot2 as $isRootOrShadowRoot,
  $isTextNode2 as $isTextNode,
  $parseSerializedNode2 as $parseSerializedNode,
  $selectAll2 as $selectAll,
  $setSelection2 as $setSelection,
  $splitNode2 as $splitNode,
  CAN_REDO_COMMAND2 as CAN_REDO_COMMAND,
  CAN_UNDO_COMMAND2 as CAN_UNDO_COMMAND,
  CLEAR_EDITOR_COMMAND2 as CLEAR_EDITOR_COMMAND,
  CLEAR_HISTORY_COMMAND2 as CLEAR_HISTORY_COMMAND,
  COMMAND_PRIORITY_CRITICAL2 as COMMAND_PRIORITY_CRITICAL,
  COMMAND_PRIORITY_EDITOR2 as COMMAND_PRIORITY_EDITOR,
  CONTROLLED_TEXT_INSERTION_COMMAND2 as CONTROLLED_TEXT_INSERTION_COMMAND,
  COPY_COMMAND2 as COPY_COMMAND,
  CUT_COMMAND2 as CUT_COMMAND,
  DELETE_CHARACTER_COMMAND2 as DELETE_CHARACTER_COMMAND,
  DELETE_LINE_COMMAND2 as DELETE_LINE_COMMAND,
  DELETE_WORD_COMMAND2 as DELETE_WORD_COMMAND,
  DRAGSTART_COMMAND2 as DRAGSTART_COMMAND,
  DROP_COMMAND2 as DROP_COMMAND,
  INSERT_LINE_BREAK_COMMAND2 as INSERT_LINE_BREAK_COMMAND,
  INSERT_PARAGRAPH_COMMAND2 as INSERT_PARAGRAPH_COMMAND,
  KEY_ARROW_LEFT_COMMAND2 as KEY_ARROW_LEFT_COMMAND,
  KEY_ARROW_RIGHT_COMMAND2 as KEY_ARROW_RIGHT_COMMAND,
  KEY_BACKSPACE_COMMAND2 as KEY_BACKSPACE_COMMAND,
  KEY_DELETE_COMMAND2 as KEY_DELETE_COMMAND,
  KEY_ENTER_COMMAND2 as KEY_ENTER_COMMAND,
  PASTE_COMMAND2 as PASTE_COMMAND,
  REDO_COMMAND2 as REDO_COMMAND,
  REMOVE_TEXT_COMMAND2 as REMOVE_TEXT_COMMAND,
  SELECTION_INSERT_CLIPBOARD_NODES_COMMAND2 as SELECTION_INSERT_CLIPBOARD_NODES_COMMAND,
  SELECT_ALL_COMMAND2 as SELECT_ALL_COMMAND,
  TextNode2 as TextNode,
  UNDO_COMMAND2 as UNDO_COMMAND,
  createEditor2 as createEditor,
  isHTMLAnchorElement2 as isHTMLAnchorElement,
  isHTMLElement2 as isHTMLElement,
  isSelectionWithinEditor2 as isSelectionWithinEditor
};
//# sourceMappingURL=chunk-OLAYFG2J.js.map
