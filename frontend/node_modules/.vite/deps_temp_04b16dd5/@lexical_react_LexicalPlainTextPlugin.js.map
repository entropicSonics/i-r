{
  "version": 3,
  "sources": ["../../../../node_modules/@lexical/react/LexicalPlainTextPlugin.dev.esm.js", "../../../../node_modules/@lexical/react/useLexicalEditable.dev.esm.js", "../../../../node_modules/@lexical/react/useLexicalEditable.prod.esm.js", "../../../../node_modules/@lexical/react/useLexicalEditable.esm.js", "../../../../node_modules/@lexical/text/LexicalText.dev.esm.js", "../../../../node_modules/@lexical/text/LexicalText.esm.js", "../../../../node_modules/@lexical/dragon/LexicalDragon.dev.esm.js", "../../../../node_modules/@lexical/dragon/LexicalDragon.esm.js", "../../../../node_modules/@lexical/plain-text/LexicalPlainText.dev.esm.js", "../../../../node_modules/@lexical/clipboard/LexicalClipboard.dev.esm.js", "../../../../node_modules/@lexical/html/LexicalHtml.dev.esm.js", "../../../../node_modules/@lexical/html/LexicalHtml.esm.js", "../../../../node_modules/@lexical/clipboard/LexicalClipboard.prod.esm.js", "../../../../node_modules/@lexical/clipboard/LexicalClipboard.esm.js", "../../../../node_modules/@lexical/plain-text/LexicalPlainText.prod.esm.js", "../../../../node_modules/@lexical/plain-text/LexicalPlainText.esm.js", "../../../../node_modules/@lexical/react/LexicalPlainTextPlugin.prod.esm.js", "../../../../node_modules/@lexical/react/LexicalPlainTextPlugin.esm.js"],
  "sourcesContent": ["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';\nimport useLexicalEditable from '@lexical/react/useLexicalEditable';\nimport * as React from 'react';\nimport { useLayoutEffect as useLayoutEffect$1, useEffect, useState, useMemo, Suspense } from 'react';\nimport { $canShowPlaceholderCurry } from '@lexical/text';\nimport { mergeRegister } from '@lexical/utils';\nimport { createPortal, flushSync } from 'react-dom';\nimport { registerDragonSupport } from '@lexical/dragon';\nimport { registerPlainText } from '@lexical/plain-text';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst useLayoutEffectImpl = CAN_USE_DOM ? useLayoutEffect$1 : useEffect;\nvar useLayoutEffect = useLayoutEffectImpl;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction canShowPlaceholderFromCurrentEditorState(editor) {\n  const currentCanShowPlaceholder = editor.getEditorState().read($canShowPlaceholderCurry(editor.isComposing()));\n  return currentCanShowPlaceholder;\n}\nfunction useCanShowPlaceholder(editor) {\n  const [canShowPlaceholder, setCanShowPlaceholder] = useState(() => canShowPlaceholderFromCurrentEditorState(editor));\n  useLayoutEffect(() => {\n    function resetCanShowPlaceholder() {\n      const currentCanShowPlaceholder = canShowPlaceholderFromCurrentEditorState(editor);\n      setCanShowPlaceholder(currentCanShowPlaceholder);\n    }\n    resetCanShowPlaceholder();\n    return mergeRegister(editor.registerUpdateListener(() => {\n      resetCanShowPlaceholder();\n    }), editor.registerEditableListener(() => {\n      resetCanShowPlaceholder();\n    }));\n  }, [editor]);\n  return canShowPlaceholder;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction useDecorators(editor, ErrorBoundary) {\n  const [decorators, setDecorators] = useState(() => editor.getDecorators());\n\n  // Subscribe to changes\n  useLayoutEffect(() => {\n    return editor.registerDecoratorListener(nextDecorators => {\n      flushSync(() => {\n        setDecorators(nextDecorators);\n      });\n    });\n  }, [editor]);\n  useEffect(() => {\n    // If the content editable mounts before the subscription is added, then\n    // nothing will be rendered on initial pass. We can get around that by\n    // ensuring that we set the value.\n    setDecorators(editor.getDecorators());\n  }, [editor]);\n\n  // Return decorators defined as React Portals\n  return useMemo(() => {\n    const decoratedPortals = [];\n    const decoratorKeys = Object.keys(decorators);\n    for (let i = 0; i < decoratorKeys.length; i++) {\n      const nodeKey = decoratorKeys[i];\n      const reactDecorator = /*#__PURE__*/React.createElement(ErrorBoundary, {\n        onError: e => editor._onError(e)\n      }, /*#__PURE__*/React.createElement(Suspense, {\n        fallback: null\n      }, decorators[nodeKey]));\n      const element = editor.getElementByKey(nodeKey);\n      if (element !== null) {\n        decoratedPortals.push( /*#__PURE__*/createPortal(reactDecorator, element, nodeKey));\n      }\n    }\n    return decoratedPortals;\n  }, [ErrorBoundary, decorators, editor]);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction usePlainTextSetup(editor) {\n  useLayoutEffect(() => {\n    return mergeRegister(registerPlainText(editor), registerDragonSupport(editor));\n\n    // We only do this for init\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [editor]);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction PlainTextPlugin({\n  contentEditable,\n  placeholder,\n  ErrorBoundary\n}) {\n  const [editor] = useLexicalComposerContext();\n  const decorators = useDecorators(editor, ErrorBoundary);\n  usePlainTextSetup(editor);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, contentEditable, /*#__PURE__*/React.createElement(Placeholder, {\n    content: placeholder\n  }), decorators);\n}\nfunction Placeholder({\n  content\n}) {\n  const [editor] = useLexicalComposerContext();\n  const showPlaceholder = useCanShowPlaceholder(editor);\n  const editable = useLexicalEditable();\n  if (!showPlaceholder) {\n    return null;\n  }\n  if (typeof content === 'function') {\n    return content(editable);\n  } else {\n    return content;\n  }\n}\n\nexport { PlainTextPlugin };\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { useLexicalComposerContext } from '@lexical/react/LexicalComposerContext';\nimport { useLayoutEffect as useLayoutEffect$1, useEffect, useMemo, useRef, useState } from 'react';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst useLayoutEffectImpl = CAN_USE_DOM ? useLayoutEffect$1 : useEffect;\nvar useLayoutEffect = useLayoutEffectImpl;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/**\n * Shortcut to Lexical subscriptions when values are used for render.\n */\nfunction useLexicalSubscription(subscription) {\n  const [editor] = useLexicalComposerContext();\n  const initializedSubscription = useMemo(() => subscription(editor), [editor, subscription]);\n  const valueRef = useRef(initializedSubscription.initialValueFn());\n  const [value, setValue] = useState(valueRef.current);\n  useLayoutEffect(() => {\n    const {\n      initialValueFn,\n      subscribe\n    } = initializedSubscription;\n    const currentValue = initialValueFn();\n    if (valueRef.current !== currentValue) {\n      valueRef.current = currentValue;\n      setValue(currentValue);\n    }\n    return subscribe(newValue => {\n      valueRef.current = newValue;\n      setValue(newValue);\n    });\n  }, [initializedSubscription, subscription]);\n  return value;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction subscription(editor) {\n  return {\n    initialValueFn: () => editor.isEditable(),\n    subscribe: callback => {\n      return editor.registerEditableListener(callback);\n    }\n  };\n}\nfunction useLexicalEditable() {\n  return useLexicalSubscription(subscription);\n}\n\nexport { useLexicalEditable as default };\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport{useLexicalComposerContext as e}from\"@lexical/react/LexicalComposerContext\";import{useLayoutEffect as t,useEffect as n,useMemo as r,useRef as i,useState as o}from\"react\";var u=\"undefined\"!=typeof window&&void 0!==window.document&&void 0!==window.document.createElement?t:n;function c(e){return{initialValueFn:()=>e.isEditable(),subscribe:t=>e.registerEditableListener(t)}}function a(){return function(t){const[n]=e(),c=r((()=>t(n)),[n,t]),a=i(c.initialValueFn()),[l,s]=o(a.current);return u((()=>{const{initialValueFn:e,subscribe:t}=c,n=e();return a.current!==n&&(a.current=n,s(n)),t((e=>{a.current=e,s(e)}))}),[c,t]),l}(c)}export{a as default};\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport * as modDev from './useLexicalEditable.dev.esm.js';\nimport * as modProd from './useLexicalEditable.prod.esm.js';\nconst mod = process.env.NODE_ENV === 'development' ? modDev : modProd;\nexport default mod.default;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { $isElementNode, $isTextNode, $getRoot, $isDecoratorNode, $isParagraphNode, TextNode, $createTextNode } from 'lexical';\n\n/** @module @lexical/text */\n/**\n * Finds a TextNode with a size larger than targetCharacters and returns\n * the node along with the remaining length of the text.\n * @param root - The RootNode.\n * @param targetCharacters - The number of characters whose TextNode must be larger than.\n * @returns The TextNode and the intersections offset, or null if no TextNode is found.\n */\nfunction $findTextIntersectionFromCharacters(root, targetCharacters) {\n  let node = root.getFirstChild();\n  let currentCharacters = 0;\n  mainLoop: while (node !== null) {\n    if ($isElementNode(node)) {\n      const child = node.getFirstChild();\n      if (child !== null) {\n        node = child;\n        continue;\n      }\n    } else if ($isTextNode(node)) {\n      const characters = node.getTextContentSize();\n      if (currentCharacters + characters > targetCharacters) {\n        return {\n          node,\n          offset: targetCharacters - currentCharacters\n        };\n      }\n      currentCharacters += characters;\n    }\n    const sibling = node.getNextSibling();\n    if (sibling !== null) {\n      node = sibling;\n      continue;\n    }\n    let parent = node.getParent();\n    while (parent !== null) {\n      const parentSibling = parent.getNextSibling();\n      if (parentSibling !== null) {\n        node = parentSibling;\n        continue mainLoop;\n      }\n      parent = parent.getParent();\n    }\n    break;\n  }\n  return null;\n}\n\n/**\n * Determines if the root has any text content and can trim any whitespace if it does.\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @param trim - Should the root text have its whitespaced trimmed? Defaults to true.\n * @returns true if text content is empty, false if there is text or isEditorComposing is true.\n */\nfunction $isRootTextContentEmpty(isEditorComposing, trim = true) {\n  if (isEditorComposing) {\n    return false;\n  }\n  let text = $rootTextContent();\n  if (trim) {\n    text = text.trim();\n  }\n  return text === '';\n}\n\n/**\n * Returns a function that executes {@link $isRootTextContentEmpty}\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @param trim - Should the root text have its whitespaced trimmed? Defaults to true.\n * @returns A function that executes $isRootTextContentEmpty based on arguments.\n */\nfunction $isRootTextContentEmptyCurry(isEditorComposing, trim) {\n  return () => $isRootTextContentEmpty(isEditorComposing, trim);\n}\n\n/**\n * Returns the root's text content.\n * @returns The root's text content.\n */\nfunction $rootTextContent() {\n  const root = $getRoot();\n  return root.getTextContent();\n}\n\n/**\n * Determines if the input should show the placeholder. If anything is in\n * in the root the placeholder should not be shown.\n * @param isComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @returns true if the input should show the placeholder, false otherwise.\n */\nfunction $canShowPlaceholder(isComposing) {\n  if (!$isRootTextContentEmpty(isComposing, false)) {\n    return false;\n  }\n  const root = $getRoot();\n  const children = root.getChildren();\n  const childrenLength = children.length;\n  if (childrenLength > 1) {\n    return false;\n  }\n  for (let i = 0; i < childrenLength; i++) {\n    const topBlock = children[i];\n    if ($isDecoratorNode(topBlock)) {\n      return false;\n    }\n    if ($isElementNode(topBlock)) {\n      if (!$isParagraphNode(topBlock)) {\n        return false;\n      }\n      if (topBlock.__indent !== 0) {\n        return false;\n      }\n      const topBlockChildren = topBlock.getChildren();\n      const topBlockChildrenLength = topBlockChildren.length;\n      for (let s = 0; s < topBlockChildrenLength; s++) {\n        const child = topBlockChildren[i];\n        if (!$isTextNode(child)) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * Returns a function that executes {@link $canShowPlaceholder}\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @returns A function that executes $canShowPlaceholder with arguments.\n */\nfunction $canShowPlaceholderCurry(isEditorComposing) {\n  return () => $canShowPlaceholder(isEditorComposing);\n}\n/**\n * Returns a tuple that can be rested (...) into mergeRegister to clean up\n * node transforms listeners that transforms text into another node, eg. a HashtagNode.\n * @example\n * ```ts\n *   useEffect(() => {\n    return mergeRegister(\n      ...registerLexicalTextEntity(editor, getMatch, targetNode, createNode),\n    );\n  }, [createNode, editor, getMatch, targetNode]);\n * ```\n * Where targetNode is the type of node containing the text you want to transform (like a text input),\n * then getMatch uses a regex to find a matching text and creates the proper node to include the matching text.\n * @param editor - The lexical editor.\n * @param getMatch - Finds a matching string that satisfies a regex expression.\n * @param targetNode - The node type that contains text to match with. eg. HashtagNode\n * @param createNode - A function that creates a new node to contain the matched text. eg createHashtagNode\n * @returns An array containing the plain text and reverse node transform listeners.\n */\nfunction registerLexicalTextEntity(editor, getMatch, targetNode, createNode) {\n  const isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n  const replaceWithSimpleText = node => {\n    const textNode = $createTextNode(node.getTextContent());\n    textNode.setFormat(node.getFormat());\n    node.replace(textNode);\n  };\n  const getMode = node => {\n    return node.getLatest().__mode;\n  };\n  const textNodeTransform = node => {\n    if (!node.isSimpleText()) {\n      return;\n    }\n    const prevSibling = node.getPreviousSibling();\n    let text = node.getTextContent();\n    let currentNode = node;\n    let match;\n    if ($isTextNode(prevSibling)) {\n      const previousText = prevSibling.getTextContent();\n      const combinedText = previousText + text;\n      const prevMatch = getMatch(combinedText);\n      if (isTargetNode(prevSibling)) {\n        if (prevMatch === null || getMode(prevSibling) !== 0) {\n          replaceWithSimpleText(prevSibling);\n          return;\n        } else {\n          const diff = prevMatch.end - previousText.length;\n          if (diff > 0) {\n            const concatText = text.slice(0, diff);\n            const newTextContent = previousText + concatText;\n            prevSibling.select();\n            prevSibling.setTextContent(newTextContent);\n            if (diff === text.length) {\n              node.remove();\n            } else {\n              const remainingText = text.slice(diff);\n              node.setTextContent(remainingText);\n            }\n            return;\n          }\n        }\n      } else if (prevMatch === null || prevMatch.start < previousText.length) {\n        return;\n      }\n    }\n\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      match = getMatch(text);\n      let nextText = match === null ? '' : text.slice(match.end);\n      text = nextText;\n      if (nextText === '') {\n        const nextSibling = currentNode.getNextSibling();\n        if ($isTextNode(nextSibling)) {\n          nextText = currentNode.getTextContent() + nextSibling.getTextContent();\n          const nextMatch = getMatch(nextText);\n          if (nextMatch === null) {\n            if (isTargetNode(nextSibling)) {\n              replaceWithSimpleText(nextSibling);\n            } else {\n              nextSibling.markDirty();\n            }\n            return;\n          } else if (nextMatch.start !== 0) {\n            return;\n          }\n        }\n      } else {\n        const nextMatch = getMatch(nextText);\n        if (nextMatch !== null && nextMatch.start === 0) {\n          return;\n        }\n      }\n      if (match === null) {\n        return;\n      }\n      if (match.start === 0 && $isTextNode(prevSibling) && prevSibling.isTextEntity()) {\n        continue;\n      }\n      let nodeToReplace;\n      if (match.start === 0) {\n        [nodeToReplace, currentNode] = currentNode.splitText(match.end);\n      } else {\n        [, nodeToReplace, currentNode] = currentNode.splitText(match.start, match.end);\n      }\n      const replacementNode = createNode(nodeToReplace);\n      replacementNode.setFormat(nodeToReplace.getFormat());\n      nodeToReplace.replace(replacementNode);\n      if (currentNode == null) {\n        return;\n      }\n    }\n  };\n  const reverseNodeTransform = node => {\n    const text = node.getTextContent();\n    const match = getMatch(text);\n    if (match === null || match.start !== 0) {\n      replaceWithSimpleText(node);\n      return;\n    }\n    if (text.length > match.end) {\n      // This will split out the rest of the text as simple text\n      node.splitText(match.end);\n      return;\n    }\n    const prevSibling = node.getPreviousSibling();\n    if ($isTextNode(prevSibling) && prevSibling.isTextEntity()) {\n      replaceWithSimpleText(prevSibling);\n      replaceWithSimpleText(node);\n    }\n    const nextSibling = node.getNextSibling();\n    if ($isTextNode(nextSibling) && nextSibling.isTextEntity()) {\n      replaceWithSimpleText(nextSibling);\n\n      // This may have already been converted in the previous block\n      if (isTargetNode(node)) {\n        replaceWithSimpleText(node);\n      }\n    }\n  };\n  const removePlainTextTransform = editor.registerNodeTransform(TextNode, textNodeTransform);\n  const removeReverseNodeTransform = editor.registerNodeTransform(targetNode, reverseNodeTransform);\n  return [removePlainTextTransform, removeReverseNodeTransform];\n}\n\nexport { $canShowPlaceholder, $canShowPlaceholderCurry, $findTextIntersectionFromCharacters, $isRootTextContentEmpty, $isRootTextContentEmptyCurry, $rootTextContent, registerLexicalTextEntity };\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport * as modDev from './LexicalText.dev.esm.js';\nimport * as modProd from './LexicalText.prod.esm.js';\nconst mod = process.env.NODE_ENV === 'development' ? modDev : modProd;\nexport const $canShowPlaceholder = mod.$canShowPlaceholder;\nexport const $canShowPlaceholderCurry = mod.$canShowPlaceholderCurry;\nexport const $findTextIntersectionFromCharacters = mod.$findTextIntersectionFromCharacters;\nexport const $isRootTextContentEmpty = mod.$isRootTextContentEmpty;\nexport const $isRootTextContentEmptyCurry = mod.$isRootTextContentEmptyCurry;\nexport const $rootTextContent = mod.$rootTextContent;\nexport const registerLexicalTextEntity = mod.registerLexicalTextEntity;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { $getSelection, $isRangeSelection, $isTextNode } from 'lexical';\n\n/** @module @lexical/dragon */\nfunction registerDragonSupport(editor) {\n  const origin = window.location.origin;\n  const handler = event => {\n    if (event.origin !== origin) {\n      return;\n    }\n    const rootElement = editor.getRootElement();\n    if (document.activeElement !== rootElement) {\n      return;\n    }\n    const data = event.data;\n    if (typeof data === 'string') {\n      let parsedData;\n      try {\n        parsedData = JSON.parse(data);\n      } catch (e) {\n        return;\n      }\n      if (parsedData && parsedData.protocol === 'nuanria_messaging' && parsedData.type === 'request') {\n        const payload = parsedData.payload;\n        if (payload && payload.functionId === 'makeChanges') {\n          const args = payload.args;\n          if (args) {\n            const [elementStart, elementLength, text, selStart, selLength, formatCommand] = args;\n            editor.update(() => {\n              const selection = $getSelection();\n              if ($isRangeSelection(selection)) {\n                const anchor = selection.anchor;\n                let anchorNode = anchor.getNode();\n                let setSelStart = 0;\n                let setSelEnd = 0;\n                if ($isTextNode(anchorNode)) {\n                  // set initial selection\n                  if (elementStart >= 0 && elementLength >= 0) {\n                    setSelStart = elementStart;\n                    setSelEnd = elementStart + elementLength;\n                    // If the offset is more than the end, make it the end\n                    selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);\n                  }\n                }\n                if (setSelStart !== setSelEnd || text !== '') {\n                  selection.insertRawText(text);\n                  anchorNode = anchor.getNode();\n                }\n                if ($isTextNode(anchorNode)) {\n                  // set final selection\n                  setSelStart = selStart;\n                  setSelEnd = selStart + selLength;\n                  const anchorNodeTextLength = anchorNode.getTextContentSize();\n                  // If the offset is more than the end, make it the end\n                  setSelStart = setSelStart > anchorNodeTextLength ? anchorNodeTextLength : setSelStart;\n                  setSelEnd = setSelEnd > anchorNodeTextLength ? anchorNodeTextLength : setSelEnd;\n                  selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);\n                }\n\n                // block the chrome extension from handling this event\n                event.stopImmediatePropagation();\n              }\n            });\n          }\n        }\n      }\n    }\n  };\n  window.addEventListener('message', handler, true);\n  return () => {\n    window.removeEventListener('message', handler, true);\n  };\n}\n\nexport { registerDragonSupport };\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport * as modDev from './LexicalDragon.dev.esm.js';\nimport * as modProd from './LexicalDragon.prod.esm.js';\nconst mod = process.env.NODE_ENV === 'development' ? modDev : modProd;\nexport const registerDragonSupport = mod.registerDragonSupport;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { $insertDataTransferForPlainText, $getHtmlContent } from '@lexical/clipboard';\nimport { $shouldOverrideDefaultCharacterSelection, $moveCharacter } from '@lexical/selection';\nimport { mergeRegister, objectKlassEquals } from '@lexical/utils';\nimport { DELETE_CHARACTER_COMMAND, $getSelection, $isRangeSelection, COMMAND_PRIORITY_EDITOR, DELETE_WORD_COMMAND, DELETE_LINE_COMMAND, CONTROLLED_TEXT_INSERTION_COMMAND, REMOVE_TEXT_COMMAND, INSERT_LINE_BREAK_COMMAND, INSERT_PARAGRAPH_COMMAND, KEY_ARROW_LEFT_COMMAND, KEY_ARROW_RIGHT_COMMAND, KEY_BACKSPACE_COMMAND, KEY_DELETE_COMMAND, KEY_ENTER_COMMAND, SELECT_ALL_COMMAND, $selectAll, COPY_COMMAND, CUT_COMMAND, PASTE_COMMAND, DROP_COMMAND, DRAGSTART_COMMAND } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nCAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nCAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT = CAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nconst IS_ANDROID = CAN_USE_DOM && /Android/.test(navigator.userAgent);\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);\n// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nCAN_USE_DOM && IS_ANDROID && IS_CHROME;\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n\n/** @module @lexical/plain-text */\nfunction onCopyForPlainText(event, editor) {\n  editor.update(() => {\n    if (event !== null) {\n      const clipboardData = objectKlassEquals(event, KeyboardEvent) ? null : event.clipboardData;\n      const selection = $getSelection();\n      if (selection !== null && clipboardData != null) {\n        event.preventDefault();\n        const htmlString = $getHtmlContent(editor);\n        if (htmlString !== null) {\n          clipboardData.setData('text/html', htmlString);\n        }\n        clipboardData.setData('text/plain', selection.getTextContent());\n      }\n    }\n  });\n}\nfunction onPasteForPlainText(event, editor) {\n  event.preventDefault();\n  editor.update(() => {\n    const selection = $getSelection();\n    const {\n      clipboardData\n    } = event;\n    if (clipboardData != null && $isRangeSelection(selection)) {\n      $insertDataTransferForPlainText(clipboardData, selection);\n    }\n  }, {\n    tag: 'paste'\n  });\n}\nfunction onCutForPlainText(event, editor) {\n  onCopyForPlainText(event, editor);\n  editor.update(() => {\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      selection.removeText();\n    }\n  });\n}\nfunction registerPlainText(editor) {\n  const removeListener = mergeRegister(editor.registerCommand(DELETE_CHARACTER_COMMAND, isBackward => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.deleteCharacter(isBackward);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DELETE_WORD_COMMAND, isBackward => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.deleteWord(isBackward);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DELETE_LINE_COMMAND, isBackward => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.deleteLine(isBackward);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(CONTROLLED_TEXT_INSERTION_COMMAND, eventOrText => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    if (typeof eventOrText === 'string') {\n      selection.insertText(eventOrText);\n    } else {\n      const dataTransfer = eventOrText.dataTransfer;\n      if (dataTransfer != null) {\n        $insertDataTransferForPlainText(dataTransfer, selection);\n      } else {\n        const data = eventOrText.data;\n        if (data) {\n          selection.insertText(data);\n        }\n      }\n    }\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(REMOVE_TEXT_COMMAND, () => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.removeText();\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(INSERT_LINE_BREAK_COMMAND, selectStart => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.insertLineBreak(selectStart);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(INSERT_PARAGRAPH_COMMAND, () => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    selection.insertLineBreak();\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ARROW_LEFT_COMMAND, payload => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    const event = payload;\n    const isHoldingShift = event.shiftKey;\n    if ($shouldOverrideDefaultCharacterSelection(selection, true)) {\n      event.preventDefault();\n      $moveCharacter(selection, isHoldingShift, true);\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ARROW_RIGHT_COMMAND, payload => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    const event = payload;\n    const isHoldingShift = event.shiftKey;\n    if ($shouldOverrideDefaultCharacterSelection(selection, false)) {\n      event.preventDefault();\n      $moveCharacter(selection, isHoldingShift, false);\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_BACKSPACE_COMMAND, event => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    event.preventDefault();\n    return editor.dispatchCommand(DELETE_CHARACTER_COMMAND, true);\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_DELETE_COMMAND, event => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    event.preventDefault();\n    return editor.dispatchCommand(DELETE_CHARACTER_COMMAND, false);\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(KEY_ENTER_COMMAND, event => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    if (event !== null) {\n      // If we have beforeinput, then we can avoid blocking\n      // the default behavior. This ensures that the iOS can\n      // intercept that we're actually inserting a paragraph,\n      // and autocomplete, autocapitalize etc work as intended.\n      // This can also cause a strange performance issue in\n      // Safari, where there is a noticeable pause due to\n      // preventing the key down of enter.\n      if ((IS_IOS || IS_SAFARI || IS_APPLE_WEBKIT) && CAN_USE_BEFORE_INPUT) {\n        return false;\n      }\n      event.preventDefault();\n    }\n    return editor.dispatchCommand(INSERT_LINE_BREAK_COMMAND, false);\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(SELECT_ALL_COMMAND, () => {\n    $selectAll();\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(COPY_COMMAND, event => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    onCopyForPlainText(event, editor);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(CUT_COMMAND, event => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    onCutForPlainText(event, editor);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(PASTE_COMMAND, event => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    onPasteForPlainText(event, editor);\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DROP_COMMAND, event => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n\n    // TODO: Make drag and drop work at some point.\n    event.preventDefault();\n    return true;\n  }, COMMAND_PRIORITY_EDITOR), editor.registerCommand(DRAGSTART_COMMAND, event => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n\n    // TODO: Make drag and drop work at some point.\n    event.preventDefault();\n    return true;\n  }, COMMAND_PRIORITY_EDITOR));\n  return removeListener;\n}\n\nexport { registerPlainText };\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { $generateHtmlFromNodes, $generateNodesFromDOM } from '@lexical/html';\nimport { $addNodeStyle, $cloneWithProperties, $sliceSelectedTextNodeContent } from '@lexical/selection';\nimport { objectKlassEquals } from '@lexical/utils';\nimport { $getSelection, $isRangeSelection, $createTabNode, SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, $getRoot, $parseSerializedNode, $isTextNode, COPY_COMMAND, COMMAND_PRIORITY_CRITICAL, isSelectionWithinEditor, $isElementNode } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst getDOMSelection = targetWindow => CAN_USE_DOM ? (targetWindow || window).getSelection() : null;\n\n/**\n * Returns the *currently selected* Lexical content as an HTML string, relying on the\n * logic defined in the exportDOM methods on the LexicalNode classes. Note that\n * this will not return the HTML content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor - LexicalEditor instance to get HTML content from\n * @returns a string of HTML content\n */\nfunction $getHtmlContent(editor) {\n  const selection = $getSelection();\n  if (selection == null) {\n    {\n      throw Error(`Expected valid LexicalSelection`);\n    }\n  }\n\n  // If we haven't selected anything\n  if ($isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return '';\n  }\n  return $generateHtmlFromNodes(editor, selection);\n}\n\n/**\n * Returns the *currently selected* Lexical content as a JSON string, relying on the\n * logic defined in the exportJSON methods on the LexicalNode classes. Note that\n * this will not return the JSON content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor  - LexicalEditor instance to get the JSON content from\n * @returns\n */\nfunction $getLexicalContent(editor) {\n  const selection = $getSelection();\n  if (selection == null) {\n    {\n      throw Error(`Expected valid LexicalSelection`);\n    }\n  }\n\n  // If we haven't selected anything\n  if ($isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return null;\n  }\n  return JSON.stringify($generateJSONFromSelectedNodes(editor, selection));\n}\n\n/**\n * Attempts to insert content of the mime-types text/plain or text/uri-list from\n * the provided DataTransfer object into the editor at the provided selection.\n * text/uri-list is only used if text/plain is not also provided.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n */\nfunction $insertDataTransferForPlainText(dataTransfer, selection) {\n  const text = dataTransfer.getData('text/plain') || dataTransfer.getData('text/uri-list');\n  if (text != null) {\n    selection.insertRawText(text);\n  }\n}\n\n/**\n * Attempts to insert content of the mime-types application/x-lexical-editor, text/html,\n * text/plain, or text/uri-list (in descending order of priority) from the provided DataTransfer\n * object into the editor at the provided selection.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n * @param editor the LexicalEditor the content is being inserted into.\n */\nfunction $insertDataTransferForRichText(dataTransfer, selection, editor) {\n  const lexicalString = dataTransfer.getData('application/x-lexical-editor');\n  if (lexicalString) {\n    try {\n      const payload = JSON.parse(lexicalString);\n      if (payload.namespace === editor._config.namespace && Array.isArray(payload.nodes)) {\n        const nodes = $generateNodesFromSerializedNodes(payload.nodes);\n        return $insertGeneratedNodes(editor, nodes, selection);\n      }\n    } catch (_unused) {\n      // Fail silently.\n    }\n  }\n  const htmlString = dataTransfer.getData('text/html');\n  if (htmlString) {\n    try {\n      const parser = new DOMParser();\n      const dom = parser.parseFromString(htmlString, 'text/html');\n      const nodes = $generateNodesFromDOM(editor, dom);\n      return $insertGeneratedNodes(editor, nodes, selection);\n    } catch (_unused2) {\n      // Fail silently.\n    }\n  }\n\n  // Multi-line plain text in rich text mode pasted as separate paragraphs\n  // instead of single paragraph with linebreaks.\n  // Webkit-specific: Supports read 'text/uri-list' in clipboard.\n  const text = dataTransfer.getData('text/plain') || dataTransfer.getData('text/uri-list');\n  if (text != null) {\n    if ($isRangeSelection(selection)) {\n      const parts = text.split(/(\\r?\\n|\\t)/);\n      if (parts[parts.length - 1] === '') {\n        parts.pop();\n      }\n      for (let i = 0; i < parts.length; i++) {\n        const part = parts[i];\n        if (part === '\\n' || part === '\\r\\n') {\n          selection.insertParagraph();\n        } else if (part === '\\t') {\n          selection.insertNodes([$createTabNode()]);\n        } else {\n          selection.insertText(part);\n        }\n      }\n    } else {\n      selection.insertRawText(text);\n    }\n  }\n}\n\n/**\n * Inserts Lexical nodes into the editor using different strategies depending on\n * some simple selection-based heuristics. If you're looking for a generic way to\n * to insert nodes into the editor at a specific selection point, you probably want\n * {@link lexical.$insertNodes}\n *\n * @param editor LexicalEditor instance to insert the nodes into.\n * @param nodes The nodes to insert.\n * @param selection The selection to insert the nodes into.\n */\nfunction $insertGeneratedNodes(editor, nodes, selection) {\n  if (!editor.dispatchCommand(SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, {\n    nodes,\n    selection\n  })) {\n    selection.insertNodes(nodes);\n  }\n  return;\n}\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor;\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);\n    }\n  }\n  if ($isElementNode(node)) {\n    const serializedChildren = serializedNode.children;\n    if (!Array.isArray(serializedChildren)) {\n      {\n        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n  }\n  return serializedNode;\n}\nfunction $appendNodesToJSON(editor, selection, currentNode, targetArray = []) {\n  let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;\n  const shouldExclude = $isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection !== null) {\n    let clone = $cloneWithProperties(currentNode);\n    clone = $isTextNode(clone) && selection !== null ? $sliceSelectedTextNodeContent(selection, clone) : clone;\n    target = clone;\n  }\n  const children = $isElementNode(target) ? target.getChildren() : [];\n  const serializedNode = exportNodeToJSON(target);\n\n  // TODO: TextNode calls getTextContent() (NOT node.__text) within it's exportJSON method\n  // which uses getLatest() to get the text from the original node with the same key.\n  // This is a deeper issue with the word \"clone\" here, it's still a reference to the\n  // same node as far as the LexicalEditor is concerned since it shares a key.\n  // We need a way to create a clone of a Node in memory with it's own key, but\n  // until then this hack will work for the selected text extract use case.\n  if ($isTextNode(target)) {\n    const text = target.__text;\n    // If an uncollapsed selection ends or starts at the end of a line of specialized,\n    // TextNodes, such as code tokens, we will get a 'blank' TextNode here, i.e., one\n    // with text of length 0. We don't want this, it makes a confusing mess. Reset!\n    if (text.length > 0) {\n      serializedNode.text = text;\n    } else {\n      shouldInclude = false;\n    }\n  }\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToJSON(editor, selection, childNode, serializedNode.children);\n    if (!shouldInclude && $isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, 'clone')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    targetArray.push(serializedNode);\n  } else if (Array.isArray(serializedNode.children)) {\n    for (let i = 0; i < serializedNode.children.length; i++) {\n      const serializedChildNode = serializedNode.children[i];\n      targetArray.push(serializedChildNode);\n    }\n  }\n  return shouldInclude;\n}\n\n// TODO why $ function with Editor instance?\n/**\n * Gets the Lexical JSON of the nodes inside the provided Selection.\n *\n * @param editor LexicalEditor to get the JSON content from.\n * @param selection Selection to get the JSON content from.\n * @returns an object with the editor namespace and a list of serializable nodes as JavaScript objects.\n */\nfunction $generateJSONFromSelectedNodes(editor, selection) {\n  const nodes = [];\n  const root = $getRoot();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToJSON(editor, selection, topLevelNode, nodes);\n  }\n  return {\n    namespace: editor._config.namespace,\n    nodes\n  };\n}\n\n/**\n * This method takes an array of objects conforming to the BaseSeralizedNode interface and returns\n * an Array containing instances of the corresponding LexicalNode classes registered on the editor.\n * Normally, you'd get an Array of BaseSerialized nodes from {@link $generateJSONFromSelectedNodes}\n *\n * @param serializedNodes an Array of objects conforming to the BaseSerializedNode interface.\n * @returns an Array of Lexical Node objects.\n */\nfunction $generateNodesFromSerializedNodes(serializedNodes) {\n  const nodes = [];\n  for (let i = 0; i < serializedNodes.length; i++) {\n    const serializedNode = serializedNodes[i];\n    const node = $parseSerializedNode(serializedNode);\n    if ($isTextNode(node)) {\n      $addNodeStyle(node);\n    }\n    nodes.push(node);\n  }\n  return nodes;\n}\nconst EVENT_LATENCY = 50;\nlet clipboardEventTimeout = null;\n\n// TODO custom selection\n// TODO potentially have a node customizable version for plain text\n/**\n * Copies the content of the current selection to the clipboard in\n * text/plain, text/html, and application/x-lexical-editor (Lexical JSON)\n * formats.\n *\n * @param editor the LexicalEditor instance to copy content from\n * @param event the native browser ClipboardEvent to add the content to.\n * @returns\n */\nasync function copyToClipboard(editor, event) {\n  if (clipboardEventTimeout !== null) {\n    // Prevent weird race conditions that can happen when this function is run multiple times\n    // synchronously. In the future, we can do better, we can cancel/override the previously running job.\n    return false;\n  }\n  if (event !== null) {\n    return new Promise((resolve, reject) => {\n      editor.update(() => {\n        resolve($copyToClipboardEvent(editor, event));\n      });\n    });\n  }\n  const rootElement = editor.getRootElement();\n  const windowDocument = editor._window == null ? window.document : editor._window.document;\n  const domSelection = getDOMSelection(editor._window);\n  if (rootElement === null || domSelection === null) {\n    return false;\n  }\n  const element = windowDocument.createElement('span');\n  element.style.cssText = 'position: fixed; top: -1000px;';\n  element.append(windowDocument.createTextNode('#'));\n  rootElement.append(element);\n  const range = new Range();\n  range.setStart(element, 0);\n  range.setEnd(element, 1);\n  domSelection.removeAllRanges();\n  domSelection.addRange(range);\n  return new Promise((resolve, reject) => {\n    const removeListener = editor.registerCommand(COPY_COMMAND, secondEvent => {\n      if (objectKlassEquals(secondEvent, ClipboardEvent)) {\n        removeListener();\n        if (clipboardEventTimeout !== null) {\n          window.clearTimeout(clipboardEventTimeout);\n          clipboardEventTimeout = null;\n        }\n        resolve($copyToClipboardEvent(editor, secondEvent));\n      }\n      // Block the entire copy flow while we wait for the next ClipboardEvent\n      return true;\n    }, COMMAND_PRIORITY_CRITICAL);\n    // If the above hack execCommand hack works, this timeout code should never fire. Otherwise,\n    // the listener will be quickly freed so that the user can reuse it again\n    clipboardEventTimeout = window.setTimeout(() => {\n      removeListener();\n      clipboardEventTimeout = null;\n      resolve(false);\n    }, EVENT_LATENCY);\n    windowDocument.execCommand('copy');\n    element.remove();\n  });\n}\n\n// TODO shouldn't pass editor (pass namespace directly)\nfunction $copyToClipboardEvent(editor, event) {\n  const domSelection = getDOMSelection(editor._window);\n  if (!domSelection) {\n    return false;\n  }\n  const anchorDOM = domSelection.anchorNode;\n  const focusDOM = domSelection.focusNode;\n  if (anchorDOM !== null && focusDOM !== null && !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n    return false;\n  }\n  event.preventDefault();\n  const clipboardData = event.clipboardData;\n  const selection = $getSelection();\n  if (clipboardData === null || selection === null) {\n    return false;\n  }\n  const htmlString = $getHtmlContent(editor);\n  const lexicalString = $getLexicalContent(editor);\n  let plainString = '';\n  if (selection !== null) {\n    plainString = selection.getTextContent();\n  }\n  if (htmlString !== null) {\n    clipboardData.setData('text/html', htmlString);\n  }\n  if (lexicalString !== null) {\n    clipboardData.setData('application/x-lexical-editor', lexicalString);\n  }\n  clipboardData.setData('text/plain', plainString);\n  return true;\n}\n\nexport { $generateJSONFromSelectedNodes, $generateNodesFromSerializedNodes, $getHtmlContent, $getLexicalContent, $insertDataTransferForPlainText, $insertDataTransferForRichText, $insertGeneratedNodes, copyToClipboard };\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { $cloneWithProperties, $sliceSelectedTextNodeContent } from '@lexical/selection';\nimport { isHTMLElement } from '@lexical/utils';\nimport { $getRoot, $isElementNode, $isTextNode } from 'lexical';\n\n/** @module @lexical/html */\n\n/**\n * How you parse your html string to get a document is left up to you. In the browser you can use the native\n * DOMParser API to generate a document (see clipboard.ts), but to use in a headless environment you can use JSDom\n * or an equivalent library and pass in the document here.\n */\nfunction $generateNodesFromDOM(editor, dom) {\n  const elements = dom.body ? dom.body.childNodes : [];\n  let lexicalNodes = [];\n  for (let i = 0; i < elements.length; i++) {\n    const element = elements[i];\n    if (!IGNORE_TAGS.has(element.nodeName)) {\n      const lexicalNode = $createNodesFromDOM(element, editor);\n      if (lexicalNode !== null) {\n        lexicalNodes = lexicalNodes.concat(lexicalNode);\n      }\n    }\n  }\n  return lexicalNodes;\n}\nfunction $generateHtmlFromNodes(editor, selection) {\n  if (typeof document === 'undefined' || typeof window === 'undefined' && typeof global.window === 'undefined') {\n    throw new Error('To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.');\n  }\n  const container = document.createElement('div');\n  const root = $getRoot();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToHTML(editor, topLevelNode, container, selection);\n  }\n  return container.innerHTML;\n}\nfunction $appendNodesToHTML(editor, currentNode, parentElement, selection = null) {\n  let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;\n  const shouldExclude = $isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection !== null) {\n    let clone = $cloneWithProperties(currentNode);\n    clone = $isTextNode(clone) && selection !== null ? $sliceSelectedTextNodeContent(selection, clone) : clone;\n    target = clone;\n  }\n  const children = $isElementNode(target) ? target.getChildren() : [];\n  const registeredNode = editor._nodes.get(target.getType());\n  let exportOutput;\n\n  // Use HTMLConfig overrides, if available.\n  if (registeredNode && registeredNode.exportDOM !== undefined) {\n    exportOutput = registeredNode.exportDOM(editor, target);\n  } else {\n    exportOutput = target.exportDOM(editor);\n  }\n  const {\n    element,\n    after\n  } = exportOutput;\n  if (!element) {\n    return false;\n  }\n  const fragment = document.createDocumentFragment();\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToHTML(editor, childNode, fragment, selection);\n    if (!shouldInclude && $isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, 'html')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    if (isHTMLElement(element)) {\n      element.append(fragment);\n    }\n    parentElement.append(element);\n    if (after) {\n      const newElement = after.call(target, element);\n      if (newElement) {\n        element.replaceWith(newElement);\n      }\n    }\n  } else {\n    parentElement.append(fragment);\n  }\n  return shouldInclude;\n}\nfunction getConversionFunction(domNode, editor) {\n  const {\n    nodeName\n  } = domNode;\n  const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());\n  let currentConversion = null;\n  if (cachedConversions !== undefined) {\n    for (const cachedConversion of cachedConversions) {\n      const domConversion = cachedConversion(domNode);\n      if (domConversion !== null && (currentConversion === null || (currentConversion.priority || 0) < (domConversion.priority || 0))) {\n        currentConversion = domConversion;\n      }\n    }\n  }\n  return currentConversion !== null ? currentConversion.conversion : null;\n}\nconst IGNORE_TAGS = new Set(['STYLE', 'SCRIPT']);\nfunction $createNodesFromDOM(node, editor, forChildMap = new Map(), parentLexicalNode) {\n  let lexicalNodes = [];\n  if (IGNORE_TAGS.has(node.nodeName)) {\n    return lexicalNodes;\n  }\n  let currentLexicalNode = null;\n  const transformFunction = getConversionFunction(node, editor);\n  const transformOutput = transformFunction ? transformFunction(node) : null;\n  let postTransform = null;\n  if (transformOutput !== null) {\n    postTransform = transformOutput.after;\n    const transformNodes = transformOutput.node;\n    currentLexicalNode = Array.isArray(transformNodes) ? transformNodes[transformNodes.length - 1] : transformNodes;\n    if (currentLexicalNode !== null) {\n      for (const [, forChildFunction] of forChildMap) {\n        currentLexicalNode = forChildFunction(currentLexicalNode, parentLexicalNode);\n        if (!currentLexicalNode) {\n          break;\n        }\n      }\n      if (currentLexicalNode) {\n        lexicalNodes.push(...(Array.isArray(transformNodes) ? transformNodes : [currentLexicalNode]));\n      }\n    }\n    if (transformOutput.forChild != null) {\n      forChildMap.set(node.nodeName, transformOutput.forChild);\n    }\n  }\n\n  // If the DOM node doesn't have a transformer, we don't know what\n  // to do with it but we still need to process any childNodes.\n  const children = node.childNodes;\n  let childLexicalNodes = [];\n  for (let i = 0; i < children.length; i++) {\n    childLexicalNodes.push(...$createNodesFromDOM(children[i], editor, new Map(forChildMap), currentLexicalNode));\n  }\n  if (postTransform != null) {\n    childLexicalNodes = postTransform(childLexicalNodes);\n  }\n  if (currentLexicalNode == null) {\n    // If it hasn't been converted to a LexicalNode, we hoist its children\n    // up to the same level as it.\n    lexicalNodes = lexicalNodes.concat(childLexicalNodes);\n  } else {\n    if ($isElementNode(currentLexicalNode)) {\n      // If the current node is a ElementNode after conversion,\n      // we can append all the children to it.\n      currentLexicalNode.append(...childLexicalNodes);\n    }\n  }\n  return lexicalNodes;\n}\n\nexport { $generateHtmlFromNodes, $generateNodesFromDOM };\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport * as modDev from './LexicalHtml.dev.esm.js';\nimport * as modProd from './LexicalHtml.prod.esm.js';\nconst mod = process.env.NODE_ENV === 'development' ? modDev : modProd;\nexport const $generateHtmlFromNodes = mod.$generateHtmlFromNodes;\nexport const $generateNodesFromDOM = mod.$generateNodesFromDOM;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport{$generateHtmlFromNodes as e,$generateNodesFromDOM as t}from\"@lexical/html\";import{$addNodeStyle as n,$cloneWithProperties as o,$sliceSelectedTextNodeContent as l}from\"@lexical/selection\";import{objectKlassEquals as r}from\"@lexical/utils\";import{$getSelection as i,$isRangeSelection as a,$createTabNode as c,SELECTION_INSERT_CLIPBOARD_NODES_COMMAND as s,$getRoot as u,$parseSerializedNode as d,$isTextNode as f,COPY_COMMAND as p,COMMAND_PRIORITY_CRITICAL as m,isSelectionWithinEditor as h,$isElementNode as x}from\"lexical\";var g=function(e){const t=new URLSearchParams;t.append(\"code\",e);for(let e=1;e<arguments.length;e++)t.append(\"v\",arguments[e]);throw Error(`Minified Lexical error #${e}; visit https://lexical.dev/docs/error?${t} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`)};const w=\"undefined\"!=typeof window&&void 0!==window.document&&void 0!==window.document.createElement,y=e=>w?(e||window).getSelection():null;function v(t){const n=i();if(null==n)throw Error(\"Expected valid LexicalSelection\");return a(n)&&n.isCollapsed()||0===n.getNodes().length?\"\":e(t,n)}function D(e){const t=i();if(null==t)throw Error(\"Expected valid LexicalSelection\");return a(t)&&t.isCollapsed()||0===t.getNodes().length?null:JSON.stringify(T(e,t))}function C(e,t){const n=e.getData(\"text/plain\")||e.getData(\"text/uri-list\");null!=n&&t.insertRawText(n)}function E(e,n,o){const l=e.getData(\"application/x-lexical-editor\");if(l)try{const e=JSON.parse(l);if(e.namespace===o._config.namespace&&Array.isArray(e.nodes)){return N(o,_(e.nodes),n)}}catch(e){}const r=e.getData(\"text/html\");if(r)try{const e=(new DOMParser).parseFromString(r,\"text/html\");return N(o,t(o,e),n)}catch(e){}const i=e.getData(\"text/plain\")||e.getData(\"text/uri-list\");if(null!=i)if(a(n)){const e=i.split(/(\\r?\\n|\\t)/);\"\"===e[e.length-1]&&e.pop();for(let t=0;t<e.length;t++){const o=e[t];\"\\n\"===o||\"\\r\\n\"===o?n.insertParagraph():\"\\t\"===o?n.insertNodes([c()]):n.insertText(o)}}else n.insertRawText(i)}function N(e,t,n){e.dispatchCommand(s,{nodes:t,selection:n})||n.insertNodes(t)}function S(e,t,n,r=[]){let i=null===t||n.isSelected(t);const a=x(n)&&n.excludeFromCopy(\"html\");let c=n;if(null!==t){let e=o(n);e=f(e)&&null!==t?l(t,e):e,c=e}const s=x(c)?c.getChildren():[],u=function(e){const t=e.exportJSON(),n=e.constructor;if(t.type!==n.getType()&&g(58,n.name),x(e)){const e=t.children;Array.isArray(e)||g(59,n.name)}return t}(c);if(f(c)){const e=c.__text;e.length>0?u.text=e:i=!1}for(let o=0;o<s.length;o++){const l=s[o],r=S(e,t,l,u.children);!i&&x(n)&&r&&n.extractWithChild(l,t,\"clone\")&&(i=!0)}if(i&&!a)r.push(u);else if(Array.isArray(u.children))for(let e=0;e<u.children.length;e++){const t=u.children[e];r.push(t)}return i}function T(e,t){const n=[],o=u().getChildren();for(let l=0;l<o.length;l++){S(e,t,o[l],n)}return{namespace:e._config.namespace,nodes:n}}function _(e){const t=[];for(let o=0;o<e.length;o++){const l=e[o],r=d(l);f(r)&&n(r),t.push(r)}return t}let A=null;async function R(e,t){if(null!==A)return!1;if(null!==t)return new Promise(((n,o)=>{e.update((()=>{n(P(e,t))}))}));const n=e.getRootElement(),o=null==e._window?window.document:e._window.document,l=y(e._window);if(null===n||null===l)return!1;const i=o.createElement(\"span\");i.style.cssText=\"position: fixed; top: -1000px;\",i.append(o.createTextNode(\"#\")),n.append(i);const a=new Range;return a.setStart(i,0),a.setEnd(i,1),l.removeAllRanges(),l.addRange(a),new Promise(((t,n)=>{const l=e.registerCommand(p,(n=>(r(n,ClipboardEvent)&&(l(),null!==A&&(window.clearTimeout(A),A=null),t(P(e,n))),!0)),m);A=window.setTimeout((()=>{l(),A=null,t(!1)}),50),o.execCommand(\"copy\"),i.remove()}))}function P(e,t){const n=y(e._window);if(!n)return!1;const o=n.anchorNode,l=n.focusNode;if(null!==o&&null!==l&&!h(e,o,l))return!1;t.preventDefault();const r=t.clipboardData,a=i();if(null===r||null===a)return!1;const c=v(e),s=D(e);let u=\"\";return null!==a&&(u=a.getTextContent()),null!==c&&r.setData(\"text/html\",c),null!==s&&r.setData(\"application/x-lexical-editor\",s),r.setData(\"text/plain\",u),!0}export{T as $generateJSONFromSelectedNodes,_ as $generateNodesFromSerializedNodes,v as $getHtmlContent,D as $getLexicalContent,C as $insertDataTransferForPlainText,E as $insertDataTransferForRichText,N as $insertGeneratedNodes,R as copyToClipboard};\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport * as modDev from './LexicalClipboard.dev.esm.js';\nimport * as modProd from './LexicalClipboard.prod.esm.js';\nconst mod = process.env.NODE_ENV === 'development' ? modDev : modProd;\nexport const $generateJSONFromSelectedNodes = mod.$generateJSONFromSelectedNodes;\nexport const $generateNodesFromSerializedNodes = mod.$generateNodesFromSerializedNodes;\nexport const $getHtmlContent = mod.$getHtmlContent;\nexport const $getLexicalContent = mod.$getLexicalContent;\nexport const $insertDataTransferForPlainText = mod.$insertDataTransferForPlainText;\nexport const $insertDataTransferForRichText = mod.$insertDataTransferForRichText;\nexport const $insertGeneratedNodes = mod.$insertGeneratedNodes;\nexport const copyToClipboard = mod.copyToClipboard;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport{$insertDataTransferForPlainText as e,$getHtmlContent as t}from\"@lexical/clipboard\";import{$shouldOverrideDefaultCharacterSelection as n,$moveCharacter as r}from\"@lexical/selection\";import{mergeRegister as o,objectKlassEquals as i}from\"@lexical/utils\";import{DELETE_CHARACTER_COMMAND as a,$getSelection as s,$isRangeSelection as u,COMMAND_PRIORITY_EDITOR as m,DELETE_WORD_COMMAND as d,DELETE_LINE_COMMAND as c,CONTROLLED_TEXT_INSERTION_COMMAND as l,REMOVE_TEXT_COMMAND as g,INSERT_LINE_BREAK_COMMAND as f,INSERT_PARAGRAPH_COMMAND as p,KEY_ARROW_LEFT_COMMAND as C,KEY_ARROW_RIGHT_COMMAND as v,KEY_BACKSPACE_COMMAND as w,KEY_DELETE_COMMAND as x,KEY_ENTER_COMMAND as D,SELECT_ALL_COMMAND as h,$selectAll as A,COPY_COMMAND as T,CUT_COMMAND as y,PASTE_COMMAND as P,DROP_COMMAND as b,DRAGSTART_COMMAND as E}from\"lexical\";const K=\"undefined\"!=typeof window&&void 0!==window.document&&void 0!==window.document.createElement,M=K&&\"documentMode\"in document?document.documentMode:null;K&&/Mac|iPod|iPhone|iPad/.test(navigator.platform),K&&/^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);const S=!(!K||!(\"InputEvent\"in window)||M)&&\"getTargetRanges\"in new window.InputEvent(\"input\"),k=K&&/Version\\/[\\d.]+.*Safari/.test(navigator.userAgent),L=K&&/iPad|iPhone|iPod/.test(navigator.userAgent)&&!window.MSStream,B=(K&&/Android/.test(navigator.userAgent),K&&/^(?=.*Chrome).*/i.test(navigator.userAgent)),I=K&&/AppleWebKit\\/[\\d.]+/.test(navigator.userAgent)&&!B;function W(e,n){n.update((()=>{if(null!==e){const r=i(e,KeyboardEvent)?null:e.clipboardData,o=s();if(null!==o&&null!=r){e.preventDefault();const i=t(n);null!==i&&r.setData(\"text/html\",i),r.setData(\"text/plain\",o.getTextContent())}}}))}function F(t){return o(t.registerCommand(a,(e=>{const t=s();return!!u(t)&&(t.deleteCharacter(e),!0)}),m),t.registerCommand(d,(e=>{const t=s();return!!u(t)&&(t.deleteWord(e),!0)}),m),t.registerCommand(c,(e=>{const t=s();return!!u(t)&&(t.deleteLine(e),!0)}),m),t.registerCommand(l,(t=>{const n=s();if(!u(n))return!1;if(\"string\"==typeof t)n.insertText(t);else{const r=t.dataTransfer;if(null!=r)e(r,n);else{const e=t.data;e&&n.insertText(e)}}return!0}),m),t.registerCommand(g,(()=>{const e=s();return!!u(e)&&(e.removeText(),!0)}),m),t.registerCommand(f,(e=>{const t=s();return!!u(t)&&(t.insertLineBreak(e),!0)}),m),t.registerCommand(p,(()=>{const e=s();return!!u(e)&&(e.insertLineBreak(),!0)}),m),t.registerCommand(C,(e=>{const t=s();if(!u(t))return!1;const o=e,i=o.shiftKey;return!!n(t,!0)&&(o.preventDefault(),r(t,i,!0),!0)}),m),t.registerCommand(v,(e=>{const t=s();if(!u(t))return!1;const o=e,i=o.shiftKey;return!!n(t,!1)&&(o.preventDefault(),r(t,i,!1),!0)}),m),t.registerCommand(w,(e=>{const n=s();return!!u(n)&&(e.preventDefault(),t.dispatchCommand(a,!0))}),m),t.registerCommand(x,(e=>{const n=s();return!!u(n)&&(e.preventDefault(),t.dispatchCommand(a,!1))}),m),t.registerCommand(D,(e=>{const n=s();if(!u(n))return!1;if(null!==e){if((L||k||I)&&S)return!1;e.preventDefault()}return t.dispatchCommand(f,!1)}),m),t.registerCommand(h,(()=>(A(),!0)),m),t.registerCommand(T,(e=>{const n=s();return!!u(n)&&(W(e,t),!0)}),m),t.registerCommand(y,(e=>{const n=s();return!!u(n)&&(function(e,t){W(e,t),t.update((()=>{const e=s();u(e)&&e.removeText()}))}(e,t),!0)}),m),t.registerCommand(P,(n=>{const r=s();return!!u(r)&&(function(t,n){t.preventDefault(),n.update((()=>{const n=s(),{clipboardData:r}=t;null!=r&&u(n)&&e(r,n)}),{tag:\"paste\"})}(n,t),!0)}),m),t.registerCommand(b,(e=>{const t=s();return!!u(t)&&(e.preventDefault(),!0)}),m),t.registerCommand(E,(e=>{const t=s();return!!u(t)&&(e.preventDefault(),!0)}),m))}export{F as registerPlainText};\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport * as modDev from './LexicalPlainText.dev.esm.js';\nimport * as modProd from './LexicalPlainText.prod.esm.js';\nconst mod = process.env.NODE_ENV === 'development' ? modDev : modProd;\nexport const registerPlainText = mod.registerPlainText;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport{useLexicalComposerContext as e}from\"@lexical/react/LexicalComposerContext\";import t from\"@lexical/react/useLexicalEditable\";import*as r from\"react\";import{useLayoutEffect as o,useEffect as n,useState as c,useMemo as i,Suspense as l}from\"react\";import{$canShowPlaceholderCurry as a}from\"@lexical/text\";import{mergeRegister as m}from\"@lexical/utils\";import{createPortal as u,flushSync as s}from\"react-dom\";import{registerDragonSupport as f}from\"@lexical/dragon\";import{registerPlainText as d}from\"@lexical/plain-text\";var p=\"undefined\"!=typeof window&&void 0!==window.document&&void 0!==window.document.createElement?o:n;function E(e){return e.getEditorState().read(a(e.isComposing()))}function x({contentEditable:t,placeholder:o,ErrorBoundary:a}){const[E]=e(),x=function(e,t){const[o,a]=c((()=>e.getDecorators()));return p((()=>e.registerDecoratorListener((e=>{s((()=>{a(e)}))}))),[e]),n((()=>{a(e.getDecorators())}),[e]),i((()=>{const n=[],c=Object.keys(o);for(let i=0;i<c.length;i++){const a=c[i],m=r.createElement(t,{onError:t=>e._onError(t)},r.createElement(l,{fallback:null},o[a])),s=e.getElementByKey(a);null!==s&&n.push(u(m,s,a))}return n}),[t,o,e])}(E,a);return function(e){p((()=>m(d(e),f(e))),[e])}(E),r.createElement(r.Fragment,null,t,r.createElement(g,{content:o}),x)}function g({content:r}){const[o]=e(),n=function(e){const[t,r]=c((()=>E(e)));return p((()=>{function t(){const t=E(e);r(t)}return t(),m(e.registerUpdateListener((()=>{t()})),e.registerEditableListener((()=>{t()})))}),[e]),t}(o),i=t();return n?\"function\"==typeof r?r(i):r:null}export{x as PlainTextPlugin};\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport * as modDev from './LexicalPlainTextPlugin.dev.esm.js';\nimport * as modProd from './LexicalPlainTextPlugin.prod.esm.js';\nconst mod = process.env.NODE_ENV === 'development' ? modDev : modProd;\nexport const PlainTextPlugin = mod.PlainTextPlugin;"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;ACAA;AAAA;AAAA;AAAA;AAOA,mBAA2F;AAU3F,IAAM,cAAc,OAAO,WAAW,eAAe,OAAO,OAAO,aAAa,eAAe,OAAO,OAAO,SAAS,kBAAkB;AASxI,IAAM,sBAAsB,cAAc,aAAAA,kBAAoB;AAC9D,IAAI,kBAAkB;AAYtB,SAAS,uBAAuBC,eAAc;AAC5C,QAAM,CAAC,MAAM,IAAI,0BAA0B;AAC3C,QAAM,8BAA0B,sBAAQ,MAAMA,cAAa,MAAM,GAAG,CAAC,QAAQA,aAAY,CAAC;AAC1F,QAAM,eAAW,qBAAO,wBAAwB,eAAe,CAAC;AAChE,QAAM,CAAC,OAAO,QAAQ,QAAI,uBAAS,SAAS,OAAO;AACnD,kBAAgB,MAAM;AACpB,UAAM;AAAA,MACJ;AAAA,MACA;AAAA,IACF,IAAI;AACJ,UAAM,eAAe,eAAe;AACpC,QAAI,SAAS,YAAY,cAAc;AACrC,eAAS,UAAU;AACnB,eAAS,YAAY;AAAA,IACvB;AACA,WAAO,UAAU,cAAY;AAC3B,eAAS,UAAU;AACnB,eAAS,QAAQ;AAAA,IACnB,CAAC;AAAA,EACH,GAAG,CAAC,yBAAyBA,aAAY,CAAC;AAC1C,SAAO;AACT;AASA,SAAS,aAAa,QAAQ;AAC5B,SAAO;AAAA,IACL,gBAAgB,MAAM,OAAO,WAAW;AAAA,IACxC,WAAW,cAAY;AACrB,aAAO,OAAO,yBAAyB,QAAQ;AAAA,IACjD;AAAA,EACF;AACF;AACA,SAAS,qBAAqB;AAC5B,SAAO,uBAAuB,YAAY;AAC5C;;;ACzEkF,IAAAC,gBAAsF;AAAQ,IAAI,IAAE,eAAa,OAAO,UAAQ,WAAS,OAAO,YAAU,WAAS,OAAO,SAAS,gBAAc,cAAAC,kBAAE,cAAAC;;;ACErR,IAAM,MAAM,OAAyC,qCAAS;AAC9D,IAAO,iCAAQ,IAAI;;;AHDnB,YAAuB;AACvB,IAAAC,gBAA6F;;;AIT7F;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBA,SAAS,oCAAoC,MAAM,kBAAkB;AACnE,MAAI,OAAO,KAAK,cAAc;AAC9B,MAAI,oBAAoB;AACxB;AAAU,WAAO,SAAS,MAAM;AAC9B,UAAI,eAAe,IAAI,GAAG;AACxB,cAAM,QAAQ,KAAK,cAAc;AACjC,YAAI,UAAU,MAAM;AAClB,iBAAO;AACP;AAAA,QACF;AAAA,MACF,WAAW,YAAY,IAAI,GAAG;AAC5B,cAAM,aAAa,KAAK,mBAAmB;AAC3C,YAAI,oBAAoB,aAAa,kBAAkB;AACrD,iBAAO;AAAA,YACL;AAAA,YACA,QAAQ,mBAAmB;AAAA,UAC7B;AAAA,QACF;AACA,6BAAqB;AAAA,MACvB;AACA,YAAM,UAAU,KAAK,eAAe;AACpC,UAAI,YAAY,MAAM;AACpB,eAAO;AACP;AAAA,MACF;AACA,UAAI,SAAS,KAAK,UAAU;AAC5B,aAAO,WAAW,MAAM;AACtB,cAAM,gBAAgB,OAAO,eAAe;AAC5C,YAAI,kBAAkB,MAAM;AAC1B,iBAAO;AACP,mBAAS;AAAA,QACX;AACA,iBAAS,OAAO,UAAU;AAAA,MAC5B;AACA;AAAA,IACF;AACA,SAAO;AACT;AAQA,SAAS,wBAAwB,mBAAmB,OAAO,MAAM;AAC/D,MAAI,mBAAmB;AACrB,WAAO;AAAA,EACT;AACA,MAAI,OAAO,iBAAiB;AAC5B,MAAI,MAAM;AACR,WAAO,KAAK,KAAK;AAAA,EACnB;AACA,SAAO,SAAS;AAClB;AAQA,SAAS,6BAA6B,mBAAmB,MAAM;AAC7D,SAAO,MAAM,wBAAwB,mBAAmB,IAAI;AAC9D;AAMA,SAAS,mBAAmB;AAC1B,QAAM,OAAO,SAAS;AACtB,SAAO,KAAK,eAAe;AAC7B;AAQA,SAAS,oBAAoB,aAAa;AACxC,MAAI,CAAC,wBAAwB,aAAa,KAAK,GAAG;AAChD,WAAO;AAAA,EACT;AACA,QAAM,OAAO,SAAS;AACtB,QAAM,WAAW,KAAK,YAAY;AAClC,QAAM,iBAAiB,SAAS;AAChC,MAAI,iBAAiB,GAAG;AACtB,WAAO;AAAA,EACT;AACA,WAASC,KAAI,GAAGA,KAAI,gBAAgBA,MAAK;AACvC,UAAM,WAAW,SAASA,EAAC;AAC3B,QAAI,iBAAiB,QAAQ,GAAG;AAC9B,aAAO;AAAA,IACT;AACA,QAAI,eAAe,QAAQ,GAAG;AAC5B,UAAI,CAAC,iBAAiB,QAAQ,GAAG;AAC/B,eAAO;AAAA,MACT;AACA,UAAI,SAAS,aAAa,GAAG;AAC3B,eAAO;AAAA,MACT;AACA,YAAM,mBAAmB,SAAS,YAAY;AAC9C,YAAM,yBAAyB,iBAAiB;AAChD,eAASC,KAAI,GAAGA,KAAI,wBAAwBA,MAAK;AAC/C,cAAM,QAAQ,iBAAiBD,EAAC;AAChC,YAAI,CAAC,YAAY,KAAK,GAAG;AACvB,iBAAO;AAAA,QACT;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AAOA,SAAS,yBAAyB,mBAAmB;AACnD,SAAO,MAAM,oBAAoB,iBAAiB;AACpD;AAoBA,SAAS,0BAA0B,QAAQ,UAAU,YAAY,YAAY;AAC3E,QAAM,eAAe,UAAQ;AAC3B,WAAO,gBAAgB;AAAA,EACzB;AACA,QAAM,wBAAwB,UAAQ;AACpC,UAAM,WAAW,gBAAgB,KAAK,eAAe,CAAC;AACtD,aAAS,UAAU,KAAK,UAAU,CAAC;AACnC,SAAK,QAAQ,QAAQ;AAAA,EACvB;AACA,QAAM,UAAU,UAAQ;AACtB,WAAO,KAAK,UAAU,EAAE;AAAA,EAC1B;AACA,QAAM,oBAAoB,UAAQ;AAChC,QAAI,CAAC,KAAK,aAAa,GAAG;AACxB;AAAA,IACF;AACA,UAAM,cAAc,KAAK,mBAAmB;AAC5C,QAAI,OAAO,KAAK,eAAe;AAC/B,QAAI,cAAc;AAClB,QAAI;AACJ,QAAI,YAAY,WAAW,GAAG;AAC5B,YAAM,eAAe,YAAY,eAAe;AAChD,YAAM,eAAe,eAAe;AACpC,YAAM,YAAY,SAAS,YAAY;AACvC,UAAI,aAAa,WAAW,GAAG;AAC7B,YAAI,cAAc,QAAQ,QAAQ,WAAW,MAAM,GAAG;AACpD,gCAAsB,WAAW;AACjC;AAAA,QACF,OAAO;AACL,gBAAM,OAAO,UAAU,MAAM,aAAa;AAC1C,cAAI,OAAO,GAAG;AACZ,kBAAM,aAAa,KAAK,MAAM,GAAG,IAAI;AACrC,kBAAM,iBAAiB,eAAe;AACtC,wBAAY,OAAO;AACnB,wBAAY,eAAe,cAAc;AACzC,gBAAI,SAAS,KAAK,QAAQ;AACxB,mBAAK,OAAO;AAAA,YACd,OAAO;AACL,oBAAM,gBAAgB,KAAK,MAAM,IAAI;AACrC,mBAAK,eAAe,aAAa;AAAA,YACnC;AACA;AAAA,UACF;AAAA,QACF;AAAA,MACF,WAAW,cAAc,QAAQ,UAAU,QAAQ,aAAa,QAAQ;AACtE;AAAA,MACF;AAAA,IACF;AAGA,WAAO,MAAM;AACX,cAAQ,SAAS,IAAI;AACrB,UAAI,WAAW,UAAU,OAAO,KAAK,KAAK,MAAM,MAAM,GAAG;AACzD,aAAO;AACP,UAAI,aAAa,IAAI;AACnB,cAAM,cAAc,YAAY,eAAe;AAC/C,YAAI,YAAY,WAAW,GAAG;AAC5B,qBAAW,YAAY,eAAe,IAAI,YAAY,eAAe;AACrE,gBAAM,YAAY,SAAS,QAAQ;AACnC,cAAI,cAAc,MAAM;AACtB,gBAAI,aAAa,WAAW,GAAG;AAC7B,oCAAsB,WAAW;AAAA,YACnC,OAAO;AACL,0BAAY,UAAU;AAAA,YACxB;AACA;AAAA,UACF,WAAW,UAAU,UAAU,GAAG;AAChC;AAAA,UACF;AAAA,QACF;AAAA,MACF,OAAO;AACL,cAAM,YAAY,SAAS,QAAQ;AACnC,YAAI,cAAc,QAAQ,UAAU,UAAU,GAAG;AAC/C;AAAA,QACF;AAAA,MACF;AACA,UAAI,UAAU,MAAM;AAClB;AAAA,MACF;AACA,UAAI,MAAM,UAAU,KAAK,YAAY,WAAW,KAAK,YAAY,aAAa,GAAG;AAC/E;AAAA,MACF;AACA,UAAI;AACJ,UAAI,MAAM,UAAU,GAAG;AACrB,SAAC,eAAe,WAAW,IAAI,YAAY,UAAU,MAAM,GAAG;AAAA,MAChE,OAAO;AACL,SAAC,EAAE,eAAe,WAAW,IAAI,YAAY,UAAU,MAAM,OAAO,MAAM,GAAG;AAAA,MAC/E;AACA,YAAM,kBAAkB,WAAW,aAAa;AAChD,sBAAgB,UAAU,cAAc,UAAU,CAAC;AACnD,oBAAc,QAAQ,eAAe;AACrC,UAAI,eAAe,MAAM;AACvB;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACA,QAAM,uBAAuB,UAAQ;AACnC,UAAM,OAAO,KAAK,eAAe;AACjC,UAAM,QAAQ,SAAS,IAAI;AAC3B,QAAI,UAAU,QAAQ,MAAM,UAAU,GAAG;AACvC,4BAAsB,IAAI;AAC1B;AAAA,IACF;AACA,QAAI,KAAK,SAAS,MAAM,KAAK;AAE3B,WAAK,UAAU,MAAM,GAAG;AACxB;AAAA,IACF;AACA,UAAM,cAAc,KAAK,mBAAmB;AAC5C,QAAI,YAAY,WAAW,KAAK,YAAY,aAAa,GAAG;AAC1D,4BAAsB,WAAW;AACjC,4BAAsB,IAAI;AAAA,IAC5B;AACA,UAAM,cAAc,KAAK,eAAe;AACxC,QAAI,YAAY,WAAW,KAAK,YAAY,aAAa,GAAG;AAC1D,4BAAsB,WAAW;AAGjC,UAAI,aAAa,IAAI,GAAG;AACtB,8BAAsB,IAAI;AAAA,MAC5B;AAAA,IACF;AAAA,EACF;AACA,QAAM,2BAA2B,OAAO,sBAAsB,UAAU,iBAAiB;AACzF,QAAM,6BAA6B,OAAO,sBAAsB,YAAY,oBAAoB;AAChG,SAAO,CAAC,0BAA0B,0BAA0B;AAC9D;;;ACrRA,IAAME,OAAM,OAAyC,8BAAS;AACvD,IAAMC,uBAAsBD,KAAI;AAChC,IAAME,4BAA2BF,KAAI;AACrC,IAAMG,uCAAsCH,KAAI;AAChD,IAAMI,2BAA0BJ,KAAI;AACpC,IAAMK,gCAA+BL,KAAI;AACzC,IAAMM,oBAAmBN,KAAI;AAC7B,IAAMO,6BAA4BP,KAAI;;;ALH7C,uBAAwC;;;AMZxC;AAAA;AAAA;AAAA;AASA,SAAS,sBAAsB,QAAQ;AACrC,QAAM,SAAS,OAAO,SAAS;AAC/B,QAAM,UAAU,WAAS;AACvB,QAAI,MAAM,WAAW,QAAQ;AAC3B;AAAA,IACF;AACA,UAAM,cAAc,OAAO,eAAe;AAC1C,QAAI,SAAS,kBAAkB,aAAa;AAC1C;AAAA,IACF;AACA,UAAM,OAAO,MAAM;AACnB,QAAI,OAAO,SAAS,UAAU;AAC5B,UAAI;AACJ,UAAI;AACF,qBAAa,KAAK,MAAM,IAAI;AAAA,MAC9B,SAAS,GAAG;AACV;AAAA,MACF;AACA,UAAI,cAAc,WAAW,aAAa,uBAAuB,WAAW,SAAS,WAAW;AAC9F,cAAM,UAAU,WAAW;AAC3B,YAAI,WAAW,QAAQ,eAAe,eAAe;AACnD,gBAAM,OAAO,QAAQ;AACrB,cAAI,MAAM;AACR,kBAAM,CAAC,cAAc,eAAe,MAAM,UAAU,WAAW,aAAa,IAAI;AAChF,mBAAO,OAAO,MAAM;AAClB,oBAAM,YAAY,cAAc;AAChC,kBAAI,kBAAkB,SAAS,GAAG;AAChC,sBAAM,SAAS,UAAU;AACzB,oBAAI,aAAa,OAAO,QAAQ;AAChC,oBAAI,cAAc;AAClB,oBAAI,YAAY;AAChB,oBAAI,YAAY,UAAU,GAAG;AAE3B,sBAAI,gBAAgB,KAAK,iBAAiB,GAAG;AAC3C,kCAAc;AACd,gCAAY,eAAe;AAE3B,8BAAU,iBAAiB,YAAY,aAAa,YAAY,SAAS;AAAA,kBAC3E;AAAA,gBACF;AACA,oBAAI,gBAAgB,aAAa,SAAS,IAAI;AAC5C,4BAAU,cAAc,IAAI;AAC5B,+BAAa,OAAO,QAAQ;AAAA,gBAC9B;AACA,oBAAI,YAAY,UAAU,GAAG;AAE3B,gCAAc;AACd,8BAAY,WAAW;AACvB,wBAAM,uBAAuB,WAAW,mBAAmB;AAE3D,gCAAc,cAAc,uBAAuB,uBAAuB;AAC1E,8BAAY,YAAY,uBAAuB,uBAAuB;AACtE,4BAAU,iBAAiB,YAAY,aAAa,YAAY,SAAS;AAAA,gBAC3E;AAGA,sBAAM,yBAAyB;AAAA,cACjC;AAAA,YACF,CAAC;AAAA,UACH;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACA,SAAO,iBAAiB,WAAW,SAAS,IAAI;AAChD,SAAO,MAAM;AACX,WAAO,oBAAoB,WAAW,SAAS,IAAI;AAAA,EACrD;AACF;;;ACrEA,IAAMQ,OAAM,OAAyC,gCAAS;AACvD,IAAMC,yBAAwBD,KAAI;;;ACTzC;AAAA;AAAA;AAAA;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAiBA,SAAS,sBAAsB,QAAQ,KAAK;AAC1C,QAAM,WAAW,IAAI,OAAO,IAAI,KAAK,aAAa,CAAC;AACnD,MAAI,eAAe,CAAC;AACpB,WAASE,KAAI,GAAGA,KAAI,SAAS,QAAQA,MAAK;AACxC,UAAM,UAAU,SAASA,EAAC;AAC1B,QAAI,CAAC,YAAY,IAAI,QAAQ,QAAQ,GAAG;AACtC,YAAM,cAAc,oBAAoB,SAAS,MAAM;AACvD,UAAI,gBAAgB,MAAM;AACxB,uBAAe,aAAa,OAAO,WAAW;AAAA,MAChD;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AACA,SAAS,uBAAuB,QAAQ,WAAW;AACjD,MAAI,OAAO,aAAa,eAAe,OAAO,WAAW,eAAe,OAAO,OAAO,WAAW,aAAa;AAC5G,UAAM,IAAI,MAAM,gJAAgJ;AAAA,EAClK;AACA,QAAM,YAAY,SAAS,cAAc,KAAK;AAC9C,QAAM,OAAO,SAAS;AACtB,QAAM,mBAAmB,KAAK,YAAY;AAC1C,WAASA,KAAI,GAAGA,KAAI,iBAAiB,QAAQA,MAAK;AAChD,UAAM,eAAe,iBAAiBA,EAAC;AACvC,uBAAmB,QAAQ,cAAc,WAAW,SAAS;AAAA,EAC/D;AACA,SAAO,UAAU;AACnB;AACA,SAAS,mBAAmB,QAAQ,aAAa,eAAe,YAAY,MAAM;AAChF,MAAI,gBAAgB,cAAc,OAAO,YAAY,WAAW,SAAS,IAAI;AAC7E,QAAM,gBAAgB,eAAe,WAAW,KAAK,YAAY,gBAAgB,MAAM;AACvF,MAAI,SAAS;AACb,MAAI,cAAc,MAAM;AACtB,QAAI,QAAQ,qBAAqB,WAAW;AAC5C,YAAQ,YAAY,KAAK,KAAK,cAAc,OAAO,8BAA8B,WAAW,KAAK,IAAI;AACrG,aAAS;AAAA,EACX;AACA,QAAM,WAAW,eAAe,MAAM,IAAI,OAAO,YAAY,IAAI,CAAC;AAClE,QAAM,iBAAiB,OAAO,OAAO,IAAI,OAAO,QAAQ,CAAC;AACzD,MAAI;AAGJ,MAAI,kBAAkB,eAAe,cAAc,QAAW;AAC5D,mBAAe,eAAe,UAAU,QAAQ,MAAM;AAAA,EACxD,OAAO;AACL,mBAAe,OAAO,UAAU,MAAM;AAAA,EACxC;AACA,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,EACF,IAAI;AACJ,MAAI,CAAC,SAAS;AACZ,WAAO;AAAA,EACT;AACA,QAAM,WAAW,SAAS,uBAAuB;AACjD,WAASA,KAAI,GAAGA,KAAI,SAAS,QAAQA,MAAK;AACxC,UAAM,YAAY,SAASA,EAAC;AAC5B,UAAM,qBAAqB,mBAAmB,QAAQ,WAAW,UAAU,SAAS;AACpF,QAAI,CAAC,iBAAiB,eAAe,WAAW,KAAK,sBAAsB,YAAY,iBAAiB,WAAW,WAAW,MAAM,GAAG;AACrI,sBAAgB;AAAA,IAClB;AAAA,EACF;AACA,MAAI,iBAAiB,CAAC,eAAe;AACnC,QAAI,cAAc,OAAO,GAAG;AAC1B,cAAQ,OAAO,QAAQ;AAAA,IACzB;AACA,kBAAc,OAAO,OAAO;AAC5B,QAAI,OAAO;AACT,YAAM,aAAa,MAAM,KAAK,QAAQ,OAAO;AAC7C,UAAI,YAAY;AACd,gBAAQ,YAAY,UAAU;AAAA,MAChC;AAAA,IACF;AAAA,EACF,OAAO;AACL,kBAAc,OAAO,QAAQ;AAAA,EAC/B;AACA,SAAO;AACT;AACA,SAAS,sBAAsB,SAAS,QAAQ;AAC9C,QAAM;AAAA,IACJ;AAAA,EACF,IAAI;AACJ,QAAM,oBAAoB,OAAO,iBAAiB,IAAI,SAAS,YAAY,CAAC;AAC5E,MAAI,oBAAoB;AACxB,MAAI,sBAAsB,QAAW;AACnC,eAAW,oBAAoB,mBAAmB;AAChD,YAAM,gBAAgB,iBAAiB,OAAO;AAC9C,UAAI,kBAAkB,SAAS,sBAAsB,SAAS,kBAAkB,YAAY,MAAM,cAAc,YAAY,KAAK;AAC/H,4BAAoB;AAAA,MACtB;AAAA,IACF;AAAA,EACF;AACA,SAAO,sBAAsB,OAAO,kBAAkB,aAAa;AACrE;AACA,IAAM,cAAc,oBAAI,IAAI,CAAC,SAAS,QAAQ,CAAC;AAC/C,SAAS,oBAAoB,MAAM,QAAQ,cAAc,oBAAI,IAAI,GAAG,mBAAmB;AACrF,MAAI,eAAe,CAAC;AACpB,MAAI,YAAY,IAAI,KAAK,QAAQ,GAAG;AAClC,WAAO;AAAA,EACT;AACA,MAAI,qBAAqB;AACzB,QAAM,oBAAoB,sBAAsB,MAAM,MAAM;AAC5D,QAAM,kBAAkB,oBAAoB,kBAAkB,IAAI,IAAI;AACtE,MAAI,gBAAgB;AACpB,MAAI,oBAAoB,MAAM;AAC5B,oBAAgB,gBAAgB;AAChC,UAAM,iBAAiB,gBAAgB;AACvC,yBAAqB,MAAM,QAAQ,cAAc,IAAI,eAAe,eAAe,SAAS,CAAC,IAAI;AACjG,QAAI,uBAAuB,MAAM;AAC/B,iBAAW,CAAC,EAAE,gBAAgB,KAAK,aAAa;AAC9C,6BAAqB,iBAAiB,oBAAoB,iBAAiB;AAC3E,YAAI,CAAC,oBAAoB;AACvB;AAAA,QACF;AAAA,MACF;AACA,UAAI,oBAAoB;AACtB,qBAAa,KAAK,GAAI,MAAM,QAAQ,cAAc,IAAI,iBAAiB,CAAC,kBAAkB,CAAE;AAAA,MAC9F;AAAA,IACF;AACA,QAAI,gBAAgB,YAAY,MAAM;AACpC,kBAAY,IAAI,KAAK,UAAU,gBAAgB,QAAQ;AAAA,IACzD;AAAA,EACF;AAIA,QAAM,WAAW,KAAK;AACtB,MAAI,oBAAoB,CAAC;AACzB,WAASA,KAAI,GAAGA,KAAI,SAAS,QAAQA,MAAK;AACxC,sBAAkB,KAAK,GAAG,oBAAoB,SAASA,EAAC,GAAG,QAAQ,IAAI,IAAI,WAAW,GAAG,kBAAkB,CAAC;AAAA,EAC9G;AACA,MAAI,iBAAiB,MAAM;AACzB,wBAAoB,cAAc,iBAAiB;AAAA,EACrD;AACA,MAAI,sBAAsB,MAAM;AAG9B,mBAAe,aAAa,OAAO,iBAAiB;AAAA,EACtD,OAAO;AACL,QAAI,eAAe,kBAAkB,GAAG;AAGtC,yBAAmB,OAAO,GAAG,iBAAiB;AAAA,IAChD;AAAA,EACF;AACA,SAAO;AACT;;;AC1JA,IAAMC,OAAM,OAAyC,8BAAS;AACvD,IAAMC,0BAAyBD,KAAI;AACnC,IAAME,yBAAwBF,KAAI;;;AFSzC,IAAMG,eAAc,OAAO,WAAW,eAAe,OAAO,OAAO,aAAa,eAAe,OAAO,OAAO,SAAS,kBAAkB;AASxI,IAAM,kBAAkB,kBAAgBA,gBAAe,gBAAgB,QAAQ,aAAa,IAAI;AAWhG,SAAS,gBAAgB,QAAQ;AAC/B,QAAM,YAAY,cAAc;AAChC,MAAI,aAAa,MAAM;AACrB;AACE,YAAM,MAAM,iCAAiC;AAAA,IAC/C;AAAA,EACF;AAGA,MAAI,kBAAkB,SAAS,KAAK,UAAU,YAAY,KAAK,UAAU,SAAS,EAAE,WAAW,GAAG;AAChG,WAAO;AAAA,EACT;AACA,SAAOC,wBAAuB,QAAQ,SAAS;AACjD;AAWA,SAAS,mBAAmB,QAAQ;AAClC,QAAM,YAAY,cAAc;AAChC,MAAI,aAAa,MAAM;AACrB;AACE,YAAM,MAAM,iCAAiC;AAAA,IAC/C;AAAA,EACF;AAGA,MAAI,kBAAkB,SAAS,KAAK,UAAU,YAAY,KAAK,UAAU,SAAS,EAAE,WAAW,GAAG;AAChG,WAAO;AAAA,EACT;AACA,SAAO,KAAK,UAAU,+BAA+B,QAAQ,SAAS,CAAC;AACzE;AAUA,SAAS,gCAAgC,cAAc,WAAW;AAChE,QAAM,OAAO,aAAa,QAAQ,YAAY,KAAK,aAAa,QAAQ,eAAe;AACvF,MAAI,QAAQ,MAAM;AAChB,cAAU,cAAc,IAAI;AAAA,EAC9B;AACF;AAWA,SAAS,+BAA+B,cAAc,WAAW,QAAQ;AACvE,QAAM,gBAAgB,aAAa,QAAQ,8BAA8B;AACzE,MAAI,eAAe;AACjB,QAAI;AACF,YAAM,UAAU,KAAK,MAAM,aAAa;AACxC,UAAI,QAAQ,cAAc,OAAO,QAAQ,aAAa,MAAM,QAAQ,QAAQ,KAAK,GAAG;AAClF,cAAM,QAAQ,kCAAkC,QAAQ,KAAK;AAC7D,eAAO,sBAAsB,QAAQ,OAAO,SAAS;AAAA,MACvD;AAAA,IACF,SAAS,SAAS;AAAA,IAElB;AAAA,EACF;AACA,QAAM,aAAa,aAAa,QAAQ,WAAW;AACnD,MAAI,YAAY;AACd,QAAI;AACF,YAAM,SAAS,IAAI,UAAU;AAC7B,YAAM,MAAM,OAAO,gBAAgB,YAAY,WAAW;AAC1D,YAAM,QAAQC,uBAAsB,QAAQ,GAAG;AAC/C,aAAO,sBAAsB,QAAQ,OAAO,SAAS;AAAA,IACvD,SAAS,UAAU;AAAA,IAEnB;AAAA,EACF;AAKA,QAAM,OAAO,aAAa,QAAQ,YAAY,KAAK,aAAa,QAAQ,eAAe;AACvF,MAAI,QAAQ,MAAM;AAChB,QAAI,kBAAkB,SAAS,GAAG;AAChC,YAAM,QAAQ,KAAK,MAAM,YAAY;AACrC,UAAI,MAAM,MAAM,SAAS,CAAC,MAAM,IAAI;AAClC,cAAM,IAAI;AAAA,MACZ;AACA,eAASC,KAAI,GAAGA,KAAI,MAAM,QAAQA,MAAK;AACrC,cAAM,OAAO,MAAMA,EAAC;AACpB,YAAI,SAAS,QAAQ,SAAS,QAAQ;AACpC,oBAAU,gBAAgB;AAAA,QAC5B,WAAW,SAAS,KAAM;AACxB,oBAAU,YAAY,CAAC,eAAe,CAAC,CAAC;AAAA,QAC1C,OAAO;AACL,oBAAU,WAAW,IAAI;AAAA,QAC3B;AAAA,MACF;AAAA,IACF,OAAO;AACL,gBAAU,cAAc,IAAI;AAAA,IAC9B;AAAA,EACF;AACF;AAYA,SAAS,sBAAsB,QAAQ,OAAO,WAAW;AACvD,MAAI,CAAC,OAAO,gBAAgB,0CAA0C;AAAA,IACpE;AAAA,IACA;AAAA,EACF,CAAC,GAAG;AACF,cAAU,YAAY,KAAK;AAAA,EAC7B;AACA;AACF;AACA,SAAS,iBAAiB,MAAM;AAC9B,QAAM,iBAAiB,KAAK,WAAW;AACvC,QAAM,YAAY,KAAK;AACvB,MAAI,eAAe,SAAS,UAAU,QAAQ,GAAG;AAC/C;AACE,YAAM,MAAM,qBAAqB,UAAU,IAAI,oCAAoC;AAAA,IACrF;AAAA,EACF;AACA,MAAI,eAAe,IAAI,GAAG;AACxB,UAAM,qBAAqB,eAAe;AAC1C,QAAI,CAAC,MAAM,QAAQ,kBAAkB,GAAG;AACtC;AACE,cAAM,MAAM,qBAAqB,UAAU,IAAI,kEAAkE;AAAA,MACnH;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AACA,SAAS,mBAAmB,QAAQ,WAAW,aAAa,cAAc,CAAC,GAAG;AAC5E,MAAI,gBAAgB,cAAc,OAAO,YAAY,WAAW,SAAS,IAAI;AAC7E,QAAM,gBAAgB,eAAe,WAAW,KAAK,YAAY,gBAAgB,MAAM;AACvF,MAAI,SAAS;AACb,MAAI,cAAc,MAAM;AACtB,QAAI,QAAQ,qBAAqB,WAAW;AAC5C,YAAQ,YAAY,KAAK,KAAK,cAAc,OAAO,8BAA8B,WAAW,KAAK,IAAI;AACrG,aAAS;AAAA,EACX;AACA,QAAM,WAAW,eAAe,MAAM,IAAI,OAAO,YAAY,IAAI,CAAC;AAClE,QAAM,iBAAiB,iBAAiB,MAAM;AAQ9C,MAAI,YAAY,MAAM,GAAG;AACvB,UAAM,OAAO,OAAO;AAIpB,QAAI,KAAK,SAAS,GAAG;AACnB,qBAAe,OAAO;AAAA,IACxB,OAAO;AACL,sBAAgB;AAAA,IAClB;AAAA,EACF;AACA,WAASA,KAAI,GAAGA,KAAI,SAAS,QAAQA,MAAK;AACxC,UAAM,YAAY,SAASA,EAAC;AAC5B,UAAM,qBAAqB,mBAAmB,QAAQ,WAAW,WAAW,eAAe,QAAQ;AACnG,QAAI,CAAC,iBAAiB,eAAe,WAAW,KAAK,sBAAsB,YAAY,iBAAiB,WAAW,WAAW,OAAO,GAAG;AACtI,sBAAgB;AAAA,IAClB;AAAA,EACF;AACA,MAAI,iBAAiB,CAAC,eAAe;AACnC,gBAAY,KAAK,cAAc;AAAA,EACjC,WAAW,MAAM,QAAQ,eAAe,QAAQ,GAAG;AACjD,aAASA,KAAI,GAAGA,KAAI,eAAe,SAAS,QAAQA,MAAK;AACvD,YAAM,sBAAsB,eAAe,SAASA,EAAC;AACrD,kBAAY,KAAK,mBAAmB;AAAA,IACtC;AAAA,EACF;AACA,SAAO;AACT;AAUA,SAAS,+BAA+B,QAAQ,WAAW;AACzD,QAAM,QAAQ,CAAC;AACf,QAAM,OAAO,SAAS;AACtB,QAAM,mBAAmB,KAAK,YAAY;AAC1C,WAASA,KAAI,GAAGA,KAAI,iBAAiB,QAAQA,MAAK;AAChD,UAAM,eAAe,iBAAiBA,EAAC;AACvC,uBAAmB,QAAQ,WAAW,cAAc,KAAK;AAAA,EAC3D;AACA,SAAO;AAAA,IACL,WAAW,OAAO,QAAQ;AAAA,IAC1B;AAAA,EACF;AACF;AAUA,SAAS,kCAAkC,iBAAiB;AAC1D,QAAM,QAAQ,CAAC;AACf,WAASA,KAAI,GAAGA,KAAI,gBAAgB,QAAQA,MAAK;AAC/C,UAAM,iBAAiB,gBAAgBA,EAAC;AACxC,UAAM,OAAO,qBAAqB,cAAc;AAChD,QAAI,YAAY,IAAI,GAAG;AACrB,oBAAc,IAAI;AAAA,IACpB;AACA,UAAM,KAAK,IAAI;AAAA,EACjB;AACA,SAAO;AACT;AACA,IAAM,gBAAgB;AACtB,IAAI,wBAAwB;AAa5B,eAAe,gBAAgB,QAAQ,OAAO;AAC5C,MAAI,0BAA0B,MAAM;AAGlC,WAAO;AAAA,EACT;AACA,MAAI,UAAU,MAAM;AAClB,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,aAAO,OAAO,MAAM;AAClB,gBAAQ,sBAAsB,QAAQ,KAAK,CAAC;AAAA,MAC9C,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AACA,QAAM,cAAc,OAAO,eAAe;AAC1C,QAAM,iBAAiB,OAAO,WAAW,OAAO,OAAO,WAAW,OAAO,QAAQ;AACjF,QAAM,eAAe,gBAAgB,OAAO,OAAO;AACnD,MAAI,gBAAgB,QAAQ,iBAAiB,MAAM;AACjD,WAAO;AAAA,EACT;AACA,QAAM,UAAU,eAAe,cAAc,MAAM;AACnD,UAAQ,MAAM,UAAU;AACxB,UAAQ,OAAO,eAAe,eAAe,GAAG,CAAC;AACjD,cAAY,OAAO,OAAO;AAC1B,QAAM,QAAQ,IAAI,MAAM;AACxB,QAAM,SAAS,SAAS,CAAC;AACzB,QAAM,OAAO,SAAS,CAAC;AACvB,eAAa,gBAAgB;AAC7B,eAAa,SAAS,KAAK;AAC3B,SAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,UAAM,iBAAiB,OAAO,gBAAgB,cAAc,iBAAe;AACzE,UAAI,kBAAkB,aAAa,cAAc,GAAG;AAClD,uBAAe;AACf,YAAI,0BAA0B,MAAM;AAClC,iBAAO,aAAa,qBAAqB;AACzC,kCAAwB;AAAA,QAC1B;AACA,gBAAQ,sBAAsB,QAAQ,WAAW,CAAC;AAAA,MACpD;AAEA,aAAO;AAAA,IACT,GAAG,yBAAyB;AAG5B,4BAAwB,OAAO,WAAW,MAAM;AAC9C,qBAAe;AACf,8BAAwB;AACxB,cAAQ,KAAK;AAAA,IACf,GAAG,aAAa;AAChB,mBAAe,YAAY,MAAM;AACjC,YAAQ,OAAO;AAAA,EACjB,CAAC;AACH;AAGA,SAAS,sBAAsB,QAAQ,OAAO;AAC5C,QAAM,eAAe,gBAAgB,OAAO,OAAO;AACnD,MAAI,CAAC,cAAc;AACjB,WAAO;AAAA,EACT;AACA,QAAM,YAAY,aAAa;AAC/B,QAAM,WAAW,aAAa;AAC9B,MAAI,cAAc,QAAQ,aAAa,QAAQ,CAAC,wBAAwB,QAAQ,WAAW,QAAQ,GAAG;AACpG,WAAO;AAAA,EACT;AACA,QAAM,eAAe;AACrB,QAAM,gBAAgB,MAAM;AAC5B,QAAM,YAAY,cAAc;AAChC,MAAI,kBAAkB,QAAQ,cAAc,MAAM;AAChD,WAAO;AAAA,EACT;AACA,QAAM,aAAa,gBAAgB,MAAM;AACzC,QAAM,gBAAgB,mBAAmB,MAAM;AAC/C,MAAI,cAAc;AAClB,MAAI,cAAc,MAAM;AACtB,kBAAc,UAAU,eAAe;AAAA,EACzC;AACA,MAAI,eAAe,MAAM;AACvB,kBAAc,QAAQ,aAAa,UAAU;AAAA,EAC/C;AACA,MAAI,kBAAkB,MAAM;AAC1B,kBAAc,QAAQ,gCAAgC,aAAa;AAAA,EACrE;AACA,gBAAc,QAAQ,cAAc,WAAW;AAC/C,SAAO;AACT;;;AGnXs1B,IAAM,IAAE,eAAa,OAAO,UAAQ,WAAS,OAAO,YAAU,WAAS,OAAO,SAAS;;;ACE76B,IAAMC,OAAM,OAAyC,mCAAS;AACvD,IAAMC,kCAAiCD,KAAI;AAC3C,IAAME,qCAAoCF,KAAI;AAC9C,IAAMG,mBAAkBH,KAAI;AAC5B,IAAMI,sBAAqBJ,KAAI;AAC/B,IAAMK,mCAAkCL,KAAI;AAC5C,IAAMM,kCAAiCN,KAAI;AAC3C,IAAMO,yBAAwBP,KAAI;AAClC,IAAMQ,mBAAkBR,KAAI;;;ALGnC,IAAMS,eAAc,OAAO,WAAW,eAAe,OAAO,OAAO,aAAa,eAAe,OAAO,OAAO,SAAS,kBAAkB;AASxI,IAAM,eAAeA,gBAAe,kBAAkB,WAAW,SAAS,eAAe;AACzFA,gBAAe,uBAAuB,KAAK,UAAU,QAAQ;AAC7DA,gBAAe,mCAAmC,KAAK,UAAU,SAAS;AAC1E,IAAM,uBAAuBA,gBAAe,gBAAgB,UAAU,CAAC,eAAe,qBAAqB,IAAI,OAAO,WAAW,OAAO,IAAI;AAC5I,IAAM,YAAYA,gBAAe,0BAA0B,KAAK,UAAU,SAAS;AACnF,IAAM,SAASA,gBAAe,mBAAmB,KAAK,UAAU,SAAS,KAAK,CAAC,OAAO;AACtF,IAAM,aAAaA,gBAAe,UAAU,KAAK,UAAU,SAAS;AAIpE,IAAM,YAAYA,gBAAe,mBAAmB,KAAK,UAAU,SAAS;AAI5E,IAAM,kBAAkBC,gBAAe,sBAAsB,KAAK,UAAU,SAAS,KAAK,CAAC;AAG3F,SAAS,mBAAmB,OAAO,QAAQ;AACzC,SAAO,OAAO,MAAM;AAClB,QAAI,UAAU,MAAM;AAClB,YAAM,gBAAgB,kBAAkB,OAAO,aAAa,IAAI,OAAO,MAAM;AAC7E,YAAM,YAAY,cAAc;AAChC,UAAI,cAAc,QAAQ,iBAAiB,MAAM;AAC/C,cAAM,eAAe;AACrB,cAAM,aAAaC,iBAAgB,MAAM;AACzC,YAAI,eAAe,MAAM;AACvB,wBAAc,QAAQ,aAAa,UAAU;AAAA,QAC/C;AACA,sBAAc,QAAQ,cAAc,UAAU,eAAe,CAAC;AAAA,MAChE;AAAA,IACF;AAAA,EACF,CAAC;AACH;AACA,SAAS,oBAAoB,OAAO,QAAQ;AAC1C,QAAM,eAAe;AACrB,SAAO,OAAO,MAAM;AAClB,UAAM,YAAY,cAAc;AAChC,UAAM;AAAA,MACJ;AAAA,IACF,IAAI;AACJ,QAAI,iBAAiB,QAAQ,kBAAkB,SAAS,GAAG;AACzD,MAAAC,iCAAgC,eAAe,SAAS;AAAA,IAC1D;AAAA,EACF,GAAG;AAAA,IACD,KAAK;AAAA,EACP,CAAC;AACH;AACA,SAAS,kBAAkB,OAAO,QAAQ;AACxC,qBAAmB,OAAO,MAAM;AAChC,SAAO,OAAO,MAAM;AAClB,UAAM,YAAY,cAAc;AAChC,QAAI,kBAAkB,SAAS,GAAG;AAChC,gBAAU,WAAW;AAAA,IACvB;AAAA,EACF,CAAC;AACH;AACA,SAAS,kBAAkB,QAAQ;AACjC,QAAM,iBAAiB,cAAc,OAAO,gBAAgB,0BAA0B,gBAAc;AAClG,UAAM,YAAY,cAAc;AAChC,QAAI,CAAC,kBAAkB,SAAS,GAAG;AACjC,aAAO;AAAA,IACT;AACA,cAAU,gBAAgB,UAAU;AACpC,WAAO;AAAA,EACT,GAAG,uBAAuB,GAAG,OAAO,gBAAgB,qBAAqB,gBAAc;AACrF,UAAM,YAAY,cAAc;AAChC,QAAI,CAAC,kBAAkB,SAAS,GAAG;AACjC,aAAO;AAAA,IACT;AACA,cAAU,WAAW,UAAU;AAC/B,WAAO;AAAA,EACT,GAAG,uBAAuB,GAAG,OAAO,gBAAgB,qBAAqB,gBAAc;AACrF,UAAM,YAAY,cAAc;AAChC,QAAI,CAAC,kBAAkB,SAAS,GAAG;AACjC,aAAO;AAAA,IACT;AACA,cAAU,WAAW,UAAU;AAC/B,WAAO;AAAA,EACT,GAAG,uBAAuB,GAAG,OAAO,gBAAgB,mCAAmC,iBAAe;AACpG,UAAM,YAAY,cAAc;AAChC,QAAI,CAAC,kBAAkB,SAAS,GAAG;AACjC,aAAO;AAAA,IACT;AACA,QAAI,OAAO,gBAAgB,UAAU;AACnC,gBAAU,WAAW,WAAW;AAAA,IAClC,OAAO;AACL,YAAM,eAAe,YAAY;AACjC,UAAI,gBAAgB,MAAM;AACxB,QAAAA,iCAAgC,cAAc,SAAS;AAAA,MACzD,OAAO;AACL,cAAM,OAAO,YAAY;AACzB,YAAI,MAAM;AACR,oBAAU,WAAW,IAAI;AAAA,QAC3B;AAAA,MACF;AAAA,IACF;AACA,WAAO;AAAA,EACT,GAAG,uBAAuB,GAAG,OAAO,gBAAgB,qBAAqB,MAAM;AAC7E,UAAM,YAAY,cAAc;AAChC,QAAI,CAAC,kBAAkB,SAAS,GAAG;AACjC,aAAO;AAAA,IACT;AACA,cAAU,WAAW;AACrB,WAAO;AAAA,EACT,GAAG,uBAAuB,GAAG,OAAO,gBAAgB,2BAA2B,iBAAe;AAC5F,UAAM,YAAY,cAAc;AAChC,QAAI,CAAC,kBAAkB,SAAS,GAAG;AACjC,aAAO;AAAA,IACT;AACA,cAAU,gBAAgB,WAAW;AACrC,WAAO;AAAA,EACT,GAAG,uBAAuB,GAAG,OAAO,gBAAgB,0BAA0B,MAAM;AAClF,UAAM,YAAY,cAAc;AAChC,QAAI,CAAC,kBAAkB,SAAS,GAAG;AACjC,aAAO;AAAA,IACT;AACA,cAAU,gBAAgB;AAC1B,WAAO;AAAA,EACT,GAAG,uBAAuB,GAAG,OAAO,gBAAgB,wBAAwB,aAAW;AACrF,UAAM,YAAY,cAAc;AAChC,QAAI,CAAC,kBAAkB,SAAS,GAAG;AACjC,aAAO;AAAA,IACT;AACA,UAAM,QAAQ;AACd,UAAM,iBAAiB,MAAM;AAC7B,QAAI,yCAAyC,WAAW,IAAI,GAAG;AAC7D,YAAM,eAAe;AACrB,qBAAe,WAAW,gBAAgB,IAAI;AAC9C,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT,GAAG,uBAAuB,GAAG,OAAO,gBAAgB,yBAAyB,aAAW;AACtF,UAAM,YAAY,cAAc;AAChC,QAAI,CAAC,kBAAkB,SAAS,GAAG;AACjC,aAAO;AAAA,IACT;AACA,UAAM,QAAQ;AACd,UAAM,iBAAiB,MAAM;AAC7B,QAAI,yCAAyC,WAAW,KAAK,GAAG;AAC9D,YAAM,eAAe;AACrB,qBAAe,WAAW,gBAAgB,KAAK;AAC/C,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT,GAAG,uBAAuB,GAAG,OAAO,gBAAgB,uBAAuB,WAAS;AAClF,UAAM,YAAY,cAAc;AAChC,QAAI,CAAC,kBAAkB,SAAS,GAAG;AACjC,aAAO;AAAA,IACT;AACA,UAAM,eAAe;AACrB,WAAO,OAAO,gBAAgB,0BAA0B,IAAI;AAAA,EAC9D,GAAG,uBAAuB,GAAG,OAAO,gBAAgB,oBAAoB,WAAS;AAC/E,UAAM,YAAY,cAAc;AAChC,QAAI,CAAC,kBAAkB,SAAS,GAAG;AACjC,aAAO;AAAA,IACT;AACA,UAAM,eAAe;AACrB,WAAO,OAAO,gBAAgB,0BAA0B,KAAK;AAAA,EAC/D,GAAG,uBAAuB,GAAG,OAAO,gBAAgB,mBAAmB,WAAS;AAC9E,UAAM,YAAY,cAAc;AAChC,QAAI,CAAC,kBAAkB,SAAS,GAAG;AACjC,aAAO;AAAA,IACT;AACA,QAAI,UAAU,MAAM;AAQlB,WAAK,UAAU,aAAa,oBAAoB,sBAAsB;AACpE,eAAO;AAAA,MACT;AACA,YAAM,eAAe;AAAA,IACvB;AACA,WAAO,OAAO,gBAAgB,2BAA2B,KAAK;AAAA,EAChE,GAAG,uBAAuB,GAAG,OAAO,gBAAgB,oBAAoB,MAAM;AAC5E,eAAW;AACX,WAAO;AAAA,EACT,GAAG,uBAAuB,GAAG,OAAO,gBAAgB,cAAc,WAAS;AACzE,UAAM,YAAY,cAAc;AAChC,QAAI,CAAC,kBAAkB,SAAS,GAAG;AACjC,aAAO;AAAA,IACT;AACA,uBAAmB,OAAO,MAAM;AAChC,WAAO;AAAA,EACT,GAAG,uBAAuB,GAAG,OAAO,gBAAgB,aAAa,WAAS;AACxE,UAAM,YAAY,cAAc;AAChC,QAAI,CAAC,kBAAkB,SAAS,GAAG;AACjC,aAAO;AAAA,IACT;AACA,sBAAkB,OAAO,MAAM;AAC/B,WAAO;AAAA,EACT,GAAG,uBAAuB,GAAG,OAAO,gBAAgB,eAAe,WAAS;AAC1E,UAAM,YAAY,cAAc;AAChC,QAAI,CAAC,kBAAkB,SAAS,GAAG;AACjC,aAAO;AAAA,IACT;AACA,wBAAoB,OAAO,MAAM;AACjC,WAAO;AAAA,EACT,GAAG,uBAAuB,GAAG,OAAO,gBAAgB,cAAc,WAAS;AACzE,UAAM,YAAY,cAAc;AAChC,QAAI,CAAC,kBAAkB,SAAS,GAAG;AACjC,aAAO;AAAA,IACT;AAGA,UAAM,eAAe;AACrB,WAAO;AAAA,EACT,GAAG,uBAAuB,GAAG,OAAO,gBAAgB,mBAAmB,WAAS;AAC9E,UAAM,YAAY,cAAc;AAChC,QAAI,CAAC,kBAAkB,SAAS,GAAG;AACjC,aAAO;AAAA,IACT;AAGA,UAAM,eAAe;AACrB,WAAO;AAAA,EACT,GAAG,uBAAuB,CAAC;AAC3B,SAAO;AACT;;;AMnPqzB,IAAM,IAAE,eAAa,OAAO,UAAQ,WAAS,OAAO,YAAU,WAAS,OAAO,SAAS;AAAvF,IAAqG,IAAE,KAAG,kBAAiB,WAAS,SAAS,eAAa;AAAK,KAAG,uBAAuB,KAAK,UAAU,QAAQ,GAAE,KAAG,mCAAmC,KAAK,UAAU,SAAS;AAAE,IAAM,IAAE,EAAE,CAAC,KAAG,EAAE,gBAAe,WAAS,MAAI,qBAAoB,IAAI,OAAO,WAAW,OAAO;AAA7F,IAA+F,IAAE,KAAG,0BAA0B,KAAK,UAAU,SAAS;AAAtJ,IAAwJ,IAAE,KAAG,mBAAmB,KAAK,UAAU,SAAS,KAAG,CAAC,OAAO;AAAnN,IAA4N,KAAG,KAAG,UAAU,KAAK,UAAU,SAAS,GAAE,KAAG,mBAAmB,KAAK,UAAU,SAAS;AAApT,IAAuT,IAAE,KAAG,sBAAsB,KAAK,UAAU,SAAS,KAAG,CAAC;;;ACEr7C,IAAMC,OAAM,OAAyC,mCAAS;AACvD,IAAMC,qBAAoBD,KAAI;;;AferC,IAAME,eAAc,OAAO,WAAW,eAAe,OAAO,OAAO,aAAa,eAAe,OAAO,OAAO,SAAS,kBAAkB;AASxI,IAAMC,uBAAsBD,eAAc,cAAAE,kBAAoB;AAC9D,IAAIC,mBAAkBF;AAStB,SAAS,yCAAyC,QAAQ;AACxD,QAAM,4BAA4B,OAAO,eAAe,EAAE,KAAKG,0BAAyB,OAAO,YAAY,CAAC,CAAC;AAC7G,SAAO;AACT;AACA,SAAS,sBAAsB,QAAQ;AACrC,QAAM,CAAC,oBAAoB,qBAAqB,QAAI,wBAAS,MAAM,yCAAyC,MAAM,CAAC;AACnH,EAAAD,iBAAgB,MAAM;AACpB,aAAS,0BAA0B;AACjC,YAAM,4BAA4B,yCAAyC,MAAM;AACjF,4BAAsB,yBAAyB;AAAA,IACjD;AACA,4BAAwB;AACxB,WAAO,cAAc,OAAO,uBAAuB,MAAM;AACvD,8BAAwB;AAAA,IAC1B,CAAC,GAAG,OAAO,yBAAyB,MAAM;AACxC,8BAAwB;AAAA,IAC1B,CAAC,CAAC;AAAA,EACJ,GAAG,CAAC,MAAM,CAAC;AACX,SAAO;AACT;AASA,SAAS,cAAc,QAAQ,eAAe;AAC5C,QAAM,CAAC,YAAY,aAAa,QAAI,wBAAS,MAAM,OAAO,cAAc,CAAC;AAGzE,EAAAA,iBAAgB,MAAM;AACpB,WAAO,OAAO,0BAA0B,oBAAkB;AACxD,sCAAU,MAAM;AACd,sBAAc,cAAc;AAAA,MAC9B,CAAC;AAAA,IACH,CAAC;AAAA,EACH,GAAG,CAAC,MAAM,CAAC;AACX,+BAAU,MAAM;AAId,kBAAc,OAAO,cAAc,CAAC;AAAA,EACtC,GAAG,CAAC,MAAM,CAAC;AAGX,aAAO,uBAAQ,MAAM;AACnB,UAAM,mBAAmB,CAAC;AAC1B,UAAM,gBAAgB,OAAO,KAAK,UAAU;AAC5C,aAASE,KAAI,GAAGA,KAAI,cAAc,QAAQA,MAAK;AAC7C,YAAM,UAAU,cAAcA,EAAC;AAC/B,YAAM,iBAAoC,oBAAc,eAAe;AAAA,QACrE,SAAS,OAAK,OAAO,SAAS,CAAC;AAAA,MACjC,GAAsB,oBAAc,wBAAU;AAAA,QAC5C,UAAU;AAAA,MACZ,GAAG,WAAW,OAAO,CAAC,CAAC;AACvB,YAAM,UAAU,OAAO,gBAAgB,OAAO;AAC9C,UAAI,YAAY,MAAM;AACpB,yBAAiB,SAAmB,+BAAa,gBAAgB,SAAS,OAAO,CAAC;AAAA,MACpF;AAAA,IACF;AACA,WAAO;AAAA,EACT,GAAG,CAAC,eAAe,YAAY,MAAM,CAAC;AACxC;AASA,SAAS,kBAAkB,QAAQ;AACjC,EAAAF,iBAAgB,MAAM;AACpB,WAAO,cAAcG,mBAAkB,MAAM,GAAGC,uBAAsB,MAAM,CAAC;AAAA,EAI/E,GAAG,CAAC,MAAM,CAAC;AACb;AASA,SAAS,gBAAgB;AAAA,EACvB;AAAA,EACA;AAAA,EACA;AACF,GAAG;AACD,QAAM,CAAC,MAAM,IAAI,0BAA0B;AAC3C,QAAM,aAAa,cAAc,QAAQ,aAAa;AACtD,oBAAkB,MAAM;AACxB,SAA0B,oBAAoB,gBAAU,MAAM,iBAAoC,oBAAc,aAAa;AAAA,IAC3H,SAAS;AAAA,EACX,CAAC,GAAG,UAAU;AAChB;AACA,SAAS,YAAY;AAAA,EACnB;AACF,GAAG;AACD,QAAM,CAAC,MAAM,IAAI,0BAA0B;AAC3C,QAAM,kBAAkB,sBAAsB,MAAM;AACpD,QAAM,WAAW,+BAAmB;AACpC,MAAI,CAAC,iBAAiB;AACpB,WAAO;AAAA,EACT;AACA,MAAI,OAAO,YAAY,YAAY;AACjC,WAAO,QAAQ,QAAQ;AAAA,EACzB,OAAO;AACL,WAAO;AAAA,EACT;AACF;;;AgBxJmI,IAAAC,KAAgB;AAAQ,IAAAC,gBAAwF;AAAgH,IAAAC,oBAA4C;AAA4H,IAAI,IAAE,eAAa,OAAO,UAAQ,WAAS,OAAO,YAAU,WAAS,OAAO,SAAS,gBAAc,cAAAC,kBAAE,cAAAC;;;ACEhnB,IAAMC,OAAM,OAAyC,yCAAS;AACvD,IAAMC,mBAAkBD,KAAI;",
  "names": ["useLayoutEffect$1", "subscription", "import_react", "t", "n", "import_react", "i", "s", "mod", "$canShowPlaceholder", "$canShowPlaceholderCurry", "$findTextIntersectionFromCharacters", "$isRootTextContentEmpty", "$isRootTextContentEmptyCurry", "$rootTextContent", "registerLexicalTextEntity", "mod", "registerDragonSupport", "i", "mod", "$generateHtmlFromNodes", "$generateNodesFromDOM", "CAN_USE_DOM", "$generateHtmlFromNodes", "$generateNodesFromDOM", "i", "mod", "$generateJSONFromSelectedNodes", "$generateNodesFromSerializedNodes", "$getHtmlContent", "$getLexicalContent", "$insertDataTransferForPlainText", "$insertDataTransferForRichText", "$insertGeneratedNodes", "copyToClipboard", "CAN_USE_DOM", "CAN_USE_DOM", "$getHtmlContent", "$insertDataTransferForPlainText", "mod", "registerPlainText", "CAN_USE_DOM", "useLayoutEffectImpl", "useLayoutEffect$1", "useLayoutEffect", "$canShowPlaceholderCurry", "i", "registerPlainText", "registerDragonSupport", "r", "import_react", "import_react_dom", "o", "n", "mod", "PlainTextPlugin"]
}
